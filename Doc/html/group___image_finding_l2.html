<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLAMERDOC++: Image Finding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Finding<div class="ingroups"><a class="el" href="group___mid_level.html">Mid Level Routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for finding and characterizing images.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Image Finding:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___image_finding_l2.png" border="0" alt="" usemap="#group______image__finding__l2"/>
<map name="group______image__finding__l2" id="group______image__finding__l2">
<area shape="rect" id="node1" href="group___mid_level.html" title="These are routines that might be used by a user. " alt="" coords="6,5,141,33"/></map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga48107c0fed9a62e11a567ecf7067914f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga48107c0fed9a62e11a567ecf7067914f">DirtyFoF</a> (std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, int *Nimages, PosType linkinglength)</td></tr>
<tr class="memdesc:ga48107c0fed9a62e11a567ecf7067914f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides kist of points into friends-of-friends groups with. Does not need a tree to be built, but takes N^2 time so it is not good for a large number of points.  <a href="#ga48107c0fed9a62e11a567ecf7067914f">More...</a><br /></td></tr>
<tr class="separator:ga48107c0fed9a62e11a567ecf7067914f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a604ea0f846665ffd08b62e882255aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga1a604ea0f846665ffd08b62e882255aa">DirtyDivider</a> (<a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo, int *Nimages, int MaxNimages, int Ngroup)</td></tr>
<tr class="memdesc:ga1a604ea0f846665ffd08b62e882255aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides kist of points into groups.  <a href="#ga1a604ea0f846665ffd08b62e882255aa">More...</a><br /></td></tr>
<tr class="separator:ga1a604ea0f846665ffd08b62e882255aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70aa5fea432a351b2bd71dfa84892429"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga70aa5fea432a351b2bd71dfa84892429"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga70aa5fea432a351b2bd71dfa84892429">find_divide_images</a> (<a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree, <a class="el" href="struct_tree_struct.html">TreeHndl</a> s_tree, PosType *source_x, PosType source_r, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, int *Nimages)</td></tr>
<tr class="memdesc:ga70aa5fea432a351b2bd71dfa84892429"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the points that are within the circular source and divides the images. <br /></td></tr>
<tr class="separator:ga70aa5fea432a351b2bd71dfa84892429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000476cfc3aa55d3b896ceff5d89ff9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga000476cfc3aa55d3b896ceff5d89ff9f">divide_images_kist</a> (<a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, int *Nimages)</td></tr>
<tr class="memdesc:ga000476cfc3aa55d3b896ceff5d89ff9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divides the image points up into separate images that are linked by cell neighbors.  <a href="#ga000476cfc3aa55d3b896ceff5d89ff9f">More...</a><br /></td></tr>
<tr class="separator:ga000476cfc3aa55d3b896ceff5d89ff9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e6f3a57cd89680b0dccf18999c900be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga8e6f3a57cd89680b0dccf18999c900be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga8e6f3a57cd89680b0dccf18999c900be">partition_images</a> (<a class="el" href="struct_point.html">Point</a> *point, unsigned long *N_in_image, <a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree)</td></tr>
<tr class="memdesc:ga8e6f3a57cd89680b0dccf18999c900be"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive function that un-marks all the points that are attached to point by cell neighbors that were previously marked in_image==YES <br /></td></tr>
<tr class="separator:ga8e6f3a57cd89680b0dccf18999c900be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5de71abe41930d1dc3502a75d1a17e3"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gad5de71abe41930d1dc3502a75d1a17e3">partition_images_kist</a> (<a class="el" href="struct_point.html">Point</a> *point, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *imagekist, <a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree)</td></tr>
<tr class="separator:gad5de71abe41930d1dc3502a75d1a17e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada95fb817758ef1d0bffadb790083124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gada95fb817758ef1d0bffadb790083124">findborders4</a> (<a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree, <a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo)</td></tr>
<tr class="memdesc:gada95fb817758ef1d0bffadb790083124"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds inner and outer borders of an image using bordering box method.  <a href="#gada95fb817758ef1d0bffadb790083124">More...</a><br /></td></tr>
<tr class="separator:gada95fb817758ef1d0bffadb790083124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84c7d7f490494d2a457595d93299a9c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga84c7d7f490494d2a457595d93299a9c1">CollectTrash</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *trashkist, bool check)</td></tr>
<tr class="memdesc:ga84c7d7f490494d2a457595d93299a9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty trash points.  <a href="#ga84c7d7f490494d2a457595d93299a9c1">More...</a><br /></td></tr>
<tr class="separator:ga84c7d7f490494d2a457595d93299a9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28c70386a2785138fdfbaed0fd35b5e5"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga28c70386a2785138fdfbaed0fd35b5e5">FreeBranchesBelow</a> (<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;i_tree_current, <a class="el" href="struct_tree_struct.html">TreeHndl</a> i_tree, <a class="el" href="struct_tree_struct.html">TreeHndl</a> s_tree, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *trashkist)</td></tr>
<tr class="separator:ga28c70386a2785138fdfbaed0fd35b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2864fc3791c44eed90c2e980777884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884">Grid::RefineLeaf</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:gaef2864fc3791c44eed90c2e980777884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental function used to divide a leaf in the tree into nine subcells.  <a href="#gaef2864fc3791c44eed90c2e980777884">More...</a><br /></td></tr>
<tr class="separator:gaef2864fc3791c44eed90c2e980777884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1d61941f50776c7133ead2f5ea87117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gaa1d61941f50776c7133ead2f5ea87117">ImageFinding::image_finder_kist</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, PosType *y_source, PosType r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, short splitparities, short true_images)</td></tr>
<tr class="memdesc:gaa1d61941f50776c7133ead2f5ea87117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images for a given source position and size. Not meant for high level user.  <a href="#gaa1d61941f50776c7133ead2f5ea87117">More...</a><br /></td></tr>
<tr class="separator:gaa1d61941f50776c7133ead2f5ea87117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a61b57e20ce0984d968c53fd7820b82"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga9a61b57e20ce0984d968c53fd7820b82">ImageFinding::IF_routines::refine_grid_kist</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, <a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo, int Nimages, double res_target, short criterion, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *newpointkist=NULL, bool batch=true)</td></tr>
<tr class="memdesc:ga9a61b57e20ce0984d968c53fd7820b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines every point in the given image and its outer border that satisfies the refinement criterion.  <a href="#ga9a61b57e20ce0984d968c53fd7820b82">More...</a><br /></td></tr>
<tr class="separator:ga9a61b57e20ce0984d968c53fd7820b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ca903fb4c7ae94e69157bb5e2cdb89d"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga4ca903fb4c7ae94e69157bb5e2cdb89d">TreeStruct::PointsWithinKist</a> (const PosType *center, PosType rmax, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist, short markpoints) const </td></tr>
<tr class="memdesc:ga4ca903fb4c7ae94e69157bb5e2cdb89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all points in tree that lie within rmax of the point ray[].  <a href="#ga4ca903fb4c7ae94e69157bb5e2cdb89d">More...</a><br /></td></tr>
<tr class="separator:ga4ca903fb4c7ae94e69157bb5e2cdb89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0423162f8437cfc3e8129d4b304bd19d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga0423162f8437cfc3e8129d4b304bd19d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga0423162f8437cfc3e8129d4b304bd19d">TreeStruct::PointsWithinKist_iter</a> (const PosType *center, float rmin, float rmax, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist) const </td></tr>
<tr class="memdesc:ga0423162f8437cfc3e8129d4b304bd19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all points within a circle. Much simpler, iterative algorithm. <br /></td></tr>
<tr class="separator:ga0423162f8437cfc3e8129d4b304bd19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76668d1516ab7ddb2b7cdefa470d3419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga76668d1516ab7ddb2b7cdefa470d3419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga76668d1516ab7ddb2b7cdefa470d3419">TreeStruct::FillTree</a> (<a class="el" href="struct_point.html">Point</a> *xp, unsigned long Npoints)</td></tr>
<tr class="memdesc:ga76668d1516ab7ddb2b7cdefa470d3419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a tree with points. The previous tree structure will be destroyed. Used for refilling. <br /></td></tr>
<tr class="separator:ga76668d1516ab7ddb2b7cdefa470d3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga427822306514170bb89a5d529a6cb565"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga427822306514170bb89a5d529a6cb565">TreeStruct::RebuildTreeFromList</a> ()</td></tr>
<tr class="memdesc:ga427822306514170bb89a5d529a6cb565"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rebuilds the tree from the points that are already in the tree-&gt;pointlist.  <a href="#ga427822306514170bb89a5d529a6cb565">More...</a><br /></td></tr>
<tr class="separator:ga427822306514170bb89a5d529a6cb565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22011842bc8af6c0770f23e4cf192a87"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#ga22011842bc8af6c0770f23e4cf192a87">TreeStruct::emptyTree</a> ()</td></tr>
<tr class="memdesc:ga22011842bc8af6c0770f23e4cf192a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Empty tree of all point leaving a tree with an empty root.  <a href="#ga22011842bc8af6c0770f23e4cf192a87">More...</a><br /></td></tr>
<tr class="separator:ga22011842bc8af6c0770f23e4cf192a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa57c8f27fb818e4c45e75cfda1cee0ec"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa57c8f27fb818e4c45e75cfda1cee0ec"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gaa57c8f27fb818e4c45e75cfda1cee0ec">TreeStruct::AddPointsToTree</a> (<a class="el" href="struct_point.html">Point</a> *xpoint, unsigned long Nadd)</td></tr>
<tr class="memdesc:gaa57c8f27fb818e4c45e75cfda1cee0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands tree by adding points. <br /></td></tr>
<tr class="separator:gaa57c8f27fb818e4c45e75cfda1cee0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gac8142d1e6206e19c8f83d21aee7fd03c">Grid::PrunePointsOutside</a> (double resolution, double *y, double r_in, double r_out)</td></tr>
<tr class="memdesc:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune off points that are below a resolution and in an annulus on the source plane.  <a href="#gac8142d1e6206e19c8f83d21aee7fd03c">More...</a><br /></td></tr>
<tr class="separator:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Routines for finding and characterizing images. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga84c7d7f490494d2a457595d93299a9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CollectTrash </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>trashkist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty trash points. </p>
<p>Frees point arrays whose heads are stored in trashlist. If check=true if will only free arrays where all the points have NULL leafs. check=false all the point arrays are freed.. </p>

</div>
</div>
<a class="anchor" id="ga1a604ea0f846665ffd08b62e882255aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DirtyDivider </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>MaxNimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ngroup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides kist of points into groups. </p>
<p>Does not need a tree to be built, but takes N^2 time so it is not good for a large number of points.</p>
<p>On entry all points must be in imageinfo[0].imagekist. On exit they are divided into imageinfo[0...*Nimages=1].imagekist with each containing approximately &lt;= Ngroup points. The left most point is used as a seed to start the first group and the closest Ngroup points are found. If there are not Ngroup points left, they are all put into one group. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageinfo</td><td>Contains the kists of points in each image </td></tr>
    <tr><td class="paramname">Nimages</td><td>Number of images </td></tr>
    <tr><td class="paramname">MaxNimages</td><td>Maximum size of imageinfo array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga48107c0fed9a62e11a567ecf7067914f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DirtyFoF </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>linkinglength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides kist of points into friends-of-friends groups with. Does not need a tree to be built, but takes N^2 time so it is not good for a large number of points. </p>
<p>On entry all points must be in imageinfo[0].imagekist. On exit they are divided into imageinfo[0...*Nimages=1].imagekist</p>
<p>If linkinglength &gt; 0.0 a fixed linkinglength is used. If &lt;= 0.0 the SQRT(2)*(gridsize + gridsize) is used for a linking length. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageinfo</td><td>Contains the kists of points in each image </td></tr>
    <tr><td class="paramname">Nimages</td><td>Number of images </td></tr>
    <tr><td class="paramname">linkinglength</td><td>linking length, If it is &lt;= 0 the gridsize's for the points is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga000476cfc3aa55d3b896ceff5d89ff9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void divide_images_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td>
          <td class="paramname"><em>i_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divides the image points up into separate images that are linked by cell neighbors. </p>
<p>divide_images_kist</p>
<p>Should scale like NlogN instead of N^2. This is achieved with a recursive algorithm.</p>
<p>on entering: imageinfo[0].imagekist must contain all the point in all the images in any order. The flags in_image == NO for all points in i_tree and their images that are not in the image. Not required that points in the image be flagged. on exit: Nimages is updated imageinfo[i].imagekist is set to the points in ith image image point flags in_image == YES the area and area_error of each image are calculated</p>
<p>imageinfo[i].ShouldNotRefile = 0 is set for every image.</p>
<p>Calculates images' geometric centers and area's. </p>

</div>
</div>
<a class="anchor" id="ga22011842bc8af6c0770f23e4cf192a87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TreeStruct::emptyTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Empty tree of all point leaving a tree with an empty root. </p>
<p>The points are freed, but the list structure is not destroyed.</p>
<p>FillTree can then be used to regenerate tree. </p>

</div>
</div>
<a class="anchor" id="gada95fb817758ef1d0bffadb790083124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void findborders4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td>
          <td class="paramname"><em>i_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *&#160;</td>
          <td class="paramname"><em>imageinfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds inner and outer borders of an image using bordering box method. </p>
<p>uses the in_image markers uses imaginfo-&gt;imagekist instead of imageinfo-&gt;points</p>
<p>In the case of the entire grid being within the image, the innerborders is the border points of the grid and the outerborder contains no points.</p>
<p>Note: Markers in_image must be preset to true for all image points and false for non-image points. </p>

</div>
</div>
<a class="anchor" id="ga28c70386a2785138fdfbaed0fd35b5e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long FreeBranchesBelow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>i_tree_current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td>
          <td class="paramname"><em>i_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td>
          <td class="paramname"><em>s_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>trashkist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees all branches of the tree below the current branch in i_tree if that branch is square and i_tree-&gt;current-&gt;refined == true. If either of these are not true nothing happens.</p>
<p>On exit: The i_tree-&gt;current is back to the original current. If it is square it will have no children and contain one point. The source points and branches are also removed. </p>

</div>
</div>
<a class="anchor" id="gaa1d61941f50776c7133ead2f5ea87117"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::image_finder_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>splitparities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>true_images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images for a given source position and size. Not meant for high level user. </p>
<p>image points are put into imageinfo[].imagekist imageinfo[].points and imageinfo[].Npoints are not changed</p>
<p>splitparities= 0 don't split attached negative and positive parity images = 1 do split parities NOTE: this is now obsolete = -1 doesn't slit into images at all , also does not find borders or change in_image markers true_images = 1 gives just the points that are in the image = 0 if there are not enough points in images this will include close points to be refined</p>
<p>side-effects : Will make in_image = true for all image points if splitparities == 0 </p>

</div>
</div>
<a class="anchor" id="gad5de71abe41930d1dc3502a75d1a17e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType partition_images_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>imagekist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td>
          <td class="paramname"><em>i_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>finds all the points in i_tree with in_image = YES that are connected to point by cell neighbors of cell neighbors. The resulting kist of points is left in imagekist. The in_image marks are NOT returned to their original values. The ones that are put into imagekist are changed to in_image = NO </p>

</div>
</div>
<a class="anchor" id="ga4ca903fb4c7ae94e69157bb5e2cdb89d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType TreeStruct::PointsWithinKist </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighborkist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>markpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all points in tree that lie within rmax of the point ray[]. </p>
<p>markpoints = 0 does not change in_image variable in any point, gives a list of neighbors = 1 makes in_image=YES for all points and their images in image, gives no list of neighbors = -1 makes in_image=NO for all points in image to reset, gives no list of neighbors</p>
<p>Returns the largest gridsize of the points within the circle. Note that this is the gridsize stored in the point. If finding points on the source plane the i_point-&gt;gridsize must be set to the same as the image point to get the largest gridsize on the image plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of circle </td></tr>
    <tr><td class="paramname">rmax</td><td>radius of circle </td></tr>
    <tr><td class="paramname">neighborkist</td><td>output neighbor kist, will be emptied if it contains anything on entry </td></tr>
    <tr><td class="paramname">markpoints</td><td>see comment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac8142d1e6206e19c8f83d21aee7fd03c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Grid::PrunePointsOutside </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prune off points that are below a resolution and in an annulus on the source plane. </p>
<p>Used to keep the number of grid points limited while telescoping.</p>
<p>The points that are removed have cells that do not overlap the inner circle and centers that are within the outer circle. Thus some points will be outside of the inner circle and some cells that are not removed may intersect with the outer circle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>Maximum size of a cell to be removed. </td></tr>
    <tr><td class="paramname">y</td><td>Center on source plane </td></tr>
    <tr><td class="paramname">r_in</td><td>Inner radius of annulus on the source plane </td></tr>
    <tr><td class="paramname">r_out</td><td>Outer radius of annulus on the source plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga427822306514170bb89a5d529a6cb565"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::RebuildTreeFromList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rebuilds the tree from the points that are already in the tree-&gt;pointlist. </p>
<p>This is not the best function because it copies all the points </p>

</div>
</div>
<a class="anchor" id="ga9a61b57e20ce0984d968c53fd7820b82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ImageFinding::IF_routines::refine_grid_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>newpointskist</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>batch</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines every point in the given image and its outer border that satisfies the refinement criterion. </p>
<p>Same as refine_grid with additions</p><ul>
<li>uses imageinfo-&gt;imagekist instead of imageinfo-&gt;points[]</li>
<li>can export rayshooting</li>
<li>Does not affect imageinfo-&gt;points in any way</li>
<li>Allows for refinements to be done on the borders of the initial grid region The initial grid region is never expanded.</li>
</ul>
<p>The borders of the image must be found previously.</p>
<p>criterion = 0 stops refining when error in total area reaches res_target = 1 stops refining when each image reaches error limit or is smaller than res_target, (imageinfo[i].area_error &gt; res_target)*(imageinfo[i].area &gt; 1.0e-2*res_target*total_area) = 2 stops refining when grid resolution is smaller than res_target in all images = 3 stops refining when each image reaches error limit or imageinfo[i].ShouldNotRefine == true</p>
<p>Returns the number of points that were added to the grids. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>the lens model </td></tr>
    <tr><td class="paramname">grid</td><td>the grid </td></tr>
    <tr><td class="paramname">imageinfo</td><td>images </td></tr>
    <tr><td class="paramname">Nimages</td><td>Number of images to refine </td></tr>
    <tr><td class="paramname">res_target</td><td>meaning depends on criterion, see general notes </td></tr>
    <tr><td class="paramname">criterion</td><td>see general notes </td></tr>
    <tr><td class="paramname">newpointskist</td><td>returns a Kist of the points that were added to the grid on this pass, if == NULL will not be added </td></tr>
    <tr><td class="paramname">batch</td><td>True, passes all points to rayshooter at once, False shoots rays each cell at a time and new points are in memory blocks of 8 or smaller </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaef2864fc3791c44eed90c2e980777884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point.html">Point</a> * Grid::RefineLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fundamental function used to divide a leaf in the tree into nine subcells. </p>
<p><a class="el" href="class_source.html" title="Base class for all sources. ">Source</a> and image points are created, linked, shot and added to the trees. The leaf pointers of the points including the input are assigned.</p>
<p>If some of the of the points are outside the original grid they will not be added in which case THERE WILL BE LESS THEN Ngrid*Ngrid-1 points added. The true number will be result-&gt;head or, if no points are added, result = NULL.</p>
<p>Returns a pointer to the list of image points that have been added. This array can then be used for calculating the surface brightness or marking them as in the image.</p>
<p>i_tree current is left in one of the new subcells. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 24 2019 10:15:21 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
