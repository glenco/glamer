<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Lens Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_lens-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Lens Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A class to represents a lens with multiple planes.  
 <a href="class_lens.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lens_8h_source.html">lens.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a911b9ca1ee4ba99ed6e56b58d33af1e0"><td class="memItemLeft" align="right" valign="top"><a id="a911b9ca1ee4ba99ed6e56b58d33af1e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a911b9ca1ee4ba99ed6e56b58d33af1e0">Lens</a> (long *seed, PosType z_source, CosmoParamSet cosmoset=WMAP5yr, bool verbose=false)</td></tr>
<tr class="memdesc:a911b9ca1ee4ba99ed6e56b58d33af1e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty lens. Main halos and field halos need to be inserted by hand from the user. <br /></td></tr>
<tr class="separator:a911b9ca1ee4ba99ed6e56b58d33af1e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93bddcc7b090035073061909626cb762"><td class="memItemLeft" align="right" valign="top"><a id="a93bddcc7b090035073061909626cb762"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a93bddcc7b090035073061909626cb762">Lens</a> (<a class="el" href="class_input_params.html">InputParams</a> &amp;params, long *my_seed, CosmoParamSet cosmoset=WMAP5yr, bool verbose=false)</td></tr>
<tr class="memdesc:a93bddcc7b090035073061909626cb762"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates space for the halo trees and the inout lens, if there is any <br /></td></tr>
<tr class="separator:a93bddcc7b090035073061909626cb762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35c838440ad6d526e402492be04fc3"><td class="memItemLeft" align="right" valign="top"><a id="a7d35c838440ad6d526e402492be04fc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b> (long *seed, PosType z_source, const <a class="el" href="class_c_o_s_m_o_l_o_g_y.html">COSMOLOGY</a> &amp;cosmo, bool verbose=false)</td></tr>
<tr class="separator:a7d35c838440ad6d526e402492be04fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a601c95658ea2f20715d12dc6b16bc"><td class="memItemLeft" align="right" valign="top"><a id="a16a601c95658ea2f20715d12dc6b16bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a16a601c95658ea2f20715d12dc6b16bc">Lens</a> (<a class="el" href="class_input_params.html">InputParams</a> &amp;params, long *my_seed, const <a class="el" href="class_c_o_s_m_o_l_o_g_y.html">COSMOLOGY</a> &amp;cosmo, bool verbose=false)</td></tr>
<tr class="memdesc:a16a601c95658ea2f20715d12dc6b16bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">allocates space for the halo trees and the inout lens, if there is any <br /></td></tr>
<tr class="separator:a16a601c95658ea2f20715d12dc6b16bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce0eee4b6bf7070d5524d27b3474168"><td class="memItemLeft" align="right" valign="top"><a id="a0ce0eee4b6bf7070d5524d27b3474168"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a0ce0eee4b6bf7070d5524d27b3474168">getNplanes</a> () const</td></tr>
<tr class="memdesc:a0ce0eee4b6bf7070d5524d27b3474168"><td class="mdescLeft">&#160;</td><td class="mdescRight">the total number of lens planes <br /></td></tr>
<tr class="separator:a0ce0eee4b6bf7070d5524d27b3474168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4269648ebbcbfcb1df353a92a5da2710"><td class="memItemLeft" align="right" valign="top"><a id="a4269648ebbcbfcb1df353a92a5da2710"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a4269648ebbcbfcb1df353a92a5da2710">getfov</a> () const</td></tr>
<tr class="memdesc:a4269648ebbcbfcb1df353a92a5da2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">field of view in square degrees <br /></td></tr>
<tr class="separator:a4269648ebbcbfcb1df353a92a5da2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32d8eedc7ff362eed924f1dacea54ad"><td class="memItemLeft" align="right" valign="top"><a id="ac32d8eedc7ff362eed924f1dacea54ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setfov</b> (PosType fov)</td></tr>
<tr class="separator:ac32d8eedc7ff362eed924f1dacea54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2196496f170af2ee0a410ba064e2fa"><td class="memItemLeft" align="right" valign="top"><a id="a1f2196496f170af2ee0a410ba064e2fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a1f2196496f170af2ee0a410ba064e2fa">resetFieldNplanes</a> (std::size_t field_Nplanes, bool verbose=false)</td></tr>
<tr class="memdesc:a1f2196496f170af2ee0a410ba064e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the number of planes, but keep the field halos and main lens <br /></td></tr>
<tr class="separator:a1f2196496f170af2ee0a410ba064e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4151410075a47b095f2f716055b1c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#ae4151410075a47b095f2f716055b1c69">resetFieldHalos</a> (bool verbose=false)</td></tr>
<tr class="separator:ae4151410075a47b095f2f716055b1c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c41fbb1d57645660161259c6352d85"><td class="memItemLeft" align="right" valign="top"><a id="a39c41fbb1d57645660161259c6352d85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a39c41fbb1d57645660161259c6352d85">printMultiLens</a> ()</td></tr>
<tr class="memdesc:a39c41fbb1d57645660161259c6352d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the main parameters of the lens <br /></td></tr>
<tr class="separator:a39c41fbb1d57645660161259c6352d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96bfac69304667e16af07feb20843f8"><td class="memItemLeft" align="right" valign="top"><a id="ac96bfac69304667e16af07feb20843f8"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#ac96bfac69304667e16af07feb20843f8">getZlens</a> () const</td></tr>
<tr class="memdesc:ac96bfac69304667e16af07feb20843f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redshift of first main lens plane. <br /></td></tr>
<tr class="separator:ac96bfac69304667e16af07feb20843f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b720d302cc40cc8dc820b98e766339e"><td class="memItemLeft" align="right" valign="top"><a id="a9b720d302cc40cc8dc820b98e766339e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a9b720d302cc40cc8dc820b98e766339e">getAngDistLens</a> () const</td></tr>
<tr class="memdesc:a9b720d302cc40cc8dc820b98e766339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular size distance (Mpc) to first main lens plane. <br /></td></tr>
<tr class="separator:a9b720d302cc40cc8dc820b98e766339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21ff2601808978cc0783a53c305c43"><td class="memItemLeft" align="right" valign="top"><a id="a4b21ff2601808978cc0783a53c305c43"></a>
<a class="el" href="class_utilities_1_1_geometry_1_1_spherical_point.html">Utilities::Geometry::SphericalPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCenter</b> () const</td></tr>
<tr class="separator:a4b21ff2601808978cc0783a53c305c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b0553693fdcff5a9cafc8f6c49e387"><td class="memItemLeft" align="right" valign="top"><a id="a01b0553693fdcff5a9cafc8f6c49e387"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a01b0553693fdcff5a9cafc8f6c49e387">clearMainHalos</a> (bool verbose=false)</td></tr>
<tr class="memdesc:a01b0553693fdcff5a9cafc8f6c49e387"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all main halos <br /></td></tr>
<tr class="separator:a01b0553693fdcff5a9cafc8f6c49e387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memTemplParams" colspan="2"><a id="ad3fc4fa967bf6f74cfc0bdf257bc0f30"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#ad3fc4fa967bf6f74cfc0bdf257bc0f30">clearMainHalo</a> (bool verbose=false)</td></tr>
<tr class="memdesc:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">remaove all main halo of given type <br /></td></tr>
<tr class="separator:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177ee7cbb406d835865edd855b556d63"><td class="memTemplParams" colspan="2"><a id="a177ee7cbb406d835865edd855b556d63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a177ee7cbb406d835865edd855b556d63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#a177ee7cbb406d835865edd855b556d63">insertMainHalo</a> (const T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:a177ee7cbb406d835865edd855b556d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a single main lens halo and adds it to the existing ones <br /></td></tr>
<tr class="separator:a177ee7cbb406d835865edd855b556d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#aa8a8bbd818794bc97ee6d3f842e82e54">moveinMainHalo</a> (T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This has the same effect as <a class="el" href="class_lens.html#a177ee7cbb406d835865edd855b556d63" title="inserts a single main lens halo and adds it to the existing ones">insertMainHalo()</a>, but the halo is not copied, it is moved.  <a href="#aa8a8bbd818794bc97ee6d3f842e82e54">More...</a><br /></td></tr>
<tr class="separator:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7e1b3c66565092fdc7555dc4704896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba7e1b3c66565092fdc7555dc4704896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#aba7e1b3c66565092fdc7555dc4704896">replaceMainHalo</a> (const T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:aba7e1b3c66565092fdc7555dc4704896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single main lens halo and deletes all previous ones. Then all lensing planes are updated accordingly.  <a href="#aba7e1b3c66565092fdc7555dc4704896">More...</a><br /></td></tr>
<tr class="separator:aba7e1b3c66565092fdc7555dc4704896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d549b1f217ff1a5c8246ffe845036b9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5d549b1f217ff1a5c8246ffe845036b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#a5d549b1f217ff1a5c8246ffe845036b9">insertMainHalos</a> (std::vector&lt; T &gt; &amp;my_halos, bool addplanes, bool verbose)</td></tr>
<tr class="memdesc:a5d549b1f217ff1a5c8246ffe845036b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a sequense of main lens halos and adds them to the existing ones. Then all lensing planes are updated accordingly. If addplanes is true new planes will be added otherwise the halo is added to the nearest plane and a plane is added only if none exited on entry.  <a href="#a5d549b1f217ff1a5c8246ffe845036b9">More...</a><br /></td></tr>
<tr class="separator:a5d549b1f217ff1a5c8246ffe845036b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#a0cfbb73f3ff13e43beccb50d18a89af4">replaceMainHalos</a> (std::vector&lt; T &gt; &amp;my_halos, bool verbose)</td></tr>
<tr class="memdesc:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a sequense of main lens halos and remove all previous ones.  <a href="#a0cfbb73f3ff13e43beccb50d18a89af4">More...</a><br /></td></tr>
<tr class="separator:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0324de1e5d25474e42cff1633be9eb1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a0324de1e5d25474e42cff1633be9eb1a">insertSubstructures</a> (PosType Rregion, PosType center[], PosType NumberDensity, PosType Mass_min, PosType Mass_max, PosType redshift, PosType alpha, PosType density_contrast, bool verbose)</td></tr>
<tr class="memdesc:a0324de1e5d25474e42cff1633be9eb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a sequence of main lens halos and adds them to the existing ones  <a href="#a0324de1e5d25474e42cff1633be9eb1a">More...</a><br /></td></tr>
<tr class="separator:a0324de1e5d25474e42cff1633be9eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff453e42293b1dddda27c7bdebc36db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#afff453e42293b1dddda27c7bdebc36db">resetSubstructure</a> (bool verbose=false)</td></tr>
<tr class="memdesc:afff453e42293b1dddda27c7bdebc36db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will randomize the substructure without changing the region, mass function, etc.  <a href="#afff453e42293b1dddda27c7bdebc36db">More...</a><br /></td></tr>
<tr class="separator:afff453e42293b1dddda27c7bdebc36db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5edcf261950dab5a8d3339626b01eed"><td class="memItemLeft" align="right" valign="top"><a id="ad5edcf261950dab5a8d3339626b01eed"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#ad5edcf261950dab5a8d3339626b01eed">getNMainHalos</a> () const</td></tr>
<tr class="memdesc:ad5edcf261950dab5a8d3339626b01eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of main halos <br /></td></tr>
<tr class="separator:ad5edcf261950dab5a8d3339626b01eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfbf61d32fcad6120af5a472132391"><td class="memTemplParams" colspan="2"><a id="a44cfbf61d32fcad6120af5a472132391"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:a44cfbf61d32fcad6120af5a472132391"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#a44cfbf61d32fcad6120af5a472132391">getNMainHalos</a> () const</td></tr>
<tr class="memdesc:a44cfbf61d32fcad6120af5a472132391"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of main halos of given type <br /></td></tr>
<tr class="separator:a44cfbf61d32fcad6120af5a472132391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc7754f42783ebe2f3d7a8074591322"><td class="memItemLeft" align="right" valign="top"><a id="aecc7754f42783ebe2f3d7a8074591322"></a>
<a class="el" href="class_lens_halo.html">LensHalo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#aecc7754f42783ebe2f3d7a8074591322">getMainHalo</a> (std::size_t i)</td></tr>
<tr class="memdesc:aecc7754f42783ebe2f3d7a8074591322"><td class="mdescLeft">&#160;</td><td class="mdescRight">get single main halo <br /></td></tr>
<tr class="separator:aecc7754f42783ebe2f3d7a8074591322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff81a6b811293718d2f58665b81571"><td class="memTemplParams" colspan="2"><a id="afbff81a6b811293718d2f58665b81571"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:afbff81a6b811293718d2f58665b81571"><td class="memTemplItemLeft" align="right" valign="top">HaloType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_lens.html#afbff81a6b811293718d2f58665b81571">getMainHalo</a> (std::size_t i)</td></tr>
<tr class="memdesc:afbff81a6b811293718d2f58665b81571"><td class="mdescLeft">&#160;</td><td class="mdescRight">get single main halo of given type <br /></td></tr>
<tr class="separator:afbff81a6b811293718d2f58665b81571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711067d75213f4e6bc0f8a5606faf66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a711067d75213f4e6bc0f8a5606faf66a">rayshooterInternal</a> (unsigned long Npoints, <a class="el" href="struct_point.html">Point</a> *i_points, bool RSIverbose=false)</td></tr>
<tr class="memdesc:a711067d75213f4e6bc0f8a5606faf66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the deflection, shear, convergence, rotation and time-delay of rays in parallel.  <a href="#a711067d75213f4e6bc0f8a5606faf66a">More...</a><br /></td></tr>
<tr class="separator:a711067d75213f4e6bc0f8a5606faf66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789442c6d34aad5a578b2042c65f0903"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a789442c6d34aad5a578b2042c65f0903">info_rayshooter</a> (<a class="el" href="struct_point.html">Point</a> *i_point, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;ang_positions, std::vector&lt; KappaType &gt; &amp;kappa_on_planes, std::vector&lt; std::vector&lt; <a class="el" href="class_lens_halo.html">LensHalo</a> * &gt;&gt; &amp;halo_neighbors, <a class="el" href="class_lens_halo.html">LensHalo</a> **halo_max, KappaType &amp;kappa_max, KappaType gamma_max[], PosType rmax, short mode=0, bool verbose=false)</td></tr>
<tr class="memdesc:a789442c6d34aad5a578b2042c65f0903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collects information about the halos and kappa contributions along the light path.  <a href="#a789442c6d34aad5a578b2042c65f0903">More...</a><br /></td></tr>
<tr class="separator:a789442c6d34aad5a578b2042c65f0903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a7645662d9c26b1c2c4373826348c1"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a41a7645662d9c26b1c2c4373826348c1">ResetSourcePlane</a> (PosType z, bool nearest=false, unsigned long GalID=0, PosType *xx=NULL, bool verbose=false)</td></tr>
<tr class="memdesc:a41a7645662d9c26b1c2c4373826348c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the redshift of the source plane  <a href="#a41a7645662d9c26b1c2c4373826348c1">More...</a><br /></td></tr>
<tr class="separator:a41a7645662d9c26b1c2c4373826348c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c16d98618b2a26e75c2673af2058c2"><td class="memItemLeft" align="right" valign="top"><a id="af4c16d98618b2a26e75c2673af2058c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#af4c16d98618b2a26e75c2673af2058c2">RevertSourcePlane</a> ()</td></tr>
<tr class="memdesc:af4c16d98618b2a26e75c2673af2058c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert the source redshift to the value it was when the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> was created. <br /></td></tr>
<tr class="separator:af4c16d98618b2a26e75c2673af2058c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f423ad5bbf4d7256673256a601037"><td class="memItemLeft" align="right" valign="top"><a id="af77f423ad5bbf4d7256673256a601037"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getSourceZ</b> ()</td></tr>
<tr class="separator:af77f423ad5bbf4d7256673256a601037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fd74bb5f5ffc4ee1610db34bb96def"><td class="memItemLeft" align="right" valign="top"><a id="a45fd74bb5f5ffc4ee1610db34bb96def"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getZmax</b> () const</td></tr>
<tr class="separator:a45fd74bb5f5ffc4ee1610db34bb96def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="memItemLeft" align="right" valign="top"><a id="a6e65d6c8d5c97e4024d7002eb8cc7d04"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a6e65d6c8d5c97e4024d7002eb8cc7d04">PrintCosmology</a> ()</td></tr>
<tr class="memdesc:a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the cosmological parameters <br /></td></tr>
<tr class="separator:a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53108c7002e0cb4ce7064d43c5efdb0e"><td class="memItemLeft" align="right" valign="top"><a id="a53108c7002e0cb4ce7064d43c5efdb0e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a53108c7002e0cb4ce7064d43c5efdb0e">getSigmaCrit</a> (PosType zsource) const</td></tr>
<tr class="memdesc:a53108c7002e0cb4ce7064d43c5efdb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the critical density at the main lens in Msun/ Mpc^2 for a source at zsource <br /></td></tr>
<tr class="separator:a53108c7002e0cb4ce7064d43c5efdb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5576b59d2f70c1d0f0a798b8a92a4f81"><td class="memItemLeft" align="right" valign="top"><a id="a5576b59d2f70c1d0f0a798b8a92a4f81"></a>
const <a class="el" href="class_c_o_s_m_o_l_o_g_y.html">COSMOLOGY</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a5576b59d2f70c1d0f0a798b8a92a4f81">getCosmo</a> ()</td></tr>
<tr class="memdesc:a5576b59d2f70c1d0f0a798b8a92a4f81"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const reference to the cosmology so that constant functions can be used, but the cosmological parameters cannot be changed. <br /></td></tr>
<tr class="separator:a5576b59d2f70c1d0f0a798b8a92a4f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="memItemLeft" align="right" valign="top"><a id="a40ef8e31f5a9d3ada238db9c8a8babe9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a40ef8e31f5a9d3ada238db9c8a8babe9">TurnFieldOff</a> ()</td></tr>
<tr class="memdesc:a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set flag_switch_field_off, turn the field On/Off : <br /></td></tr>
<tr class="separator:a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b527844992bbd710bb5bee3c7e55f3"><td class="memItemLeft" align="right" valign="top"><a id="a15b527844992bbd710bb5bee3c7e55f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TurnFieldOn</b> ()</td></tr>
<tr class="separator:a15b527844992bbd710bb5bee3c7e55f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769e1aec46d81eab053a7de55f464cc"><td class="memItemLeft" align="right" valign="top"><a id="a3769e1aec46d81eab053a7de55f464cc"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a3769e1aec46d81eab053a7de55f464cc">getFieldMinMass</a> () const</td></tr>
<tr class="memdesc:a3769e1aec46d81eab053a7de55f464cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the field min mass : <br /></td></tr>
<tr class="separator:a3769e1aec46d81eab053a7de55f464cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6ea256727745b13b6df8258cfa7ec0"><td class="memItemLeft" align="right" valign="top"><a id="a6a6ea256727745b13b6df8258cfa7ec0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getfieldOff</b> () const</td></tr>
<tr class="separator:a6a6ea256727745b13b6df8258cfa7ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6503364df69f159ab0f6b80acc26761c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a6503364df69f159ab0f6b80acc26761c">GenerateFieldHalos</a> (double min_mass, MassFuncType mass_function, double field_of_view, int Nplanes, LensHaloType halo_type=nfw_lens, GalaxyLensHaloType galaxy_type=null_gal, double buffer=1.0, bool verbose=false)</td></tr>
<tr class="memdesc:a6503364df69f159ab0f6b80acc26761c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add random halos to the light cone according to standard structure formation theory. A new realization of the light-cone can be made with <a class="el" href="class_lens.html#ae4151410075a47b095f2f716055b1c69">Lens::resetFieldHalos()</a> after this function is called once.  <a href="#a6503364df69f159ab0f6b80acc26761c">More...</a><br /></td></tr>
<tr class="separator:a6503364df69f159ab0f6b80acc26761c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e312accd9681ad7e131b5530ca2affd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lens.html">Lens</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a2e312accd9681ad7e131b5530ca2affd">operator=</a> (<a class="el" href="class_lens.html">Lens</a> &amp;&amp;lens)</td></tr>
<tr class="separator:a2e312accd9681ad7e131b5530ca2affd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f940236f66e88f8a3b73efbb7c2bc"><td class="memItemLeft" align="right" valign="top"><a id="a557f940236f66e88f8a3b73efbb7c2bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b> (<a class="el" href="class_lens.html">Lens</a> &amp;&amp;lens)</td></tr>
<tr class="separator:a557f940236f66e88f8a3b73efbb7c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a09c7b4946959331f7dc5aed93053727c"><td class="memItemLeft" align="right" valign="top"><a id="a09c7b4946959331f7dc5aed93053727c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#a09c7b4946959331f7dc5aed93053727c">set</a></td></tr>
<tr class="memdesc:a09c7b4946959331f7dc5aed93053727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">marks if the lens has been setup. <br /></td></tr>
<tr class="separator:a09c7b4946959331f7dc5aed93053727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aee17d6e92bea425de358a9381ad6280b"><td class="memItemLeft" align="right" valign="top"><a id="aee17d6e92bea425de358a9381ad6280b"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lens.html#aee17d6e92bea425de358a9381ad6280b">fieldofview</a></td></tr>
<tr class="memdesc:aee17d6e92bea425de358a9381ad6280b"><td class="mdescLeft">&#160;</td><td class="mdescRight">field of view in square degrees <br /></td></tr>
<tr class="separator:aee17d6e92bea425de358a9381ad6280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to represents a lens with multiple planes. </p>
<pre>
 The rays are traced through multiple deflections.  On each plane there is a deflection
 solver.  An <a class="el" href="class_lens_halo_ana_n_s_i_e.html" title="A NSIE lens with distortions in shape, substructures and stars included.">LensHaloAnaNSIE</a> or <a class="el" href="class_lens_halo_mass_map.html" title="A class that includes the MOKA lens map.">LensHaloMassMap</a> can be put on one of the planes.  The other planes can be
 populated with random field_halos drawn from a mass function or they can be retrieved from an
 external catalog.</pre><pre>   Input Parameters (variable names):</pre><pre>   main_halo_on -- 0: no major lens present; 1: there is a major lens present
   main_halo_type -- profile type for the main DM lens halo
    0 or nolens, 1 or NFW, 2 or PseudoNFW, 3 or PowerLaw, 4 or NSIE, 5 or AnaLens, 6 or UniLens, 7 or MOKALens, 8 or DummyLens
   main_galaxy_halo_type -- profile typ for the main galaxy lens halo 0 or none, 1 or NSIE
   redshift_planes_file -- asci file with the redshifts of the lensing planes, if not set then created internaly
   flag_switch_field_off -- false: field halos are created, true: no field halos are created; default is false</pre><pre>   if field_off == false, i.e. there are field halos then also the following are used:
   field_Nplanes -- number of field planes
   field_fov -- field of view of the light cone, filled with field halos
   field_internal_profile -- profile type of the DM field lens halos
    0 or nolens, 1 or NFW, 2 or PseudoNFW, 3 or PowerLaw, 4 or NSIE, 5 or AnaLens, 6 or UniLens, 7 or MOKALens, 8 or DummyLens, 9 or Hernquist, 10 or Jaffe
   field_prof_internal_slope_pl -- slope of the surface density for power law
   field_prof_internal_slope_pnfw -- slope of the surface density for pseudo nfw profiles
   field_internal_profile_galaxy -- profile type of the galaxy field halos; if not set, no galaxies are used
    0 or none, 1 or NSIE</pre><pre>   field_input_sim_file -- filename of the Millennium simulation data to be read in and used to populate the light cone with field halos</pre><pre>   if field_input_sim_file is  _not_ set, then the field halos are generated from a mass function and the following are used:
   field_mass_func_type -- type of the halo mass function
    PS (0), ST (1), and power law (2)
   mass_func_PL_slope -- slope of the mass function in the power law case; default is -1/6
   field_min_mass -- minimum mass for the generated field halos
   field_buffer -- a constant physical size buffer, padding every lens plane to increase its surface</pre><pre>   zsource -- source redshift
   flag_switch_deflection_off -- false: deflection is on, but kappa and gamma may be calculated, true: deflection is off; default is false
   flag_switch_lensing_off -- false: lensing is on, true: lensing is off (no alpha, kappa or gamma); default is false</pre><pre>   # Cosmology - Any cosmological parameters that are not set will have default values</pre><pre>  Omega_matter -- Total mass (baryons + dark matter) in the units of the critical density, optional
  Omega_lambda -- Density in a cosmological constant, if not set it will be = 1 - Omega_matter
  Omega_baryon -- Density in baryons
  Omega_neutrino -- Density in neutrinos
  hubble -- Hubble parameter in units of 100 km/s/Mpc
  sigm_8 -- normalization of power spectrum</pre><pre> </pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6503364df69f159ab0f6b80acc26761c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6503364df69f159ab0f6b80acc26761c">&#9670;&nbsp;</a></span>GenerateFieldHalos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::GenerateFieldHalos </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MassFuncType&#160;</td>
          <td class="paramname"><em>mass_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>field_of_view</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nplanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensHaloType&#160;</td>
          <td class="paramname"><em>halo_type</em> = <code>nfw_lens</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GalaxyLensHaloType&#160;</td>
          <td class="paramname"><em>galaxy_type</em> = <code>null_gal</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add random halos to the light cone according to standard structure formation theory. A new realization of the light-cone can be made with <a class="el" href="class_lens.html#ae4151410075a47b095f2f716055b1c69">Lens::resetFieldHalos()</a> after this function is called once. </p>
<p>The cone is filled up until the redshift of the current zsource that is stored in the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> class. The field is a circular on the sky. There is no clustering of the halos. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">min_mass</td><td>minimum mass of halos </td></tr>
    <tr><td class="paramname">mass_function</td><td>type of mass function </td></tr>
    <tr><td class="paramname">field_of_view</td><td>in square degrees </td></tr>
    <tr><td class="paramname">Nplanes</td><td>number of lens planes </td></tr>
    <tr><td class="paramname">halo_type</td><td>type of halo </td></tr>
    <tr><td class="paramname">galaxy_type</td><td>type of galaxy, if null_gal no galaxy </td></tr>
    <tr><td class="paramname">buffer</td><td>buffer in Mpc for cone </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a789442c6d34aad5a578b2042c65f0903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789442c6d34aad5a578b2042c65f0903">&#9670;&nbsp;</a></span>info_rayshooter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::info_rayshooter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>i_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ang_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; KappaType &gt; &amp;&#160;</td>
          <td class="paramname"><em>kappa_on_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="class_lens_halo.html">LensHalo</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>halo_neighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lens_halo.html">LensHalo</a> **&#160;</td>
          <td class="paramname"><em>halo_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KappaType &amp;&#160;</td>
          <td class="paramname"><em>kappa_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KappaType&#160;</td>
          <td class="paramname"><em>gamma_max</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>mode</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collects information about the halos and kappa contributions along the light path. </p>
<p>Information on the nearest halos is collected where nearest is defined by rmax and mode. When mode == 2 the unlensed angular coordinates are used to evaluate proximity not the lensed ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_point</td><td>point to be shot, must have image point linked </td></tr>
    <tr><td class="paramname">ang_positions</td><td>angular positions on each plane </td></tr>
    <tr><td class="paramname">kappa_on_planes</td><td>convergence on each plane </td></tr>
    <tr><td class="paramname">halo_neighbors</td><td>neighboring halos within rmax of ray on each plane </td></tr>
    <tr><td class="paramname">rmax</td><td>distance from ray on each plane, units depend on mode parameter </td></tr>
    <tr><td class="paramname">mode</td><td>0:physical distance, 1: comoving distance, 2: angular distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d549b1f217ff1a5c8246ffe845036b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d549b1f217ff1a5c8246ffe845036b9">&#9670;&nbsp;</a></span>insertMainHalos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::insertMainHalos </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>my_halos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addplanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a sequense of main lens halos and adds them to the existing ones. Then all lensing planes are updated accordingly. If addplanes is true new planes will be added otherwise the halo is added to the nearest plane and a plane is added only if none exited on entry. </p>
<p>The angular position of the halo should be preserved, but the x coordinates may change The halos are copied so the input halos can be destoyed without affecting the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a>. </p>

</div>
</div>
<a id="a0324de1e5d25474e42cff1633be9eb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0324de1e5d25474e42cff1633be9eb1a">&#9670;&nbsp;</a></span>insertSubstructures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::insertSubstructures </td>
          <td>(</td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>Rregion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>NumberDensity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>Mass_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>Mass_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>redshift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>density_contrast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>inserts a sequence of main lens halos and adds them to the existing ones </p>
<p>replaces existing main halos with a single main halo replaces existing main halos with a sequence of main halos Add substructures to the lens.</p>
<p>This method is meant for inserting substructure to a main lens. All the substructure will be at one redshift. The mass function follows a power law. The density of substructures is constant within a circular region. The tidal truncation is controlled through the parameter density_contrast which is the average density within the substructures orbit in units of the average density to the universe at the redshift where they are places. For example density_contrast=200 would give them the truncation radius appropriate at R_200.</p>
<ul>
<li>INSERT SUB STRUCTURE * /// </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Rregion</td><td>radius of region in which substructures are inserted (radians) </td></tr>
    <tr><td class="paramname">center</td><td>center of region in which the substructures are inserted (radians) </td></tr>
    <tr><td class="paramname">NumberDensity</td><td>number density per radian^2 of all substructures </td></tr>
    <tr><td class="paramname">Mass_min</td><td>minimum mass of substructures </td></tr>
    <tr><td class="paramname">Mass_max</td><td>maximum mass of substructures </td></tr>
    <tr><td class="paramname">redshift</td><td>redshift of substructures </td></tr>
    <tr><td class="paramname">alpha</td><td>index of mass function (dN/dm \propto m^alpha) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a8bbd818794bc97ee6d3f842e82e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a8bbd818794bc97ee6d3f842e82e54">&#9670;&nbsp;</a></span>moveinMainHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::moveinMainHalo </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>halo_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addplanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This has the same effect as <a class="el" href="class_lens.html#a177ee7cbb406d835865edd855b556d63" title="inserts a single main lens halo and adds it to the existing ones">insertMainHalo()</a>, but the halo is not copied, it is moved. </p>
<p>The <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> will take possession of the halo and will destroy it when it is destroyed. This is to avoid copying halos that take up a lot of memory and require a lot of time to copy like <a class="el" href="class_lens_halo_particles.html" title="A class that represents the lensing by a collection of simulation particles.">LensHaloParticles()</a>. </p>

</div>
</div>
<a id="a2e312accd9681ad7e131b5530ca2affd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e312accd9681ad7e131b5530ca2affd">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lens.html">Lens</a>&amp; Lens::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">Lens</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>lens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MixedVector cannot be copyed </p>

</div>
</div>
<a id="a711067d75213f4e6bc0f8a5606faf66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711067d75213f4e6bc0f8a5606faf66a">&#9670;&nbsp;</a></span>rayshooterInternal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::rayshooterInternal </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>i_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>RSIVerbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the deflection, shear, convergence, rotation and time-delay of rays in parallel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Npoints</td><td>number of points to be shot </td></tr>
    <tr><td class="paramname">i_points</td><td>point on the image plane </td></tr>
    <tr><td class="paramname">RSIVerbose</td><td>verbose option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba7e1b3c66565092fdc7555dc4704896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7e1b3c66565092fdc7555dc4704896">&#9670;&nbsp;</a></span>replaceMainHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::replaceMainHalo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>halo_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>addplanes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single main lens halo and deletes all previous ones. Then all lensing planes are updated accordingly. </p>
<p>Note that this does delete all the halos that were there. </p>

</div>
</div>
<a id="a0cfbb73f3ff13e43beccb50d18a89af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfbb73f3ff13e43beccb50d18a89af4">&#9670;&nbsp;</a></span>replaceMainHalos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::replaceMainHalos </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>my_halos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a sequense of main lens halos and remove all previous ones. </p>
<p>Note that this does delete the halos that were there. Then all lensing planes are updated accordingly. </p>

</div>
</div>
<a id="ae4151410075a47b095f2f716055b1c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4151410075a47b095f2f716055b1c69">&#9670;&nbsp;</a></span>resetFieldHalos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::resetFieldHalos </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>keep the main lens and the number of planes constant, but generate new field halos. This function will also erase the substructure halos so they need to be regenerated using <a class="el" href="class_lens.html#afff453e42293b1dddda27c7bdebc36db" title="This function will randomize the substructure without changing the region, mass function,...">resetSubstructure()</a> if they are desired . </p>

</div>
</div>
<a id="a41a7645662d9c26b1c2c4373826348c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a7645662d9c26b1c2c4373826348c1">&#9670;&nbsp;</a></span>ResetSourcePlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short Lens::ResetSourcePlane </td>
          <td>(</td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nearest</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>GalID</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>xx</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset the redshift of the source plane </p>
<p>Changes the maximum redshift that the rays are shot to. Warning: Grids that have already been made with this <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> will not have this new source redshift.</p>
<p>The multilens must have been initially constructed with a source redshift that is higher than this redshift. This is used to rayshoot to a source whose line of sight passes through the simulation volume. The source can be at higher redshift than the simulation volume.</p>
<p>To revert the source redshift to its original value use <a class="el" href="class_lens.html#af4c16d98618b2a26e75c2673af2058c2" title="Revert the source redshift to the value it was when the Lens was created.">Lens::RevertSourcePlane()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>redshift of implanted source </td></tr>
    <tr><td class="paramname">nearest</td><td>If true, set the source plane to the nearest (in coordinate distance) lensing plane that was created already. This can be used to avoid self-lensing by the halo of the source. If the source is at higher redshift than the simulation volume the source will be at its real redshift. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afff453e42293b1dddda27c7bdebc36db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff453e42293b1dddda27c7bdebc36db">&#9670;&nbsp;</a></span>resetSubstructure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::resetSubstructure </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will randomize the substructure without changing the region, mass function, etc. </p>
<p>The <a class="el" href="class_lens.html#a0324de1e5d25474e42cff1633be9eb1a" title="inserts a sequence of main lens halos and adds them to the existing ones">Lens::insertSubstructures()</a> function must have been called on this instance of the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> before.</p>
<ul>
<li>RESET SUB STRUCTURE * /// </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="lens_8h_source.html">lens.h</a></li>
<li>SLsimLib/FullRange/internal_rayshooter_multi.cpp</li>
<li>SLsimLib/MultiPlane/lens.cpp</li>
<li>SLsimLib/MultiPlane/lens_multi_dark.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 28 2019 11:59:02 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
