<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Lens Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_lens-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Lens Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class to represents a lens with multiple planes.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lens_8h_source.html">lens.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc69ae46a84f55e9f89633d0e4182230" id="r_acc69ae46a84f55e9f89633d0e4182230"><td class="memItemLeft" align="right" valign="top"><a id="acc69ae46a84f55e9f89633d0e4182230" name="acc69ae46a84f55e9f89633d0e4182230"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b> (long *seed, PosType z_source, CosmoParamSet cosmoset, bool verbose=false)</td></tr>
<tr class="memdesc:acc69ae46a84f55e9f89633d0e4182230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an empty lens. Main halos and field halos need to be inserted by hand from the user. <br /></td></tr>
<tr class="separator:acc69ae46a84f55e9f89633d0e4182230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d35c838440ad6d526e402492be04fc3" id="r_a7d35c838440ad6d526e402492be04fc3"><td class="memItemLeft" align="right" valign="top"><a id="a7d35c838440ad6d526e402492be04fc3" name="a7d35c838440ad6d526e402492be04fc3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b> (long *seed, PosType z_source, const <a class="el" href="class_c_o_s_m_o_l_o_g_y.html">COSMOLOGY</a> &amp;cosmo, bool verbose=false)</td></tr>
<tr class="separator:a7d35c838440ad6d526e402492be04fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce0eee4b6bf7070d5524d27b3474168" id="r_a0ce0eee4b6bf7070d5524d27b3474168"><td class="memItemLeft" align="right" valign="top"><a id="a0ce0eee4b6bf7070d5524d27b3474168" name="a0ce0eee4b6bf7070d5524d27b3474168"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNplanes</b> () const</td></tr>
<tr class="memdesc:a0ce0eee4b6bf7070d5524d27b3474168"><td class="mdescLeft">&#160;</td><td class="mdescRight">the total number of lens planes <br /></td></tr>
<tr class="separator:a0ce0eee4b6bf7070d5524d27b3474168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4269648ebbcbfcb1df353a92a5da2710" id="r_a4269648ebbcbfcb1df353a92a5da2710"><td class="memItemLeft" align="right" valign="top"><a id="a4269648ebbcbfcb1df353a92a5da2710" name="a4269648ebbcbfcb1df353a92a5da2710"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getfov</b> () const</td></tr>
<tr class="memdesc:a4269648ebbcbfcb1df353a92a5da2710"><td class="mdescLeft">&#160;</td><td class="mdescRight">field of view in square degrees <br /></td></tr>
<tr class="separator:a4269648ebbcbfcb1df353a92a5da2710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32d8eedc7ff362eed924f1dacea54ad" id="r_ac32d8eedc7ff362eed924f1dacea54ad"><td class="memItemLeft" align="right" valign="top"><a id="ac32d8eedc7ff362eed924f1dacea54ad" name="ac32d8eedc7ff362eed924f1dacea54ad"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setfov</b> (PosType fov)</td></tr>
<tr class="separator:ac32d8eedc7ff362eed924f1dacea54ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2196496f170af2ee0a410ba064e2fa" id="r_a1f2196496f170af2ee0a410ba064e2fa"><td class="memItemLeft" align="right" valign="top"><a id="a1f2196496f170af2ee0a410ba064e2fa" name="a1f2196496f170af2ee0a410ba064e2fa"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resetFieldNplanes</b> (std::size_t field_Nplanes, bool verbose=false)</td></tr>
<tr class="memdesc:a1f2196496f170af2ee0a410ba064e2fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the number of planes, but keep the field halos and main lens <br /></td></tr>
<tr class="separator:a1f2196496f170af2ee0a410ba064e2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4151410075a47b095f2f716055b1c69" id="r_ae4151410075a47b095f2f716055b1c69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4151410075a47b095f2f716055b1c69">resetFieldHalos</a> (bool verbose=false)</td></tr>
<tr class="separator:ae4151410075a47b095f2f716055b1c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c41fbb1d57645660161259c6352d85" id="r_a39c41fbb1d57645660161259c6352d85"><td class="memItemLeft" align="right" valign="top"><a id="a39c41fbb1d57645660161259c6352d85" name="a39c41fbb1d57645660161259c6352d85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printMultiLens</b> ()</td></tr>
<tr class="memdesc:a39c41fbb1d57645660161259c6352d85"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the main parameters of the lens <br /></td></tr>
<tr class="separator:a39c41fbb1d57645660161259c6352d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96bfac69304667e16af07feb20843f8" id="r_ac96bfac69304667e16af07feb20843f8"><td class="memItemLeft" align="right" valign="top"><a id="ac96bfac69304667e16af07feb20843f8" name="ac96bfac69304667e16af07feb20843f8"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getZlens</b> () const</td></tr>
<tr class="memdesc:ac96bfac69304667e16af07feb20843f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Redshift of first main lens plane. <br /></td></tr>
<tr class="separator:ac96bfac69304667e16af07feb20843f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b720d302cc40cc8dc820b98e766339e" id="r_a9b720d302cc40cc8dc820b98e766339e"><td class="memItemLeft" align="right" valign="top"><a id="a9b720d302cc40cc8dc820b98e766339e" name="a9b720d302cc40cc8dc820b98e766339e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getAngDistLens</b> () const</td></tr>
<tr class="memdesc:a9b720d302cc40cc8dc820b98e766339e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Angular size distance (Mpc) to first main lens plane. <br /></td></tr>
<tr class="separator:a9b720d302cc40cc8dc820b98e766339e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b21ff2601808978cc0783a53c305c43" id="r_a4b21ff2601808978cc0783a53c305c43"><td class="memItemLeft" align="right" valign="top"><a id="a4b21ff2601808978cc0783a53c305c43" name="a4b21ff2601808978cc0783a53c305c43"></a>
<a class="el" href="class_utilities_1_1_geometry_1_1_spherical_point.html">Utilities::Geometry::SphericalPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCenter</b> () const</td></tr>
<tr class="separator:a4b21ff2601808978cc0783a53c305c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b0553693fdcff5a9cafc8f6c49e387" id="r_a01b0553693fdcff5a9cafc8f6c49e387"><td class="memItemLeft" align="right" valign="top"><a id="a01b0553693fdcff5a9cafc8f6c49e387" name="a01b0553693fdcff5a9cafc8f6c49e387"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearMainHalos</b> (bool verbose=false)</td></tr>
<tr class="memdesc:a01b0553693fdcff5a9cafc8f6c49e387"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove all main halos <br /></td></tr>
<tr class="separator:a01b0553693fdcff5a9cafc8f6c49e387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fc4fa967bf6f74cfc0bdf257bc0f30" id="r_ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memTemplParams" colspan="2"><a id="ad3fc4fa967bf6f74cfc0bdf257bc0f30" name="ad3fc4fa967bf6f74cfc0bdf257bc0f30"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>clearMainHalo</b> (bool verbose=false)</td></tr>
<tr class="memdesc:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="mdescLeft">&#160;</td><td class="mdescRight">remaove all main halo of given type <br /></td></tr>
<tr class="separator:ad3fc4fa967bf6f74cfc0bdf257bc0f30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177ee7cbb406d835865edd855b556d63" id="r_a177ee7cbb406d835865edd855b556d63"><td class="memTemplParams" colspan="2"><a id="a177ee7cbb406d835865edd855b556d63" name="a177ee7cbb406d835865edd855b556d63"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a177ee7cbb406d835865edd855b556d63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>insertMainHalo</b> (const T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:a177ee7cbb406d835865edd855b556d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a single main lens halo and adds it to the existing ones <br /></td></tr>
<tr class="separator:a177ee7cbb406d835865edd855b556d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a8bbd818794bc97ee6d3f842e82e54" id="r_aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa8a8bbd818794bc97ee6d3f842e82e54">moveinMainHalo</a> (T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">This has the same effect as <a class="el" href="#a177ee7cbb406d835865edd855b556d63" title="inserts a single main lens halo and adds it to the existing ones">insertMainHalo()</a>, but the halo is not copied, it is moved.  <br /></td></tr>
<tr class="separator:aa8a8bbd818794bc97ee6d3f842e82e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7e1b3c66565092fdc7555dc4704896" id="r_aba7e1b3c66565092fdc7555dc4704896"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aba7e1b3c66565092fdc7555dc4704896"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba7e1b3c66565092fdc7555dc4704896">replaceMainHalo</a> (const T &amp;halo_in, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:aba7e1b3c66565092fdc7555dc4704896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a single main lens halo and deletes all previous ones. Then all lensing planes are updated accordingly.  <br /></td></tr>
<tr class="separator:aba7e1b3c66565092fdc7555dc4704896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7403e6372cd1a396fb098cbd1d824cc" id="r_af7403e6372cd1a396fb098cbd1d824cc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af7403e6372cd1a396fb098cbd1d824cc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af7403e6372cd1a396fb098cbd1d824cc">insertMainHalos</a> (std::vector&lt; T &gt; &amp;my_halos, bool addplanes, bool verbose=false)</td></tr>
<tr class="memdesc:af7403e6372cd1a396fb098cbd1d824cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a sequense of main lens halos and adds them to the existing ones. Then all lensing planes are updated accordingly. If addplanes is true new planes will be added otherwise the halo is added to the nearest plane and a plane is added only if none exited on entry.  <br /></td></tr>
<tr class="separator:af7403e6372cd1a396fb098cbd1d824cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfbb73f3ff13e43beccb50d18a89af4" id="r_a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0cfbb73f3ff13e43beccb50d18a89af4">replaceMainHalos</a> (std::vector&lt; T &gt; &amp;my_halos, bool verbose)</td></tr>
<tr class="memdesc:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts a sequense of main lens halos and remove all previous ones.  <br /></td></tr>
<tr class="separator:a0cfbb73f3ff13e43beccb50d18a89af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5edcf261950dab5a8d3339626b01eed" id="r_ad5edcf261950dab5a8d3339626b01eed"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5edcf261950dab5a8d3339626b01eed">getNMainHalos</a> () const</td></tr>
<tr class="memdesc:ad5edcf261950dab5a8d3339626b01eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">inserts a sequence of main lens halos and adds them to the existing ones  <br /></td></tr>
<tr class="separator:ad5edcf261950dab5a8d3339626b01eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cfbf61d32fcad6120af5a472132391" id="r_a44cfbf61d32fcad6120af5a472132391"><td class="memTemplParams" colspan="2"><a id="a44cfbf61d32fcad6120af5a472132391" name="a44cfbf61d32fcad6120af5a472132391"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:a44cfbf61d32fcad6120af5a472132391"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getNMainHalos</b> () const</td></tr>
<tr class="memdesc:a44cfbf61d32fcad6120af5a472132391"><td class="mdescLeft">&#160;</td><td class="mdescRight">get number of main halos of given type <br /></td></tr>
<tr class="separator:a44cfbf61d32fcad6120af5a472132391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc7754f42783ebe2f3d7a8074591322" id="r_aecc7754f42783ebe2f3d7a8074591322"><td class="memItemLeft" align="right" valign="top"><a id="aecc7754f42783ebe2f3d7a8074591322" name="aecc7754f42783ebe2f3d7a8074591322"></a>
<a class="el" href="class_lens_halo.html">LensHalo</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>getMainHalo</b> (std::size_t i)</td></tr>
<tr class="memdesc:aecc7754f42783ebe2f3d7a8074591322"><td class="mdescLeft">&#160;</td><td class="mdescRight">get single main halo <br /></td></tr>
<tr class="separator:aecc7754f42783ebe2f3d7a8074591322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbff81a6b811293718d2f58665b81571" id="r_afbff81a6b811293718d2f58665b81571"><td class="memTemplParams" colspan="2"><a id="afbff81a6b811293718d2f58665b81571" name="afbff81a6b811293718d2f58665b81571"></a>
template&lt;typename HaloType &gt; </td></tr>
<tr class="memitem:afbff81a6b811293718d2f58665b81571"><td class="memTemplItemLeft" align="right" valign="top">HaloType *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>getMainHalo</b> (std::size_t i)</td></tr>
<tr class="memdesc:afbff81a6b811293718d2f58665b81571"><td class="mdescLeft">&#160;</td><td class="mdescRight">get single main halo of given type <br /></td></tr>
<tr class="separator:afbff81a6b811293718d2f58665b81571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a8ed89e743c26f14ab8e3992fa3118a" id="r_a7a8ed89e743c26f14ab8e3992fa3118a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a8ed89e743c26f14ab8e3992fa3118a">rayshooter</a> (<a class="el" href="struct_r_a_y.html">RAY</a> &amp;ray)</td></tr>
<tr class="memdesc:a7a8ed89e743c26f14ab8e3992fa3118a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using to shoot a single ray.  <br /></td></tr>
<tr class="separator:a7a8ed89e743c26f14ab8e3992fa3118a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711067d75213f4e6bc0f8a5606faf66a" id="r_a711067d75213f4e6bc0f8a5606faf66a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a711067d75213f4e6bc0f8a5606faf66a">rayshooterInternal</a> (unsigned long Npoints, <a class="el" href="struct_point.html">Point</a> *i_points, bool RSIverbose=false)</td></tr>
<tr class="memdesc:a711067d75213f4e6bc0f8a5606faf66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main routine for shooting rays in parrallel.  <br /></td></tr>
<tr class="separator:a711067d75213f4e6bc0f8a5606faf66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575c6d766091cde0ce87249e97333f1" id="r_a2575c6d766091cde0ce87249e97333f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2575c6d766091cde0ce87249e97333f1">rayshooterInternal</a> (unsigned long Npoints, <a class="el" href="struct_linked_point.html">LinkedPoint</a> *i_points, std::vector&lt; double &gt; &amp;source_zs, bool RSIverbose=false)</td></tr>
<tr class="memdesc:a2575c6d766091cde0ce87249e97333f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine for shooting rays with differnt source redshifts in parrallel.  <br /></td></tr>
<tr class="separator:a2575c6d766091cde0ce87249e97333f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae505c3e066e52d60372449aecc7ae6b0" id="r_ae505c3e066e52d60372449aecc7ae6b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae505c3e066e52d60372449aecc7ae6b0">rayshooterInternal</a> (unsigned long Npoints, <a class="el" href="struct_r_a_y.html">RAY</a> *rays)</td></tr>
<tr class="separator:ae505c3e066e52d60372449aecc7ae6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67ceb70df6830db1fbcb8e33aa60176" id="r_ae67ceb70df6830db1fbcb8e33aa60176"><td class="memItemLeft" align="right" valign="top"><a id="ae67ceb70df6830db1fbcb8e33aa60176" name="ae67ceb70df6830db1fbcb8e33aa60176"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rayshooterInternal</b> (<a class="el" href="struct_r_a_y.html">RAY</a> &amp;ray)</td></tr>
<tr class="separator:ae67ceb70df6830db1fbcb8e33aa60176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e67a9aca990e7320e2da25b671faaef" id="r_a7e67a9aca990e7320e2da25b671faaef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e67a9aca990e7320e2da25b671faaef">info_rayshooter</a> (<a class="el" href="struct_r_a_y.html">RAY</a> &amp;i_point, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;ang_positions, std::vector&lt; KappaType &gt; &amp;kappa_on_planes, std::vector&lt; std::vector&lt; <a class="el" href="class_lens_halo.html">LensHalo</a> * &gt; &gt; &amp;halo_neighbors, <a class="el" href="class_lens_halo.html">LensHalo</a> &amp;halo_max, KappaType &amp;kappa_max, KappaType gamma_max[], PosType rmax, int tag=0, short mode=0, bool verbose=false)</td></tr>
<tr class="memdesc:a7e67a9aca990e7320e2da25b671faaef"><td class="mdescLeft">&#160;</td><td class="mdescRight">single ray  <br /></td></tr>
<tr class="separator:a7e67a9aca990e7320e2da25b671faaef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e683b56effd97638db0dceb4cd04c3c" id="r_a5e683b56effd97638db0dceb4cd04c3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e683b56effd97638db0dceb4cd04c3c">mass_on_planes</a> (const std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;rays, std::vector&lt; double &gt; &amp;masses, bool verbose=false)</td></tr>
<tr class="memdesc:a5e683b56effd97638db0dceb4cd04c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the mass within a curve of rays one every lens plane im Msun  <br /></td></tr>
<tr class="separator:a5e683b56effd97638db0dceb4cd04c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73758de70585bda93be75065f772f85b" id="r_a73758de70585bda93be75065f772f85b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_r_a_y.html">RAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73758de70585bda93be75065f772f85b">find_image_min</a> (<a class="el" href="struct_point.html">Point</a> &amp;p, double zs, PosType ytol2, PosType &amp;dy2, bool use_image_guess)</td></tr>
<tr class="memdesc:a73758de70585bda93be75065f772f85b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the image position of a source without grid refinement.  <br /></td></tr>
<tr class="separator:a73758de70585bda93be75065f772f85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea1caf11ec4eff16655de132a701165" id="r_a6ea1caf11ec4eff16655de132a701165"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_r_a_y.html">RAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ea1caf11ec4eff16655de132a701165">find_image_min</a> (const <a class="el" href="struct_r_a_y.html">RAY</a> &amp;in_ray, PosType ytol2)</td></tr>
<tr class="separator:a6ea1caf11ec4eff16655de132a701165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29120751ca87eb68c2c2afc3a6ca9ae4" id="r_a29120751ca87eb68c2c2afc3a6ca9ae4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_r_a_y.html">RAY</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29120751ca87eb68c2c2afc3a6ca9ae4">find_image_min</a> (<a class="el" href="struct_point.html">Point</a> &amp;p, double zs, PosType ytol2, PosType &amp;dy2, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;boundary)</td></tr>
<tr class="memdesc:a29120751ca87eb68c2c2afc3a6ca9ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the same, but the image is forced to stay within boundary.  <br /></td></tr>
<tr class="separator:a29120751ca87eb68c2c2afc3a6ca9ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a8cd1c9c69e16aa7f01a8b0eaff596" id="r_ac4a8cd1c9c69e16aa7f01a8b0eaff596"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4a8cd1c9c69e16aa7f01a8b0eaff596">find_images</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> y_source, double z_source, <a class="el" href="struct_point__2d.html">Point_2d</a> center, double range, double stop_res)</td></tr>
<tr class="memdesc:ac4a8cd1c9c69e16aa7f01a8b0eaff596"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds images by telescoping triangle method  <br /></td></tr>
<tr class="separator:ac4a8cd1c9c69e16aa7f01a8b0eaff596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb05102639f1d175bad05f64e4e3bf56" id="r_adb05102639f1d175bad05f64e4e3bf56"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb05102639f1d175bad05f64e4e3bf56">find_images</a> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;init_grid, <a class="el" href="struct_point__2d.html">Point_2d</a> y_source, double z_source, double stop_res)</td></tr>
<tr class="memdesc:adb05102639f1d175bad05f64e4e3bf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds images by telescoping triangle method  <br /></td></tr>
<tr class="separator:adb05102639f1d175bad05f64e4e3bf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac408b0446806251de0022c4600acfdb7" id="r_ac408b0446806251de0022c4600acfdb7"><td class="memItemLeft" align="right" valign="top"><a id="ac408b0446806251de0022c4600acfdb7" name="ac408b0446806251de0022c4600acfdb7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>find_images_min_parallel</b> (std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;rays, double ytol2, std::vector&lt; bool &gt; &amp;success)</td></tr>
<tr class="separator:ac408b0446806251de0022c4600acfdb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b1279d35b08c49d537708a46c1d3a6" id="r_a71b1279d35b08c49d537708a46c1d3a6"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71b1279d35b08c49d537708a46c1d3a6">ResetSourcePlane</a> (PosType z, bool nearest=false, bool verbose=false)</td></tr>
<tr class="memdesc:a71b1279d35b08c49d537708a46c1d3a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset the redshift of the source plane  <br /></td></tr>
<tr class="separator:a71b1279d35b08c49d537708a46c1d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddbfe99548eb3e63d1d45af2f005972" id="r_a7ddbfe99548eb3e63d1d45af2f005972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ddbfe99548eb3e63d1d45af2f005972">FindSourcePlane</a> (PosType zs, long &amp;jmax, double &amp;Dls, double &amp;Ds)</td></tr>
<tr class="memdesc:a7ddbfe99548eb3e63d1d45af2f005972"><td class="mdescLeft">&#160;</td><td class="mdescRight">find information on the position of the source plane with respect to the lens planes  <br /></td></tr>
<tr class="separator:a7ddbfe99548eb3e63d1d45af2f005972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c16d98618b2a26e75c2673af2058c2" id="r_af4c16d98618b2a26e75c2673af2058c2"><td class="memItemLeft" align="right" valign="top"><a id="af4c16d98618b2a26e75c2673af2058c2" name="af4c16d98618b2a26e75c2673af2058c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RevertSourcePlane</b> ()</td></tr>
<tr class="memdesc:af4c16d98618b2a26e75c2673af2058c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Revert the source redshift to the value it was when the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> was created. <br /></td></tr>
<tr class="separator:af4c16d98618b2a26e75c2673af2058c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77f423ad5bbf4d7256673256a601037" id="r_af77f423ad5bbf4d7256673256a601037"><td class="memItemLeft" align="right" valign="top"><a id="af77f423ad5bbf4d7256673256a601037" name="af77f423ad5bbf4d7256673256a601037"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getSourceZ</b> ()</td></tr>
<tr class="separator:af77f423ad5bbf4d7256673256a601037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45fd74bb5f5ffc4ee1610db34bb96def" id="r_a45fd74bb5f5ffc4ee1610db34bb96def"><td class="memItemLeft" align="right" valign="top"><a id="a45fd74bb5f5ffc4ee1610db34bb96def" name="a45fd74bb5f5ffc4ee1610db34bb96def"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getZmax</b> () const</td></tr>
<tr class="separator:a45fd74bb5f5ffc4ee1610db34bb96def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e65d6c8d5c97e4024d7002eb8cc7d04" id="r_a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="memItemLeft" align="right" valign="top"><a id="a6e65d6c8d5c97e4024d7002eb8cc7d04" name="a6e65d6c8d5c97e4024d7002eb8cc7d04"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintCosmology</b> ()</td></tr>
<tr class="memdesc:a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="mdescLeft">&#160;</td><td class="mdescRight">print the cosmological parameters <br /></td></tr>
<tr class="separator:a6e65d6c8d5c97e4024d7002eb8cc7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53108c7002e0cb4ce7064d43c5efdb0e" id="r_a53108c7002e0cb4ce7064d43c5efdb0e"><td class="memItemLeft" align="right" valign="top"><a id="a53108c7002e0cb4ce7064d43c5efdb0e" name="a53108c7002e0cb4ce7064d43c5efdb0e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getSigmaCrit</b> (PosType zsource) const</td></tr>
<tr class="memdesc:a53108c7002e0cb4ce7064d43c5efdb0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the critical density at the main lens in Msun/ Mpc^2 for a source at zsource <br /></td></tr>
<tr class="separator:a53108c7002e0cb4ce7064d43c5efdb0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ba1ed741c10e793c12dd8f0693a4384" id="r_a6ba1ed741c10e793c12dd8f0693a4384"><td class="memItemLeft" align="right" valign="top"><a id="a6ba1ed741c10e793c12dd8f0693a4384" name="a6ba1ed741c10e793c12dd8f0693a4384"></a>
const <a class="el" href="class_c_o_s_m_o_l_o_g_y.html">COSMOLOGY</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getCosmo</b> ()</td></tr>
<tr class="memdesc:a6ba1ed741c10e793c12dd8f0693a4384"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const reference to the cosmology so that constant functions can be used, but the cosmological parameters cannot be changed. <br /></td></tr>
<tr class="separator:a6ba1ed741c10e793c12dd8f0693a4384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ef8e31f5a9d3ada238db9c8a8babe9" id="r_a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="memItemLeft" align="right" valign="top"><a id="a40ef8e31f5a9d3ada238db9c8a8babe9" name="a40ef8e31f5a9d3ada238db9c8a8babe9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TurnFieldOff</b> ()</td></tr>
<tr class="memdesc:a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">set flag_switch_field_off, turn the field On/Off : <br /></td></tr>
<tr class="separator:a40ef8e31f5a9d3ada238db9c8a8babe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b527844992bbd710bb5bee3c7e55f3" id="r_a15b527844992bbd710bb5bee3c7e55f3"><td class="memItemLeft" align="right" valign="top"><a id="a15b527844992bbd710bb5bee3c7e55f3" name="a15b527844992bbd710bb5bee3c7e55f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TurnFieldOn</b> ()</td></tr>
<tr class="separator:a15b527844992bbd710bb5bee3c7e55f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3769e1aec46d81eab053a7de55f464cc" id="r_a3769e1aec46d81eab053a7de55f464cc"><td class="memItemLeft" align="right" valign="top"><a id="a3769e1aec46d81eab053a7de55f464cc" name="a3769e1aec46d81eab053a7de55f464cc"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>getFieldMinMass</b> () const</td></tr>
<tr class="memdesc:a3769e1aec46d81eab053a7de55f464cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the field min mass : <br /></td></tr>
<tr class="separator:a3769e1aec46d81eab053a7de55f464cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a6ea256727745b13b6df8258cfa7ec0" id="r_a6a6ea256727745b13b6df8258cfa7ec0"><td class="memItemLeft" align="right" valign="top"><a id="a6a6ea256727745b13b6df8258cfa7ec0" name="a6a6ea256727745b13b6df8258cfa7ec0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>getfieldOff</b> () const</td></tr>
<tr class="separator:a6a6ea256727745b13b6df8258cfa7ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2fa9d4008780de6be33f3fa165e931" id="r_a3b2fa9d4008780de6be33f3fa165e931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_lens.html">Lens</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b2fa9d4008780de6be33f3fa165e931">operator=</a> (<a class="el" href="class_lens.html">Lens</a> &amp;&amp;lens)</td></tr>
<tr class="separator:a3b2fa9d4008780de6be33f3fa165e931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f940236f66e88f8a3b73efbb7c2bc" id="r_a557f940236f66e88f8a3b73efbb7c2bc"><td class="memItemLeft" align="right" valign="top"><a id="a557f940236f66e88f8a3b73efbb7c2bc" name="a557f940236f66e88f8a3b73efbb7c2bc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b> (<a class="el" href="class_lens.html">Lens</a> &amp;&amp;lens)</td></tr>
<tr class="separator:a557f940236f66e88f8a3b73efbb7c2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd000047ad4fa2dc6ed005acaee14d29" id="r_afd000047ad4fa2dc6ed005acaee14d29"><td class="memItemLeft" align="right" valign="top"><a id="afd000047ad4fa2dc6ed005acaee14d29" name="afd000047ad4fa2dc6ed005acaee14d29"></a>
std::vector&lt; PosType &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_plane_redshifts</b> ()</td></tr>
<tr class="separator:afd000047ad4fa2dc6ed005acaee14d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a09c7b4946959331f7dc5aed93053727c" id="r_a09c7b4946959331f7dc5aed93053727c"><td class="memItemLeft" align="right" valign="top"><a id="a09c7b4946959331f7dc5aed93053727c" name="a09c7b4946959331f7dc5aed93053727c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>set</b></td></tr>
<tr class="memdesc:a09c7b4946959331f7dc5aed93053727c"><td class="mdescLeft">&#160;</td><td class="mdescRight">marks if the lens has been setup. <br /></td></tr>
<tr class="separator:a09c7b4946959331f7dc5aed93053727c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aee17d6e92bea425de358a9381ad6280b" id="r_aee17d6e92bea425de358a9381ad6280b"><td class="memItemLeft" align="right" valign="top"><a id="aee17d6e92bea425de358a9381ad6280b" name="aee17d6e92bea425de358a9381ad6280b"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fieldofview</b></td></tr>
<tr class="memdesc:aee17d6e92bea425de358a9381ad6280b"><td class="mdescLeft">&#160;</td><td class="mdescRight">field of view in square degrees <br /></td></tr>
<tr class="separator:aee17d6e92bea425de358a9381ad6280b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to represents a lens with multiple planes. </p>
<pre>
 The rays are traced through multiple deflections.  On each plane there is a deflection
 solver.  An <a class="el" href="class_lens_halo_ana_n_s_i_e.html" title="A NSIE lens with distortions in shape, substructures and stars included.">LensHaloAnaNSIE</a> or <a class="el" href="class_lens_halo_mass_map.html" title="A class that includes the MOKA lens map.">LensHaloMassMap</a> can be put on one of the planes.  The other planes can be
 populated with random field_halos drawn from a mass function or they can be retrieved from an
 extern&amp;al catalog.

   Input Parameters (variable names):

   main_halo_on -- 0: no major lens present; 1: there is a major lens present
   main_halo_type -- profile type for the main DM lens halo
    0 or nolens, 1 or NFW, 2 or PseudoNFW, 3 or PowerLaw, 4 or NSIE, 5 or AnaLens, 6 or UniLens, 7 or MOKALens, 8 or DummyLens
   main_galaxy_halo_type -- profile typ for the main galaxy lens halo 0 or none, 1 or NSIE
   redshift_planes_file -- asci file with the redshifts of the lensing planes, if not set then created internaly
   flag_switch_field_off -- false: field halos are created, true: no field halos are created; default is false

   if field_off == false, i.e. there are field halos then also the following are used:
   field_Nplanes -- number of field planes
   field_fov -- field of view of the light cone, filled with field halos
   field_internal_profile -- profile type of the DM field lens halos
    0 or nolens, 1 or NFW, 2 or PseudoNFW, 3 or PowerLaw, 4 or NSIE, 5 or AnaLens, 6 or UniLens, 7 or MOKALens, 8 or DummyLens, 9 or Hernquist, 10 or Jaffe
   field_prof_internal_slope_pl -- slope of the surface density for power law
   field_prof_internal_slope_pnfw -- slope of the surface density for pseudo nfw profiles
   field_internal_profile_galaxy -- profile type of the galaxy field halos; if not set, no galaxies are used
    0 or none, 1 or NSIE

   field_input_sim_file -- filename of the Millennium simulation data to be read in and used to populate the light cone with field halos

   if field_input_sim_file is  _not_ set, then the field halos are generated from a mass function and the following are used:
   field_mass_func_type -- type of the halo mass function
    PS (0), ST (1), and power law (2)
   mass_func_PL_slope -- slope of the mass function in the power law case; default is -1/6
   field_min_mass -- minimum mass for the generated field halos
   field_buffer -- a constant physical size buffer, padding every lens plane to increase its surface

   zsource -- source redshift
   flag_switch_deflection_off -- false: deflection is on, but kappa and gamma may be calculated, true: deflection is off; default is false
   flag_switch_lensing_off -- false: lensing is on, true: lensing is off (no alpha, kappa or gamma); default is false

   # Cosmology - Any cosmological parameters that are not set will have default values

  Omega_matter -- Total mass (baryons + dark matter) in the units of the critical density, optional
  Omega_lambda -- Density in a cosmological constant, if not set it will be = 1 - Omega_matter
  Omega_baryon -- Density in baryons
  Omega_neutrino -- Density in neutrinos
  hubble -- Hubble parameter in units of 100 km/s/Mpc
  sigm_8 -- normalization of power spectrum

 </pre> </div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a6ea1caf11ec4eff16655de132a701165" name="a6ea1caf11ec4eff16655de132a701165"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea1caf11ec4eff16655de132a701165">&#9670;&#160;</a></span>find_image_min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_r_a_y.html">RAY</a> Lens::find_image_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_r_a_y.html">RAY</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in_ray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>ytol2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>this version uses the redshift stored in the ray,</p>
<p>Tthe ray is replaced with the best guess so the source position is replaced. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in_ray</td><td>p.y[] should be set to source position  </td></tr>
    <tr><td class="paramname">ytol2</td><td>target tolerance in source position squared </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a73758de70585bda93be75065f772f85b" name="a73758de70585bda93be75065f772f85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73758de70585bda93be75065f772f85b">&#9670;&#160;</a></span>find_image_min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_r_a_y.html">RAY</a> Lens::find_image_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>zs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>ytol2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType &amp;</td>          <td class="paramname"><span class="paramname"><em>dy2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>use_image_guess</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the image position of a source without grid refinement. </p>
<p>This uses Powell's algorithm to minimise the distance between the source point of an image and the desired source point. No grid is necessary. This should be fast, but will miss multiple images. This is useful for finding the position of weakly lensed images or the rough region where a grid should be put down for a strong lens.</p>
<p>Find the image position of a source without grid refinement.</p>
<p>This finds an image position given a source postion. No grid is necessary.</p>
<p>If use_image_guess=true the input image position will be used as a first guess and the output image will be guarenteed to have the same pairity.</p>
<p>This is useful for finding the position of weakly lensed images or for refining the image positions that are found on a finite grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>p.image-&gt;x should be set to source position  </td></tr>
    <tr><td class="paramname">zs</td><td>redhsift of source  </td></tr>
    <tr><td class="paramname">ytol2</td><td>target tolerance in source position squared  </td></tr>
    <tr><td class="paramname">dy2</td><td>final value of Delta y ^2  </td></tr>
    <tr><td class="paramname">use_image_guess</td><td>if true p.x[] will be used as a guess for the image position </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29120751ca87eb68c2c2afc3a6ca9ae4" name="a29120751ca87eb68c2c2afc3a6ca9ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29120751ca87eb68c2c2afc3a6ca9ae4">&#9670;&#160;</a></span>find_image_min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_r_a_y.html">RAY</a> Lens::find_image_min </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>p</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>zs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>ytol2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType &amp;</td>          <td class="paramname"><span class="paramname"><em>dy2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>boundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the same, but the image is forced to stay within boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>p[] is  </td></tr>
    <tr><td class="paramname">zs</td><td>source redshift  </td></tr>
    <tr><td class="paramname">ytol2</td><td>target tolerance in source position squared  </td></tr>
    <tr><td class="paramname">dy2</td><td>final value of Delta y ^2  </td></tr>
    <tr><td class="paramname">boundary</td><td>image will be limited to within this boundary </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb05102639f1d175bad05f64e4e3bf56" name="adb05102639f1d175bad05f64e4e3bf56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb05102639f1d175bad05f64e4e3bf56">&#9670;&#160;</a></span>find_images() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; Lens::find_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_grid_map.html">GridMap</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>init_grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>y_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>z_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>stop_res</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds images by telescoping triangle method </p>
<p>find rays using telescoping triangle method starting with a <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> init_grid</p>
<p>Meant for refining the image positions to higher resolution than the initial grid </p>

</div>
</div>
<a id="ac4a8cd1c9c69e16aa7f01a8b0eaff596" name="ac4a8cd1c9c69e16aa7f01a8b0eaff596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a8cd1c9c69e16aa7f01a8b0eaff596">&#9670;&#160;</a></span>find_images() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; Lens::find_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>y_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>z_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>stop_res</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds images by telescoping triangle method </p>
<p>find rays using telescoping triangle method </p>

</div>
</div>
<a id="a7ddbfe99548eb3e63d1d45af2f005972" name="a7ddbfe99548eb3e63d1d45af2f005972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddbfe99548eb3e63d1d45af2f005972">&#9670;&#160;</a></span>FindSourcePlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::FindSourcePlane </td>
          <td>(</td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>zs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;</td>          <td class="paramname"><span class="paramname"><em>jmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Dls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>Ds</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find information on the position of the source plane with respect to the lens planes </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">zs</td><td>redshift of implanted source  </td></tr>
    <tr><td class="paramname">jmax</td><td>index of last plane at lower redshift  </td></tr>
    <tr><td class="paramname">Dls</td><td>coordinate distance between last plane and source plane  </td></tr>
    <tr><td class="paramname">Ds</td><td>total coordinate distance to source plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5edcf261950dab5a8d3339626b01eed" name="ad5edcf261950dab5a8d3339626b01eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5edcf261950dab5a8d3339626b01eed">&#9670;&#160;</a></span>getNMainHalos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t Lens::getNMainHalos </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>inserts a sequence of main lens halos and adds them to the existing ones </p>
<p>replaces existing main halos with a single main halo replaces existing main halos with a sequence of main halos</p>
<p>This function will randomize the substructure without changing the region, mass function, etc.</p>
<p>The Lens::insertSubstructures() function must have been called on this instance of the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> before. get number of main halos </p>

</div>
</div>
<a id="a7e67a9aca990e7320e2da25b671faaef" name="a7e67a9aca990e7320e2da25b671faaef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e67a9aca990e7320e2da25b671faaef">&#9670;&#160;</a></span>info_rayshooter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::info_rayshooter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_y.html">RAY</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ang_positions</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; KappaType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>kappa_on_planes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="class_lens_halo.html">LensHalo</a> * &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>halo_neighbors</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lens_halo.html">LensHalo</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>halo_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KappaType &amp;</td>          <td class="paramname"><span class="paramname"><em>kappa_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KappaType</td>          <td class="paramname"><span class="paramname"><em>gamma_max</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>rmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>tag</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>single ray </p>
<p>Collects information about the halos and kappa contributions along the light path.</p>
<p>Information on the nearest halos is collected where nearest is defined by rmax and mode. When mode == 2 the unlensed angular coordinates are used to evaluate proximity not the lensed ones. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ray</td><td>ray, ray.x needs to be set, all other quantities will be calculated  </td></tr>
    <tr><td class="paramname">ang_positions</td><td>angular positions on each plane  </td></tr>
    <tr><td class="paramname">kappa_on_planes</td><td>convergence on each plane  </td></tr>
    <tr><td class="paramname">halo_neighbors</td><td>neighboring halos within rmax of ray on each plane  </td></tr>
    <tr><td class="paramname">halo_max</td><td>halo with the larges kappa  </td></tr>
    <tr><td class="paramname">kappa_max</td><td>the kappa from that halo  </td></tr>
    <tr><td class="paramname">gamma_max</td><td>shear from that halo  </td></tr>
    <tr><td class="paramname">rmax</td><td>distance from ray on each plane, units depend on mode parameter  </td></tr>
    <tr><td class="paramname">tag</td><td>i f not 0, information on halos with this tag are gathered  </td></tr>
    <tr><td class="paramname">mode</td><td>0:physical distance, 1: comoving distance, 2: angular distance </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af7403e6372cd1a396fb098cbd1d824cc" name="af7403e6372cd1a396fb098cbd1d824cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7403e6372cd1a396fb098cbd1d824cc">&#9670;&#160;</a></span>insertMainHalos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::insertMainHalos </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>my_halos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>addplanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a sequense of main lens halos and adds them to the existing ones. Then all lensing planes are updated accordingly. If addplanes is true new planes will be added otherwise the halo is added to the nearest plane and a plane is added only if none exited on entry. </p>
<p>The angular position of the halo should be preserved, but the x coordinates may change The halos are copied so the input halos can be destoyed without affecting the <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a>. </p>

</div>
</div>
<a id="a5e683b56effd97638db0dceb4cd04c3c" name="a5e683b56effd97638db0dceb4cd04c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e683b56effd97638db0dceb4cd04c3c">&#9670;&#160;</a></span>mass_on_planes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::mass_on_planes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rays</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>masses</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds the mass within a curve of rays one every lens plane im Msun </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rays</td><td>ray, ray.x needs to be set  </td></tr>
    <tr><td class="paramname">masses</td><td>mass within curve on each lens plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8a8bbd818794bc97ee6d3f842e82e54" name="aa8a8bbd818794bc97ee6d3f842e82e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a8bbd818794bc97ee6d3f842e82e54">&#9670;&#160;</a></span>moveinMainHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::moveinMainHalo </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>halo_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>addplanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This has the same effect as <a class="el" href="#a177ee7cbb406d835865edd855b556d63" title="inserts a single main lens halo and adds it to the existing ones">insertMainHalo()</a>, but the halo is not copied, it is moved. </p>
<p>The <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> will take possession of the halo and will destroy it when it is destroyed. This is to avoid copying halos that take up a lot of memory and require a lot of time to copy like <a class="el" href="class_lens_halo_particles.html" title="A class that represents the lensing by a collection of simulation particles.">LensHaloParticles()</a>. </p>

</div>
</div>
<a id="a3b2fa9d4008780de6be33f3fa165e931" name="a3b2fa9d4008780de6be33f3fa165e931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2fa9d4008780de6be33f3fa165e931">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_lens.html">Lens</a> &amp; Lens::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">Lens</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>lens</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MixedVector cannot be copyed</p>

</div>
</div>
<a id="a7a8ed89e743c26f14ab8e3992fa3118a" name="a7a8ed89e743c26f14ab8e3992fa3118a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a8ed89e743c26f14ab8e3992fa3118a">&#9670;&#160;</a></span>rayshooter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::rayshooter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_r_a_y.html">RAY</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>ray</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using to shoot a single ray. </p>
<p>This function calculates the deflection, shear, convergence, rotation and time-delay of rays in parallel. The source redshift must be set for the ray.</p>
<p>ray.x should be set to the image position. The kappa,gamma,deflection, time-delay and source position will be calculated at that image point. </p>

</div>
</div>
<a id="a2575c6d766091cde0ce87249e97333f1" name="a2575c6d766091cde0ce87249e97333f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2575c6d766091cde0ce87249e97333f1">&#9670;&#160;</a></span>rayshooterInternal() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::rayshooterInternal </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_linked_point.html">LinkedPoint</a> *</td>          <td class="paramname"><span class="paramname"><em>i_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>source_zs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>RSIverbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Routine for shooting rays with differnt source redshifts in parrallel. </p>
<p>i_points[].x must be set to the image postion in angular radians. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Npoints</td><td>number of points to be shot  </td></tr>
    <tr><td class="paramname">i_points</td><td>poinst on the image plane  </td></tr>
    <tr><td class="paramname">source_zs</td><td>source redshifts  </td></tr>
    <tr><td class="paramname">RSIverbose</td><td>verbose option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a711067d75213f4e6bc0f8a5606faf66a" name="a711067d75213f4e6bc0f8a5606faf66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711067d75213f4e6bc0f8a5606faf66a">&#9670;&#160;</a></span>rayshooterInternal() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::rayshooterInternal </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>i_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>RSIverbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main routine for shooting rays in parrallel. </p>
<p>i_points[].x must be set to the image postion in angular radians.</p>
<p>i_points must have linked image points. <code><a class="el" href="struct_linked_point.html" title="A point that automatically has an image point.">LinkedPoint</a></code>s could be used, but for its internal use this is not done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Npoints</td><td>number of points to be shot  </td></tr>
    <tr><td class="paramname">i_points</td><td>points on the image plane  </td></tr>
    <tr><td class="paramname">RSIverbose</td><td>verbose option </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae505c3e066e52d60372449aecc7ae6b0" name="ae505c3e066e52d60372449aecc7ae6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae505c3e066e52d60372449aecc7ae6b0">&#9670;&#160;</a></span>rayshooterInternal() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::rayshooterInternal </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_r_a_y.html">RAY</a> *</td>          <td class="paramname"><span class="paramname"><em>rays</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Npoints</td><td>number of points to be shot  </td></tr>
    <tr><td class="paramname">rays</td><td>points on the image plane </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba7e1b3c66565092fdc7555dc4704896" name="aba7e1b3c66565092fdc7555dc4704896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7e1b3c66565092fdc7555dc4704896">&#9670;&#160;</a></span>replaceMainHalo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::replaceMainHalo </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>halo_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>addplanes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a single main lens halo and deletes all previous ones. Then all lensing planes are updated accordingly. </p>
<p>Note that this does delete all the halos that were there. </p>

</div>
</div>
<a id="a0cfbb73f3ff13e43beccb50d18a89af4" name="a0cfbb73f3ff13e43beccb50d18a89af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cfbb73f3ff13e43beccb50d18a89af4">&#9670;&#160;</a></span>replaceMainHalos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::replaceMainHalos </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>my_halos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inserts a sequense of main lens halos and remove all previous ones. </p>
<p>Note that this does delete the halos that were there. Then all lensing planes are updated accordingly. </p>

</div>
</div>
<a id="ae4151410075a47b095f2f716055b1c69" name="ae4151410075a47b095f2f716055b1c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4151410075a47b095f2f716055b1c69">&#9670;&#160;</a></span>resetFieldHalos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Lens::resetFieldHalos </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>keep the main lens and the number of planes constant, but generate new field halos. </p>

</div>
</div>
<a id="a71b1279d35b08c49d537708a46c1d3a6" name="a71b1279d35b08c49d537708a46c1d3a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b1279d35b08c49d537708a46c1d3a6">&#9670;&#160;</a></span>ResetSourcePlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short Lens::ResetSourcePlane </td>
          <td>(</td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>z</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nearest</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reset the redshift of the source plane </p>
<p>Changes the maximum redshift that the rays are shot to. Warning: Grids that have already been made with this <a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> will not have this new source redshift.</p>
<p>The multilens must have been initially constructed with a source redshift that is higher than this redshift. This is used to rayshoot to a source whose line of sight passes through the simulation volume. The source can be at higher redshift than the simulation volume.</p>
<p>To revert the source redshift to its original value use <a class="el" href="#af4c16d98618b2a26e75c2673af2058c2" title="Revert the source redshift to the value it was when the Lens was created.">Lens::RevertSourcePlane()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">z</td><td>redshift of implanted source  </td></tr>
    <tr><td class="paramname">nearest</td><td>If true, set the source plane to the nearest (in coordinate distance) lensing plane that was created already. This can be used to avoid self-lensing by the halo of the source. If the source is at higher redshift than the simulation volume the source will be at its real redshift. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="lens_8h_source.html">lens.h</a></li>
<li>SLsimLib/FullRange/<b>internal_rayshooter_multi.cpp</b></li>
<li>SLsimLib/MultiPlane/<b>lens.cpp</b></li>
<li>SLsimLib/MultiPlane/<b>lens_multi_dark.cpp</b></li>
<li>SLsimLib/TreeCode_link/<b>image_finder.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 8 2024 19:31:03 for GLAMERDOC++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
