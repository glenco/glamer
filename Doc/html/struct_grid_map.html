<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: GridMap Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="struct_grid_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GridMap Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simplified version of the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a> structure for making non-adaptive maps of the lensing quantities (kappa, gamma, etc...)  
 <a href="struct_grid_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gridmap_8h_source.html">gridmap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad8a0873c4dac82c434100643227d601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aad8a0873c4dac82c434100643227d601">GridMap</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:aad8a0873c4dac82c434100643227d601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing square grid.  <a href="#aad8a0873c4dac82c434100643227d601">More...</a><br /></td></tr>
<tr class="separator:aad8a0873c4dac82c434100643227d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36490f8b993d04ddb1f987a30871f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aea36490f8b993d04ddb1f987a30871f6">GridMap</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long Nx, const PosType center[2], PosType rangeX, PosType rangeY)</td></tr>
<tr class="memdesc:aea36490f8b993d04ddb1f987a30871f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing rectangular grid.  <a href="#aea36490f8b993d04ddb1f987a30871f6">More...</a><br /></td></tr>
<tr class="separator:aea36490f8b993d04ddb1f987a30871f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f26ca8df0d66e02553dec0f628f684"><td class="memItemLeft" align="right" valign="top"><a id="ae7f26ca8df0d66e02553dec0f628f684"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ae7f26ca8df0d66e02553dec0f628f684">ReInitializeGrid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:ae7f26ca8df0d66e02553dec0f628f684"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshoot the rays for example when the source plane has been changed <br /></td></tr>
<tr class="separator:ae7f26ca8df0d66e02553dec0f628f684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4242350b46cbd85b47818b8101f9e2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a3e4242350b46cbd85b47818b8101f9e2">RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:a3e4242350b46cbd85b47818b8101f9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness at every point without changing the positions of the gridmap or any lens properties.  <a href="#a3e4242350b46cbd85b47818b8101f9e2">More...</a><br /></td></tr>
<tr class="separator:a3e4242350b46cbd85b47818b8101f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668b2cff39b656fcf3a4e2df290f638"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ab668b2cff39b656fcf3a4e2df290f638">AddSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:ab668b2cff39b656fcf3a4e2df290f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness just like GridMap::RefreshSurfaceBrightness but the new source is added to any sources that were already there.  <a href="#ab668b2cff39b656fcf3a4e2df290f638">More...</a><br /></td></tr>
<tr class="separator:ab668b2cff39b656fcf3a4e2df290f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55353b1d0ba3890de6f1c5456840bd8"><td class="memItemLeft" align="right" valign="top"><a id="af55353b1d0ba3890de6f1c5456840bd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearSurfaceBrightnesses</b> ()</td></tr>
<tr class="separator:af55353b1d0ba3890de6f1c5456840bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5a2f995d57fcbcba8e74f96f6e5b6"><td class="memItemLeft" align="right" valign="top"><a id="a17a5a2f995d57fcbcba8e74f96f6e5b6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfPoints</b> () const</td></tr>
<tr class="separator:a17a5a2f995d57fcbcba8e74f96f6e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1378437640a32f87e245da4c7b263022"><td class="memItemLeft" align="right" valign="top"><a id="a1378437640a32f87e245da4c7b263022"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a1378437640a32f87e245da4c7b263022">getInitNgrid</a> ()</td></tr>
<tr class="memdesc:a1378437640a32f87e245da4c7b263022"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial number of grid points in each direction <br /></td></tr>
<tr class="separator:a1378437640a32f87e245da4c7b263022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757a6f8419587022795df0bced6131ec"><td class="memItemLeft" align="right" valign="top"><a id="a757a6f8419587022795df0bced6131ec"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a757a6f8419587022795df0bced6131ec">getXRange</a> ()</td></tr>
<tr class="memdesc:a757a6f8419587022795df0bced6131ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial range of gridded region. This is the distance from the first ray in a row to the last (unlike <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a>) <br /></td></tr>
<tr class="separator:a757a6f8419587022795df0bced6131ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb260b81a1c34dfa090f8f3dfd7904c"><td class="memItemLeft" align="right" valign="top"><a id="adfb260b81a1c34dfa090f8f3dfd7904c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getYRange</b> ()</td></tr>
<tr class="separator:adfb260b81a1c34dfa090f8f3dfd7904c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1ac9c5e97b87d2ddfd29260ed4cea"><td class="memItemLeft" align="right" valign="top"><a id="a27a1ac9c5e97b87d2ddfd29260ed4cea"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a27a1ac9c5e97b87d2ddfd29260ed4cea">getResolution</a> ()</td></tr>
<tr class="memdesc:a27a1ac9c5e97b87d2ddfd29260ed4cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">resolution in radians, this is range / (N-1) <br /></td></tr>
<tr class="separator:a27a1ac9c5e97b87d2ddfd29260ed4cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55e0cb0283537108615b228dbb057a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aed55e0cb0283537108615b228dbb057a">writePixelMapUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar)</td></tr>
<tr class="memdesc:aed55e0cb0283537108615b228dbb057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Pixel map of the without distribution the pixels.  <a href="#aed55e0cb0283537108615b228dbb057a">More...</a><br /></td></tr>
<tr class="separator:aed55e0cb0283537108615b228dbb057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1e721790ac12b240e73d9a699384f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a0d1e721790ac12b240e73d9a699384f9">writePixelMapUniform</a> (LensingVariable lensvar)</td></tr>
<tr class="memdesc:a0d1e721790ac12b240e73d9a699384f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">make pixel map of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>  <a href="#a0d1e721790ac12b240e73d9a699384f9">More...</a><br /></td></tr>
<tr class="separator:a0d1e721790ac12b240e73d9a699384f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8dbd5fd0a8c672b33fbe6ff6787ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a4ea8dbd5fd0a8c672b33fbe6ff6787ad">writePixelMapUniform</a> (<a class="el" href="class_pixel_map.html">PixelMap</a> &amp;map, LensingVariable lensvar)</td></tr>
<tr class="separator:a4ea8dbd5fd0a8c672b33fbe6ff6787ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b3520105f861334d0da8cd0cf60ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a1d0b3520105f861334d0da8cd0cf60ba">writeFitsUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="separator:a1d0b3520105f861334d0da8cd0cf60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="memItemLeft" align="right" valign="top"><a id="a21ba3c14b21e7a7e83e80e0a8c3aa7ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a21ba3c14b21e7a7e83e80e0a8c3aa7ba">writeFitsUniform</a> (LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">this will make a fits map of the grid as is. <br /></td></tr>
<tr class="separator:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa568491f3d6a527782d840e3cfc4d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a4aa568491f3d6a527782d840e3cfc4d3">getPixelMap</a> (int res) const</td></tr>
<tr class="memdesc:a4aa568491f3d6a527782d840e3cfc4d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution  <a href="#a4aa568491f3d6a527782d840e3cfc4d3">More...</a><br /></td></tr>
<tr class="separator:a4aa568491f3d6a527782d840e3cfc4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87d83cc6f0e3f08d9a0393e3720c5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ac87d83cc6f0e3f08d9a0393e3720c5f9">getPixelMap</a> (<a class="el" href="class_pixel_map.html">PixelMap</a> &amp;map) const</td></tr>
<tr class="memdesc:ac87d83cc6f0e3f08d9a0393e3720c5f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">surface brightness map  <a href="#ac87d83cc6f0e3f08d9a0393e3720c5f9">More...</a><br /></td></tr>
<tr class="separator:ac87d83cc6f0e3f08d9a0393e3720c5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408b0ac19bc5678ca316a582250f4946"><td class="memItemLeft" align="right" valign="top"><a id="a408b0ac19bc5678ca316a582250f4946"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a408b0ac19bc5678ca316a582250f4946">EinsteinArea</a> () const</td></tr>
<tr class="memdesc:a408b0ac19bc5678ca316a582250f4946"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the area (radians^2) of the region with negative magnification at resolution of fixed grid <br /></td></tr>
<tr class="separator:a408b0ac19bc5678ca316a582250f4946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee258972a6f83896ba50cd3a5e044e7"><td class="memItemLeft" align="right" valign="top"><a id="a9ee258972a6f83896ba50cd3a5e044e7"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a9ee258972a6f83896ba50cd3a5e044e7">magnification</a> () const</td></tr>
<tr class="memdesc:a9ee258972a6f83896ba50cd3a5e044e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">flux weighted magnification with current surface brightness averaged on the image plane <br /></td></tr>
<tr class="separator:a9ee258972a6f83896ba50cd3a5e044e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b368c185625e84e69cb65b2cc6f1f"><td class="memItemLeft" align="right" valign="top"><a id="ae31b368c185625e84e69cb65b2cc6f1f"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCenter</b> ()</td></tr>
<tr class="separator:ae31b368c185625e84e69cb65b2cc6f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57584c918879952a0b9b327f399b8754"><td class="memItemLeft" align="right" valign="top"><a id="a57584c918879952a0b9b327f399b8754"></a>
<a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i)</td></tr>
<tr class="separator:a57584c918879952a0b9b327f399b8754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b0fe1404063813ddc428175219ca29"><td class="memItemLeft" align="right" valign="top"><a id="a73b0fe1404063813ddc428175219ca29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GridMap</b> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a73b0fe1404063813ddc428175219ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b17cdeee551654f223a7f7fc0ac51"><td class="memItemLeft" align="right" valign="top"><a id="a5b6b17cdeee551654f223a7f7fc0ac51"></a>
<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a5b6b17cdeee551654f223a7f7fc0ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simplified version of the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a> structure for making non-adaptive maps of the lensing quantities (kappa, gamma, etc...) </p>
<p>GripMap is faster and uses less memory than <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a>. It does not construct the tree structures for the points and thus cannot be used for adaptive mapping or image finding. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aad8a0873c4dac82c434100643227d601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8a0873c4dac82c434100643227d601">&#9670;&nbsp;</a></span>GridMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridMap::GridMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing square grid. </p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea36490f8b993d04ddb1f987a30871f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea36490f8b993d04ddb1f987a30871f6">&#9670;&nbsp;</a></span>GridMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridMap::GridMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>my_center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing rectangular grid. </p>
<p>Cells of grid will always be square with initial resolution rangeX/(Nx-1). The Y range may not be exactly rangeY, but will be the nearest value that is a whole number of cells.</p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">Nx</td><td>Initial number of grid points in X dimension. </td></tr>
    <tr><td class="paramname">my_center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">rangeX</td><td>Full width of grid in x direction in whatever units will be used. </td></tr>
    <tr><td class="paramname">rangeY</td><td>Full width of grid in y direction in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab668b2cff39b656fcf3a4e2df290f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab668b2cff39b656fcf3a4e2df290f638">&#9670;&nbsp;</a></span>AddSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::AddSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">SourceHndl</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness just like GridMap::RefreshSurfaceBrightness but the new source is added to any sources that were already there. </p>
<p>returns the sum of the surface brightnesses from the new source </p>

</div>
</div>
<a id="a4aa568491f3d6a527782d840e3cfc4d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa568491f3d6a527782d840e3cfc4d3">&#9670;&nbsp;</a></span>getPixelMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::getPixelMap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution </p>
<p>Output a <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a> of the surface brightness with same res as the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>

</div>
</div>
<a id="ac87d83cc6f0e3f08d9a0393e3720c5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87d83cc6f0e3f08d9a0393e3720c5f9">&#9670;&nbsp;</a></span>getPixelMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::getPixelMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>surface brightness map </p>
<p>update a <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution. The map must have precisely the right size and center to match or an exception will be thrown. Constructing the map with <a class="el" href="class_pixel_map.html" title="Takes image structure and pixelizes the flux into regular pixel grid which then can be exported as a ...">PixelMap</a> getPixelMap(int res) will insure that it does. </p>

</div>
</div>
<a id="a3e4242350b46cbd85b47818b8101f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4242350b46cbd85b47818b8101f9e2">&#9670;&nbsp;</a></span>RefreshSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::RefreshSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">SourceHndl</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness at every point without changing the positions of the gridmap or any lens properties. </p>
<p>Recalculate the surface brightness at all points on the gridmap. This is useful when changing the source model while preserving changes in the grid. Both i_tree and s_tree are both changed although only s_tree shows up here.</p>
<p>returns the sum of the surface brightnesses </p>

</div>
</div>
<a id="a1d0b3520105f861334d0da8cd0cf60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b3520105f861334d0da8cd0cf60ba">&#9670;&nbsp;</a></span>writeFitsUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed55e0cb0283537108615b228dbb057a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55e0cb0283537108615b228dbb057a">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Pixel map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d1e721790ac12b240e73d9a699384f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1e721790ac12b240e73d9a699384f9">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make pixel map of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ea8dbd5fd0a8c672b33fbe6ff6787ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea8dbd5fd0a8c672b33fbe6ff6787ad">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="gridmap_8h_source.html">gridmap.h</a></li>
<li>SLsimLib/TreeCode_link/gridmap.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Dec 23 2019 18:37:20 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
