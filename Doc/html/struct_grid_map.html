<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: GridMap Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_grid_map-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GridMap Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simplified version of the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> structure for making non-adaptive maps of the lensing quantities (kappa, gamma, etc...)  
 <a href="struct_grid_map.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gridmap_8h_source.html">gridmap.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aad8a0873c4dac82c434100643227d601"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aad8a0873c4dac82c434100643227d601">GridMap</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:aad8a0873c4dac82c434100643227d601"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing square grid.  <a href="struct_grid_map.html#aad8a0873c4dac82c434100643227d601">More...</a><br /></td></tr>
<tr class="separator:aad8a0873c4dac82c434100643227d601"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea36490f8b993d04ddb1f987a30871f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aea36490f8b993d04ddb1f987a30871f6">GridMap</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long Nx, const PosType center[2], PosType rangeX, PosType rangeY)</td></tr>
<tr class="memdesc:aea36490f8b993d04ddb1f987a30871f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing rectangular grid.  <a href="struct_grid_map.html#aea36490f8b993d04ddb1f987a30871f6">More...</a><br /></td></tr>
<tr class="separator:aea36490f8b993d04ddb1f987a30871f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d83c19b0057ef09102465d77c330394"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a5d83c19b0057ef09102465d77c330394">GridMap</a> (unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:a5d83c19b0057ef09102465d77c330394"><td class="mdescLeft">&#160;</td><td class="mdescRight">this makes a dumy <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> that has no lensing  <a href="struct_grid_map.html#a5d83c19b0057ef09102465d77c330394">More...</a><br /></td></tr>
<tr class="separator:a5d83c19b0057ef09102465d77c330394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da531bd017ca6424e6cb9147a3dcc04"><td class="memItemLeft" align="right" valign="top"><a id="a8da531bd017ca6424e6cb9147a3dcc04"></a>
<a class="el" href="struct_grid_map.html">GridMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a8da531bd017ca6424e6cb9147a3dcc04">ReInitialize</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:a8da531bd017ca6424e6cb9147a3dcc04"><td class="mdescLeft">&#160;</td><td class="mdescRight">reshoot the rays for example when the source plane has been changed <br /></td></tr>
<tr class="separator:a8da531bd017ca6424e6cb9147a3dcc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c2997166a4bb8f7c7d98024dbeeb5"><td class="memItemLeft" align="right" valign="top"><a id="af25c2997166a4bb8f7c7d98024dbeeb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#af25c2997166a4bb8f7c7d98024dbeeb5">deLens</a> ()</td></tr>
<tr class="memdesc:af25c2997166a4bb8f7c7d98024dbeeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets to state without lensing <br /></td></tr>
<tr class="separator:af25c2997166a4bb8f7c7d98024dbeeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e4242350b46cbd85b47818b8101f9e2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a3e4242350b46cbd85b47818b8101f9e2">RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:a3e4242350b46cbd85b47818b8101f9e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness at every point without changing the positions of the gridmap or any lens properties.  <a href="struct_grid_map.html#a3e4242350b46cbd85b47818b8101f9e2">More...</a><br /></td></tr>
<tr class="separator:a3e4242350b46cbd85b47818b8101f9e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5eec9bca70063492a4631ba5fd97e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a8f5eec9bca70063492a4631ba5fd97e1">AdaptiveRefreshSurfaceBrightnesses</a> (<a class="el" href="class_lens.html">Lens</a> &amp;lens, <a class="el" href="class_source.html">Source</a> &amp;source)</td></tr>
<tr class="separator:a8f5eec9bca70063492a4631ba5fd97e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab668b2cff39b656fcf3a4e2df290f638"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ab668b2cff39b656fcf3a4e2df290f638">AddSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:ab668b2cff39b656fcf3a4e2df290f638"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness just like GridMap::RefreshSurfaceBrightness but the new source is added to any sources that were already there.  <a href="struct_grid_map.html#ab668b2cff39b656fcf3a4e2df290f638">More...</a><br /></td></tr>
<tr class="separator:ab668b2cff39b656fcf3a4e2df290f638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a174f8acd229fda3efd6eb4548f05d"><td class="memItemLeft" align="right" valign="top"><a id="a10a174f8acd229fda3efd6eb4548f05d"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a10a174f8acd229fda3efd6eb4548f05d">image_point</a> (size_t index)</td></tr>
<tr class="memdesc:a10a174f8acd229fda3efd6eb4548f05d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the image point for a index number <br /></td></tr>
<tr class="separator:a10a174f8acd229fda3efd6eb4548f05d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687171a57a8d3c92d2c134f77d92cf9d"><td class="memItemLeft" align="right" valign="top"><a id="a687171a57a8d3c92d2c134f77d92cf9d"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a687171a57a8d3c92d2c134f77d92cf9d">source_point</a> (size_t index)</td></tr>
<tr class="memdesc:a687171a57a8d3c92d2c134f77d92cf9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the image point for a index number <br /></td></tr>
<tr class="separator:a687171a57a8d3c92d2c134f77d92cf9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55353b1d0ba3890de6f1c5456840bd8"><td class="memItemLeft" align="right" valign="top"><a id="af55353b1d0ba3890de6f1c5456840bd8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearSurfaceBrightnesses</b> ()</td></tr>
<tr class="separator:af55353b1d0ba3890de6f1c5456840bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e91d2f9c83439ed7be21d66337208ff"><td class="memItemLeft" align="right" valign="top"><a id="a6e91d2f9c83439ed7be21d66337208ff"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>assertNAN</b> ()</td></tr>
<tr class="separator:a6e91d2f9c83439ed7be21d66337208ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a5a2f995d57fcbcba8e74f96f6e5b6"><td class="memItemLeft" align="right" valign="top"><a id="a17a5a2f995d57fcbcba8e74f96f6e5b6"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>getNumberOfPoints</b> () const</td></tr>
<tr class="separator:a17a5a2f995d57fcbcba8e74f96f6e5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89ad1f7a1df130ad863f43dab4e270e"><td class="memItemLeft" align="right" valign="top"><a id="aa89ad1f7a1df130ad863f43dab4e270e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aa89ad1f7a1df130ad863f43dab4e270e">getInitNgrid</a> () const</td></tr>
<tr class="memdesc:aa89ad1f7a1df130ad863f43dab4e270e"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial number of grid points in each direction <br /></td></tr>
<tr class="separator:aa89ad1f7a1df130ad863f43dab4e270e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5681782fdc2dd28a69ef88491410641d"><td class="memItemLeft" align="right" valign="top"><a id="a5681782fdc2dd28a69ef88491410641d"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a5681782fdc2dd28a69ef88491410641d">getXRange</a> () const</td></tr>
<tr class="memdesc:a5681782fdc2dd28a69ef88491410641d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial range of gridded region. This is the distance from the first ray in a row to the last (unlike <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a>) <br /></td></tr>
<tr class="separator:a5681782fdc2dd28a69ef88491410641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ddc43bde8a603435c66f889780a0660"><td class="memItemLeft" align="right" valign="top"><a id="a2ddc43bde8a603435c66f889780a0660"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getYRange</b> () const</td></tr>
<tr class="separator:a2ddc43bde8a603435c66f889780a0660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d852eaacc34c77db0b04e70824c1e93"><td class="memItemLeft" align="right" valign="top"><a id="a8d852eaacc34c77db0b04e70824c1e93"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a8d852eaacc34c77db0b04e70824c1e93">getResolution</a> () const</td></tr>
<tr class="memdesc:a8d852eaacc34c77db0b04e70824c1e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">resolution in radians, this is range / (N-1) <br /></td></tr>
<tr class="separator:a8d852eaacc34c77db0b04e70824c1e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7ebe491daab61d9256b45036f9bc48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a5e7ebe491daab61d9256b45036f9bc48">writePixelMap</a> (<a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:a5e7ebe491daab61d9256b45036f9bc48"><td class="mdescLeft">&#160;</td><td class="mdescRight">make pixel map of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>  <a href="struct_grid_map.html#a5e7ebe491daab61d9256b45036f9bc48">More...</a><br /></td></tr>
<tr class="separator:a5e7ebe491daab61d9256b45036f9bc48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa524a3cd8243fee4e20e9c17353cd38a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aa524a3cd8243fee4e20e9c17353cd38a">writeFits</a> (<a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filensame)</td></tr>
<tr class="memdesc:aa524a3cd8243fee4e20e9c17353cd38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">fits output of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>  <a href="struct_grid_map.html#aa524a3cd8243fee4e20e9c17353cd38a">More...</a><br /></td></tr>
<tr class="separator:aa524a3cd8243fee4e20e9c17353cd38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea8dbd5fd0a8c672b33fbe6ff6787ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a4ea8dbd5fd0a8c672b33fbe6ff6787ad">writePixelMapUniform</a> (<a class="el" href="class_pixel_map.html">PixelMap</a> &amp;map, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="separator:a4ea8dbd5fd0a8c672b33fbe6ff6787ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d0b3520105f861334d0da8cd0cf60ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a1d0b3520105f861334d0da8cd0cf60ba">writeFitsUniform</a> (const PosType center[], size_t Nx, size_t Ny, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="separator:a1d0b3520105f861334d0da8cd0cf60ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed55e0cb0283537108615b228dbb057a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aed55e0cb0283537108615b228dbb057a">writePixelMapUniform</a> (const PosType center[], size_t Nx, size_t Ny, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:aed55e0cb0283537108615b228dbb057a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Pixel map of the without distribution the pixels.  <a href="struct_grid_map.html#aed55e0cb0283537108615b228dbb057a">More...</a><br /></td></tr>
<tr class="separator:aed55e0cb0283537108615b228dbb057a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a21ba3c14b21e7a7e83e80e0a8c3aa7ba">writeFitsUniform</a> (<a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">this will make a fits map of the grid as is.  <a href="struct_grid_map.html#a21ba3c14b21e7a7e83e80e0a8c3aa7ba">More...</a><br /></td></tr>
<tr class="separator:a21ba3c14b21e7a7e83e80e0a8c3aa7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a199c9dec53304a4995bd8abf5f4f66c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a199c9dec53304a4995bd8abf5f4f66c3">getPixelMapFlux</a> (int res) const</td></tr>
<tr class="memdesc:a199c9dec53304a4995bd8abf5f4f66c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution  <a href="struct_grid_map.html#a199c9dec53304a4995bd8abf5f4f66c3">More...</a><br /></td></tr>
<tr class="separator:a199c9dec53304a4995bd8abf5f4f66c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae305576b8720f0f99a60a4278223bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a3ae305576b8720f0f99a60a4278223bb">getPixelMapFlux</a> (<a class="el" href="class_pixel_map.html">PixelMap</a> &amp;map) const</td></tr>
<tr class="memdesc:a3ae305576b8720f0f99a60a4278223bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">surface brightness map  <a href="struct_grid_map.html#a3ae305576b8720f0f99a60a4278223bb">More...</a><br /></td></tr>
<tr class="separator:a3ae305576b8720f0f99a60a4278223bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408b0ac19bc5678ca316a582250f4946"><td class="memItemLeft" align="right" valign="top"><a id="a408b0ac19bc5678ca316a582250f4946"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a408b0ac19bc5678ca316a582250f4946">EinsteinArea</a> () const</td></tr>
<tr class="memdesc:a408b0ac19bc5678ca316a582250f4946"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the area (radians^2) of the region with negative magnification at resolution of fixed grid <br /></td></tr>
<tr class="separator:a408b0ac19bc5678ca316a582250f4946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0c0b5b5e8b6c352d1e9dc306d98aef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#adf0c0b5b5e8b6c352d1e9dc306d98aef">centroid</a> () const</td></tr>
<tr class="memdesc:adf0c0b5b5e8b6c352d1e9dc306d98aef"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns centroid of flux on the grid  <a href="struct_grid_map.html#adf0c0b5b5e8b6c352d1e9dc306d98aef">More...</a><br /></td></tr>
<tr class="separator:adf0c0b5b5e8b6c352d1e9dc306d98aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b368c185625e84e69cb65b2cc6f1f"><td class="memItemLeft" align="right" valign="top"><a id="ae31b368c185625e84e69cb65b2cc6f1f"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getCenter</b> ()</td></tr>
<tr class="separator:ae31b368c185625e84e69cb65b2cc6f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57584c918879952a0b9b327f399b8754"><td class="memItemLeft" align="right" valign="top"><a id="a57584c918879952a0b9b327f399b8754"></a>
<a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>operator[]</b> (size_t i)</td></tr>
<tr class="separator:a57584c918879952a0b9b327f399b8754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b0fe1404063813ddc428175219ca29"><td class="memItemLeft" align="right" valign="top"><a id="a73b0fe1404063813ddc428175219ca29"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GridMap</b> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a73b0fe1404063813ddc428175219ca29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae672d10969440ebde47ff3970bcbe1eb"><td class="memItemLeft" align="right" valign="top"><a id="ae672d10969440ebde47ff3970bcbe1eb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GridMap</b> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;grid)</td></tr>
<tr class="separator:ae672d10969440ebde47ff3970bcbe1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6b17cdeee551654f223a7f7fc0ac51"><td class="memItemLeft" align="right" valign="top"><a id="a5b6b17cdeee551654f223a7f7fc0ac51"></a>
<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_grid_map.html">GridMap</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a5b6b17cdeee551654f223a7f7fc0ac51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12dc2253337b4b9199b6f87e5cfb91b8"><td class="memItemLeft" align="right" valign="top"><a id="a12dc2253337b4b9199b6f87e5cfb91b8"></a>
std::list&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>find_images</b> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;ys, std::vector&lt; int &gt; &amp;multiplicity) const</td></tr>
<tr class="separator:a12dc2253337b4b9199b6f87e5cfb91b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fa0dd481c7351ede52fdb9dda6680c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a19fa0dd481c7351ede52fdb9dda6680c">find_images</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> y, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;image_points, std::vector&lt; Triangle &gt; &amp;triangles) const</td></tr>
<tr class="separator:a19fa0dd481c7351ede52fdb9dda6680c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fb480a29ae385b11bf2439a889e566"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ab9fb480a29ae385b11bf2439a889e566">find_boundaries_of_caustics</a> (std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt; &amp;boundaries, std::vector&lt; bool &gt; &amp;hits_edge)</td></tr>
<tr class="memdesc:ab9fb480a29ae385b11bf2439a889e566"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds the boundary of the region on the source plane where there are more than one image  <a href="struct_grid_map.html#ab9fb480a29ae385b11bf2439a889e566">More...</a><br /></td></tr>
<tr class="separator:ab9fb480a29ae385b11bf2439a889e566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa215b04101b745c282b570ebec20481e"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#aa215b04101b745c282b570ebec20481e">magnificationFlux</a> (<a class="el" href="class_source.html">Source</a> &amp;source) const</td></tr>
<tr class="separator:aa215b04101b745c282b570ebec20481e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92219554ba2b49860499f20435657618"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a92219554ba2b49860499f20435657618">magnificationTr</a> () const</td></tr>
<tr class="memdesc:a92219554ba2b49860499f20435657618"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the LOCAL magnification by triangel method weighted by interpolated surface brightness  <a href="struct_grid_map.html#a92219554ba2b49860499f20435657618">More...</a><br /></td></tr>
<tr class="separator:a92219554ba2b49860499f20435657618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cefd110769fcf5fa65e4900390fe4c"><td class="memItemLeft" align="right" valign="top"><a id="a55cefd110769fcf5fa65e4900390fe4c"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a55cefd110769fcf5fa65e4900390fe4c">magnificationTr</a> (std::vector&lt; size_t &gt; &amp;pixels) const</td></tr>
<tr class="memdesc:a55cefd110769fcf5fa65e4900390fe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code><a class="el" href="struct_grid_map.html#a92219554ba2b49860499f20435657618" title="calculate the LOCAL magnification by triangel method weighted by interpolated surface brightness">magnificationTr()</a></code> but for a limited number of cells. Problematic when cell is intersected by critical curve. <br /></td></tr>
<tr class="separator:a55cefd110769fcf5fa65e4900390fe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7913d977ddb27acd7d970703b891cbc"><td class="memItemLeft" align="right" valign="top"><a id="ac7913d977ddb27acd7d970703b891cbc"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ac7913d977ddb27acd7d970703b891cbc">AreaCellOnSourcePlane</a> (size_t k) const</td></tr>
<tr class="memdesc:ac7913d977ddb27acd7d970703b891cbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">area of a cell (pixel size region with its lower left at point k) on source plane - calculated by triangal method <br /></td></tr>
<tr class="separator:ac7913d977ddb27acd7d970703b891cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61527ab667bce3ed2171b6f6fb53fd05"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#a61527ab667bce3ed2171b6f6fb53fd05">AddPointSource</a> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;y, double flux)</td></tr>
<tr class="memdesc:a61527ab667bce3ed2171b6f6fb53fd05"><td class="mdescLeft">&#160;</td><td class="mdescRight">add flux to the rays that are nearest to the source on the source plane for each image  <a href="struct_grid_map.html#a61527ab667bce3ed2171b6f6fb53fd05">More...</a><br /></td></tr>
<tr class="separator:a61527ab667bce3ed2171b6f6fb53fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60c0740776b53b1b22457a7add0efc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html#ae60c0740776b53b1b22457a7add0efc3">find_crit</a> (std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt; &amp;points, std::vector&lt; bool &gt; &amp;hits_boundary, std::vector&lt; CritType &gt; &amp;crit_type)</td></tr>
<tr class="memdesc:ae60c0740776b53b1b22457a7add0efc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find critical curves. This is usually not used outside of <a class="el" href="namespace_image_finding.html#aeddf360f46ff1014096ff17d160d3d3d" title="Finds critical curves and caustics.">ImageFinding::find_crit()</a>  <a href="struct_grid_map.html#ae60c0740776b53b1b22457a7add0efc3">More...</a><br /></td></tr>
<tr class="separator:ae60c0740776b53b1b22457a7add0efc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7d1324f50cb98741de87cb67580ccac5"><td class="memItemLeft" align="right" valign="top"><a id="a7d1324f50cb98741de87cb67580ccac5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Lens</b></td></tr>
<tr class="separator:a7d1324f50cb98741de87cb67580ccac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A simplified version of the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> structure for making non-adaptive maps of the lensing quantities (kappa, gamma, etc...) </p>
<p>GripMap is faster and uses less memory than <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a>. It does not construct the tree structures for the points and thus cannot be used for adaptive mapping or image finding.</p>
<p>The distance between the left (lower) most and right (upper) most ray is range so the resolution is range/(N-1). The lower left pixel is at center[]-0.5*range and the upper right is at center[]+0.5*range </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aad8a0873c4dac82c434100643227d601"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8a0873c4dac82c434100643227d601">&#9670;&nbsp;</a></span>GridMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridMap::GridMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing square grid. </p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aea36490f8b993d04ddb1f987a30871f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea36490f8b993d04ddb1f987a30871f6">&#9670;&nbsp;</a></span>GridMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridMap::GridMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>my_center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing rectangular grid. </p>
<p>Cells of grid will always be square with initial resolution rangeX/(Nx-1). The Y range may not be exactly rangeY, but will be the nearest value that is a whole number of cells.</p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">Nx</td><td>Initial number of grid points in X dimension. </td></tr>
    <tr><td class="paramname">my_center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">rangeX</td><td>Full width of grid in x direction in whatever units will be used. </td></tr>
    <tr><td class="paramname">rangeY</td><td>Full width of grid in y direction in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d83c19b0057ef09102465d77c330394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d83c19b0057ef09102465d77c330394">&#9670;&nbsp;</a></span>GridMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GridMap::GridMap </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>this makes a dumy <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> that has no lensing </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8f5eec9bca70063492a4631ba5fd97e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5eec9bca70063492a4631ba5fd97e1">&#9670;&nbsp;</a></span>AdaptiveRefreshSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::AdaptiveRefreshSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">Lens</a> &amp;&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Oversample some pixels where the usrface brightness is not smooth and update surface brighnesses to be the average inside the pixel.</p>
<p>May be slow. </p>

</div>
</div>
<a id="a61527ab667bce3ed2171b6f6fb53fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61527ab667bce3ed2171b6f6fb53fd05">&#9670;&nbsp;</a></span>AddPointSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::AddPointSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>flux</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add flux to the rays that are nearest to the source on the source plane for each image </p>
<p>This uses GridMap::find_images to find the images. It then finds the point that is closest to the source position. The flux is added to one point per image. The total flux added is returned. No further refinement of the grid is done so it is limited by the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. Some spurious low magnification images can be found. </p>

</div>
</div>
<a id="ab668b2cff39b656fcf3a4e2df290f638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab668b2cff39b656fcf3a4e2df290f638">&#9670;&nbsp;</a></span>AddSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::AddSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">SourceHndl</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness just like GridMap::RefreshSurfaceBrightness but the new source is added to any sources that were already there. </p>
<p>returns total flux from the new source </p>

</div>
</div>
<a id="adf0c0b5b5e8b6c352d1e9dc306d98aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0c0b5b5e8b6c352d1e9dc306d98aef">&#9670;&nbsp;</a></span>centroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point__2d.html">Point_2d</a> GridMap::centroid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns centroid of flux on the grid </p>
<p>flux weighted local magnification with current surface brightness averaged on the image plane, </p>

</div>
</div>
<a id="ab9fb480a29ae385b11bf2439a889e566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fb480a29ae385b11bf2439a889e566">&#9670;&nbsp;</a></span>find_boundaries_of_caustics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::find_boundaries_of_caustics </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>finds the boundary of the region on the source plane where there are more than one image </p>
<p>Warning : slow but perhaps reliable than find_caustics() when no radial caustic is found.</p>
<p>This uses the triangle method to determin which points in a source plane grid of the same size and resolution as the image plane grid have multiple images. This boundary will surround all caustics unlike for <a class="el" href="struct_grid_map.html#ae60c0740776b53b1b22457a7add0efc3" title="Find critical curves. This is usually not used outside of ImageFinding::find_crit()">GridMap::find_crit</a>.</p>
<p>This should not be as susceptible to missing the radial caustic because of resolution in the image plane. </p>

</div>
</div>
<a id="ae60c0740776b53b1b22457a7add0efc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60c0740776b53b1b22457a7add0efc3">&#9670;&nbsp;</a></span>find_crit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::find_crit </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>hits_boundary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CritType &gt; &amp;&#160;</td>
          <td class="paramname"><em>crit_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find critical curves. This is usually not used outside of <a class="el" href="namespace_image_finding.html#aeddf360f46ff1014096ff17d160d3d3d" title="Finds critical curves and caustics.">ImageFinding::find_crit()</a> </p>
<p>This will find all the resolved tangential and radial critical curves. If a radial critical curve is not found within a tangential one, curves around the maxima are used to estimate a radial or pseudo caustic. These are labeled CritType::pseudo. The out put is ordered so that the radia/pseudo curves within a tangent curve imediately follow it. </p>

</div>
</div>
<a id="a19fa0dd481c7351ede52fdb9dda6680c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fa0dd481c7351ede52fdb9dda6680c">&#9670;&nbsp;</a></span>find_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::find_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>image_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; Triangle &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>find all images by triangle method </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image_points</td><td>positions of the images limited by resolution of the gridmap </td></tr>
    <tr><td class="paramname">triangles</td><td>index's of the points that form the triangles that the images are in </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a199c9dec53304a4995bd8abf5f4f66c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199c9dec53304a4995bd8abf5f4f66c3">&#9670;&nbsp;</a></span>getPixelMapFlux() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::getPixelMapFlux </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>res</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution </p>
<p>Output a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the surface brightness with same res as the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a>. </p>

</div>
</div>
<a id="a3ae305576b8720f0f99a60a4278223bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae305576b8720f0f99a60a4278223bb">&#9670;&nbsp;</a></span>getPixelMapFlux() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::getPixelMapFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>surface brightness map </p>
<p>update a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> with the flux in pixels at a resolution of res times the original resolution. The map must have precisely the right size and center to match or an exception will be thrown. Constructing the map with <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> getPixelMapFlux(int res) will insure that it does. </p>

</div>
</div>
<a id="aa215b04101b745c282b570ebec20481e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa215b04101b745c282b570ebec20481e">&#9670;&nbsp;</a></span>magnificationFlux()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType GridMap::magnificationFlux </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the magnification of one source by adding up its flux for the lensed image and an image made on an unlensed regulare grid </p>

</div>
</div>
<a id="a92219554ba2b49860499f20435657618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92219554ba2b49860499f20435657618">&#9670;&nbsp;</a></span>magnificationTr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::magnificationTr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the LOCAL magnification by triangel method weighted by interpolated surface brightness </p>
<p>This is done by finding the area of every half cell triangle on the source plane and multiplying by the surface bightness interpolated to the center of the triangle on the image plane. This does not use the point-wise magnification calculated by the rayshooter beacuse this can be highly unstable.</p>
<p>NOTE: This will not equal the ratio of the lensed flux to the unlensed flux except in the case of one image (assuming the source is well resolved). </p>

</div>
</div>
<a id="a3e4242350b46cbd85b47818b8101f9e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4242350b46cbd85b47818b8101f9e2">&#9670;&nbsp;</a></span>RefreshSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double GridMap::RefreshSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">SourceHndl</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness at every point without changing the positions of the gridmap or any lens properties. </p>
<p>Recalculate the surface brightness at all points on the gridmap. This is useful when changing the source model while preserving changes in the grid. Both i_tree and s_tree are both changed although only s_tree shows up here.</p>
<p>returns the sum of the surface brightnesses </p>

</div>
</div>
<a id="aa524a3cd8243fee4e20e9c17353cd38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa524a3cd8243fee4e20e9c17353cd38a">&#9670;&nbsp;</a></span>writeFits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writeFits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>fits output of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>output files </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d0b3520105f861334d0da8cd0cf60ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0b3520105f861334d0da8cd0cf60ba">&#9670;&nbsp;</a></span>writeFitsUniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image -- .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21ba3c14b21e7a7e83e80e0a8c3aa7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ba3c14b21e7a7e83e80e0a8c3aa7ba">&#9670;&nbsp;</a></span>writeFitsUniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>this will make a fits map of the grid as is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>quantity to be output </td></tr>
    <tr><td class="paramname">filename</td><td>name of output fits file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e7ebe491daab61d9256b45036f9bc48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7ebe491daab61d9256b45036f9bc48">&#9670;&nbsp;</a></span>writePixelMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::writePixelMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make pixel map of lensing quantities at the resolution of the <a class="el" href="struct_grid_map.html" title="A simplified version of the Grid structure for making non-adaptive maps of the lensing quantities (ka...">GridMap</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed55e0cb0283537108615b228dbb057a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed55e0cb0283537108615b228dbb057a">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> GridMap::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Pixel map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ea8dbd5fd0a8c672b33fbe6ff6787ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea8dbd5fd0a8c672b33fbe6ff6787ad">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GridMap::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a>&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="gridmap_8h_source.html">gridmap.h</a></li>
<li>SLsimLib/TreeCode_link/gridmap.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sat Mar 16 2024 11:03:35 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
