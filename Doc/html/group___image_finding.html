<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Image Finding</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Image Finding<div class="ingroups"><a class="el" href="group___high_level.html">High Level Routines</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Routines for finding and characterizing images.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Image Finding:</div>
<div class="dyncontent">
<center><table><tr><td><img src="group___image_finding.png" border="0" alt="" usemap="#group______image__finding"/>
<map name="group______image__finding" id="group______image__finding">
<area shape="rect"  href="group___high_level.html" title="These are routines that can be used without having to muck around in the internals. " alt="" coords="6,5,146,33"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html">Grid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to contain both source and image trees. It is not yet used, but may be useful.  <a href="struct_grid.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid_map.html">GridMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplified version of the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a> structure for making non-adaptive maps of the lensing quantities (kappa, gamma, etc...)  <a href="struct_grid_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga35b9df4dfdcc34aee973719535ec8778"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga35b9df4dfdcc34aee973719535ec8778">ImageFinding::find_peaks</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, PosType rEinsteinMin, PosType kappa_max, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, int *Nimages)</td></tr>
<tr class="memdesc:ga35b9df4dfdcc34aee973719535ec8778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the grid based on the convergence so that high density regions have high resolution.  <a href="group___image_finding.html#ga35b9df4dfdcc34aee973719535ec8778">More...</a><br /></td></tr>
<tr class="separator:ga35b9df4dfdcc34aee973719535ec8778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeddf360f46ff1014096ff17d160d3d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaeddf360f46ff1014096ff17d160d3d3d">ImageFinding::find_crit</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, std::vector&lt; CriticalCurve &gt; &amp;crtcurve, int *Ncrits, double resolution, double invmag_min=0.0, bool verbose=false, bool test=false)</td></tr>
<tr class="memdesc:gaeddf360f46ff1014096ff17d160d3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds critical curves and caustics.  <a href="group___image_finding.html#gaeddf360f46ff1014096ff17d160d3d3d">More...</a><br /></td></tr>
<tr class="separator:gaeddf360f46ff1014096ff17d160d3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada031993e8ed6cfead17ecc83951a197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gada031993e8ed6cfead17ecc83951a197">ImageFinding::find_contour</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, std::vector&lt; CriticalCurve &gt; &amp;contour, int *Ncrits, PosType resolution, bool *orderingsuccess, bool ordercurve, bool dividecurves, double contour_value, LensingVariable contour_type, bool verbose=false)</td></tr>
<tr class="memdesc:gada031993e8ed6cfead17ecc83951a197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds iso kappa contours.  <a href="group___image_finding.html#gada031993e8ed6cfead17ecc83951a197">More...</a><br /></td></tr>
<tr class="separator:gada031993e8ed6cfead17ecc83951a197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24da72593941193758c4a98ee860b19"><td class="memItemLeft" align="right" valign="top"><a id="gaa24da72593941193758c4a98ee860b19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaa24da72593941193758c4a98ee860b19">Grid::ReInitializeGrid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:gaa24da72593941193758c4a98ee860b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the grid so that it is back to the original coarse grid, but if the lens has changed the source positions will be updated. <br /></td></tr>
<tr class="separator:gaa24da72593941193758c4a98ee860b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0893daf7e7db43564182f7847e8ee73e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga0893daf7e7db43564182f7847e8ee73e">Grid::ReShoot</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:ga0893daf7e7db43564182f7847e8ee73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshoot the rays with the same image postions.  <a href="#ga0893daf7e7db43564182f7847e8ee73e">More...</a><br /></td></tr>
<tr class="separator:ga0893daf7e7db43564182f7847e8ee73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaae2b3f9fe8cc6a464852e3441f22d8a9">Grid::RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness at every point without changing the positions of the grid or any lens properties.  <a href="#gaae2b3f9fe8cc6a464852e3441f22d8a9">More...</a><br /></td></tr>
<tr class="separator:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memItemLeft" align="right" valign="top"><a id="ga4b84bc9acf6cbeff3a6da1f3dca202e1"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga4b84bc9acf6cbeff3a6da1f3dca202e1">Grid::getNumberOfPoints</a> () const</td></tr>
<tr class="memdesc:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of points on image plane. <br /></td></tr>
<tr class="separator:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga84da40a884b9a6fd16038de225b51dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga84da40a884b9a6fd16038de225b51dc7">ImageFinding::find_images_kist</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, PosType *y_source, PosType r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, PosType initial_size, bool splitimages, short edge_refinement, bool verbose=false)</td></tr>
<tr class="memdesc:ga84da40a884b9a6fd16038de225b51dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images given a source position and size.  <a href="group___image_finding.html#ga84da40a884b9a6fd16038de225b51dc7">More...</a><br /></td></tr>
<tr class="separator:ga84da40a884b9a6fd16038de225b51dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4df229d3fd4cccd2a4ae17fa7edfa258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga4df229d3fd4cccd2a4ae17fa7edfa258">ImageFinding::find_images_microlens</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, double *y_source, double r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, double initial_size, double mu_min, bool splitimages, short edge_refinement, bool verbose)</td></tr>
<tr class="memdesc:ga4df229d3fd4cccd2a4ae17fa7edfa258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images given a source position and size.  <a href="group___image_finding.html#ga4df229d3fd4cccd2a4ae17fa7edfa258">More...</a><br /></td></tr>
<tr class="separator:ga4df229d3fd4cccd2a4ae17fa7edfa258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abeafd5d8401246c3a4ed2dc79989c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga2abeafd5d8401246c3a4ed2dc79989c3">ImageFinding::map_images</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double xmax, double xmin, double initial_size, ExitCriterion criterion, bool FindCenter, bool divide_images)</td></tr>
<tr class="memdesc:ga2abeafd5d8401246c3a4ed2dc79989c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find images and refine them based on their surface brightness distribution.  <a href="group___image_finding.html#ga2abeafd5d8401246c3a4ed2dc79989c3">More...</a><br /></td></tr>
<tr class="separator:ga2abeafd5d8401246c3a4ed2dc79989c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7596607b563fc41789b2db5a2277a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaa7596607b563fc41789b2db5a2277a2c">ImageFinding::map_images_fixedgrid</a> (<a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double xmax, bool divide_images, bool find_borders)</td></tr>
<tr class="memdesc:gaa7596607b563fc41789b2db5a2277a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the images without any additional grid refinement or ray shooting.  <a href="group___image_finding.html#gaa7596607b563fc41789b2db5a2277a2c">More...</a><br /></td></tr>
<tr class="separator:gaa7596607b563fc41789b2db5a2277a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70bbca22cc631872b33de04441c20b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga70bbca22cc631872b33de04441c20b99">ImageFinding::map_imagesISOP</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double rmax, double res_min, double initial_size, ExitCriterion criterion, bool divide_images, bool int_on=true, bool verbos=false)</td></tr>
<tr class="memdesc:ga70bbca22cc631872b33de04441c20b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find images and refine them based on their surface brightness distribution.  <a href="group___image_finding.html#ga70bbca22cc631872b33de04441c20b99">More...</a><br /></td></tr>
<tr class="separator:ga70bbca22cc631872b33de04441c20b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11e8ae40a50d5f47f75920509466767"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gae11e8ae40a50d5f47f75920509466767">Grid::PruneTrees</a> (double resolution, bool useSB, double fluxlimit)</td></tr>
<tr class="memdesc:gae11e8ae40a50d5f47f75920509466767"><td class="mdescLeft">&#160;</td><td class="mdescRight">THIS DOES NOT WORK YET!!!  <a href="#gae11e8ae40a50d5f47f75920509466767">More...</a><br /></td></tr>
<tr class="separator:gae11e8ae40a50d5f47f75920509466767"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Routines for finding and characterizing images. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gada031993e8ed6cfead17ecc83951a197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada031993e8ed6cfead17ecc83951a197">&#9670;&nbsp;</a></span>find_contour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_contour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>crtcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Ncrits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>orderingsuccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordercurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dividecurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>contour_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>contour_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds iso kappa contours. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>The lens model. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid. It must be initialized. </td></tr>
    <tr><td class="paramname">crtcurve</td><td>Structure to hold critical curve. Must be pre-allocated with maxNcrit elements. Stored in critcurve[i].imagekist. </td></tr>
    <tr><td class="paramname">Ncrits</td><td>The number of critical curves found. </td></tr>
    <tr><td class="paramname">resolution</td><td>The target resolution that the critical curve is mapped on the image plane. </td></tr>
    <tr><td class="paramname">orderingsuccess</td><td>true if ordering was successful. </td></tr>
    <tr><td class="paramname">ordercurve</td><td>Order the curve so that it can be drawn or used to find the winding number. </td></tr>
    <tr><td class="paramname">dividecurves</td><td>Divide the critical curves into seporate curves by whether they are attached </td></tr>
    <tr><td class="paramname">contour_value</td><td>value at which the contour is wanted </td></tr>
    <tr><td class="paramname">contour_type</td><td>KAPPA, INVMAG or DT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeddf360f46ff1014096ff17d160d3d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeddf360f46ff1014096ff17d160d3d3d">&#9670;&nbsp;</a></span>find_crit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_crit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>crtcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Ncrits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>invmag_min</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TEST</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds critical curves and caustics. </p>
<p>The critical curve is found by refining the edges of regions of negative magnification. If there are no regions of negative magnification in the original grid the grid is refined around the point of highest kappa. If there are other points of high kappa that are not of interest one should be careful that the region of interest is not missed. For this reason critical curves that are smaller than the grid resolution (could be un-uniform) are not guaranteed to be found.</p>
<p>After the borders of the negative regions are found the code looks for radial and pseudo caustics within the island. It usually finds at least one, but if there are more than one per island some might be missed.</p>
<p>All the critical curve / caustic pairs are classified as radial, tangential or pseudo. small enough radial critical curve could be miss classified as a pseudo caustic. </p>
<p>Structure to hold critical curve. Must be pre-</p>
<p>make some figures</p>
<p>make some figures</p>
<p>make some figures</p>
<p>make some figures </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>The lens model. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid. It must be initialized. </td></tr>
    <tr><td class="paramname">crtcurve</td><td>Structure to hold critical curve. </td></tr>
    <tr><td class="paramname">Ncrits</td><td>The number of critical curves found. </td></tr>
    <tr><td class="paramname">resolution</td><td>The target resolution that the critical curve is mapped on the image plane. </td></tr>
    <tr><td class="paramname">invmag_min</td><td>finds regions with 1/magnification &lt; invmag_min, set to zero for caustics </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga84da40a884b9a6fd16038de225b51dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga84da40a884b9a6fd16038de225b51dc7">&#9670;&nbsp;</a></span>find_images_kist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_images_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>edge_refinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images given a source position and size. </p>
<p>find_images_kist returns finite refined images in images[0...*Nimages-1].imagekist It starts with a large source and reduces down to the right size refining at each step. It should not miss any image larger than ~ munin*r_source linear size, but seems to do much better than that. It does nothing with the surface brightnesses.</p>
<p>The routine can follow three different strategies for refining each image controlled by edge_refinement.</p>
<p>edge_refinement</p><ul>
<li>0 does not do edge refinement, Every pixel in every image is refined until the criterion is met. The image(s) are found again after each refinement which can make it slower.</li>
<li>1 uses refine_edge(). After an initial refinement of all the pixels in the image(s) the code switches to refining only the edges of the images. The images are found after each refinement.</li>
<li>2 uses refine_edge2() Same as 1, but the images are not found after each refinement. This can make the</li>
<li>any other number does no additional refinement after telescoping routine run much faster, but has the disadvantage that the number of images will not change during the final stage of refinement. This is the setting generally recommended. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>contains the lens/es and source/sources position of source center </td></tr>
    <tr><td class="paramname">r_source</td><td>radius of source </td></tr>
    <tr><td class="paramname">grid</td><td>grid provided to routine </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">Nimagepoints</td><td>number of points in final images </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. </td></tr>
    <tr><td class="paramname">splitimages</td><td>true each image is refined to target accuracy, otherwise all images are treated as one </td></tr>
    <tr><td class="paramname">edge_refinement</td><td>see comment </td></tr>
    <tr><td class="paramname">verbose</td><td>verbose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4df229d3fd4cccd2a4ae17fa7edfa258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4df229d3fd4cccd2a4ae17fa7edfa258">&#9670;&nbsp;</a></span>find_images_microlens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_images_microlens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>edge_refinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images given a source position and size. </p>
<p><a class="el" href="group___image_finding.html#ga84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist</a> returns finite refined images in images[0...*Nimages-1].imagekist It starts with a large source and reduces down to the right size refining at each step. It should not miss any image larger than ~ munin*r_source linear size, but seems to do much better than that. It does nothing with the surface brightnesses.</p>
<p>The routine can follow three different strategies for refining each image controlled by edge_refinement.</p>
<p>edge_refinement</p><ul>
<li>0 does not do edge refinement, Every pixel in every image is refined until the criterion is met. The image(s) are found again after each refinement which can make it slower.</li>
<li>1 uses refine_edge(). After an initial refinement of all the pixels in the image(s) the code switches to refining only the edges of the images. The images are found after each refinement.</li>
<li>2 uses refine_edge2() Same as 1, but the images are not found after each refinement. This can make the routine run much faster, but has the disadvantage that the number of images will not change during the final stage of refinement. This is the setting generally recommended.</li>
</ul>
<p>When finding a finite sized source these quantities are generally not required and slow down the routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>contains the lens/es and source/sources position of source center </td></tr>
    <tr><td class="paramname">r_source</td><td>radius of source </td></tr>
    <tr><td class="paramname">grid</td><td>grid provided to routine </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">Nimagepoints</td><td>number of points in final images </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. </td></tr>
    <tr><td class="paramname">splitimages</td><td>true each image is refined to target accuracy, otherwise all images are treated as one </td></tr>
    <tr><td class="paramname">edge_refinement</td><td>see comment </td></tr>
    <tr><td class="paramname">verbose</td><td>verbose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga35b9df4dfdcc34aee973719535ec8778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35b9df4dfdcc34aee973719535ec8778">&#9670;&nbsp;</a></span>find_peaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ImageFinding::find_peaks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rEinsteinMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>kappa_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the grid based on the convergence so that high density regions have high resolution. </p>
<p>No source is used in this process. The code acts as if all the mass is in SIS halos iteratively increasing the resolution and kappa threshhold until the desired resolution is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td><a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> model </td></tr>
    <tr><td class="paramname">grid</td><td><a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a> to be refined. It must be initialized. </td></tr>
    <tr><td class="paramname">rEinsteinMin</td><td>the Einstein radius of the smallest lens that should be resolved, sets resolution target </td></tr>
    <tr><td class="paramname">kappa_max</td><td>highest kappa to be refined to, 1 or 2 is probably good enough </td></tr>
    <tr><td class="paramname">imageinfo</td><td>the image </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of peaks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2abeafd5d8401246c3a4ed2dc79989c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2abeafd5d8401246c3a4ed2dc79989c3">&#9670;&nbsp;</a></span>map_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExitCriterion&#160;</td>
          <td class="paramname"><em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>FindCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find images and refine them based on their surface brightness distribution. </p>
<p>Uses <a class="el" href="group___image_finding.html#ga84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist()</a> to initially find and refine images and then uses a surface brightness based criterion to refine the most important parts of the lens.</p>
<p>map_images is intended for mapping images of sources more complicated than simple circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>model </td></tr>
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">xmax</td><td>Maximum size of source on image plane. The entire source must be within this distance from source-&gt;getTheta()[] </td></tr>
    <tr><td class="paramname">xmin</td><td>The smallest scale of the source measured on the lens plane. The more accurate these 2 parameters are the less likely it is that an image will be missed. </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. If &lt; 0 no telescoping is used and only the already existing points are used to to initiate the image finding. </td></tr>
    <tr><td class="paramname">criterion</td><td>see data type </td></tr>
    <tr><td class="paramname">FindCenter</td><td>if the center of the source is not known this can be set to true and it will attempt to find the center, find the size of the source and determine if there is more than one source The entire source must be within xmax of source-&gt;getTheta() because this is the only region that will be scanned. </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images and apply the exit criterion to them separately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa7596607b563fc41789b2db5a2277a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7596607b563fc41789b2db5a2277a2c">&#9670;&nbsp;</a></span>map_images_fixedgrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_images_fixedgrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>find_borders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the images without any additional grid refinement or ray shooting. </p>
<p>The images and surface brighnesses are found. This will be much faster than <a class="el" href="group___image_finding.html#ga2abeafd5d8401246c3a4ed2dc79989c3" title="Find images and refine them based on their surface brightness distribution.">map_images()</a>, but will miss images that are not resolved on the current grid.</p>
<p>The surface brightnesses on all of the grid are refreshed. The images centroids and gridranges are maintained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">xmax</td><td>Maximum size of source on image plane. The entire source must be within this distance from source-&gt;getTheta()[]. Decreasing it will make the code run faster. Making xmax much bigger than the grid boundaries will check all points for surface brightness. </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images. </td></tr>
    <tr><td class="paramname">find_borders</td><td>if true will find the inner and outer borders of each image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga70bbca22cc631872b33de04441c20b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70bbca22cc631872b33de04441c20b99">&#9670;&nbsp;</a></span>map_imagesISOP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_imagesISOP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExitCriterion&#160;</td>
          <td class="paramname"><em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>int_on</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find images and refine them based on their surface brightness distribution. </p>
<p>Uses <a class="el" href="group___image_finding.html#ga84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist()</a> to initially find and refine images and then using IF_routines::IntegrateFluxInCell(). If cells cannot be integrated refiments are madebased on a surface brightness based criterion to refine the most important parts of the lens.</p>
<p>map_images is intended for mapping images of sources more complicated than simple circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>model </td></tr>
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">rmax</td><td>Maximum size of source on souce plane. The entire source must be within this distance from source-&gt;getTheta()[] </td></tr>
    <tr><td class="paramname">res_min</td><td>requred resolution of image, typically the pixel size of the final image </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. If &lt; 0 no telescoping is used and only the already existing points are used to to initiate the image finding. </td></tr>
    <tr><td class="paramname">criterion</td><td>see data type </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images and apply the exit criterion to them separately. </td></tr>
    <tr><td class="paramname">int_on</td><td>if true the flux in each cell is integrated, if false the surface brightness at the center point of the cell is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae11e8ae40a50d5f47f75920509466767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae11e8ae40a50d5f47f75920509466767">&#9670;&nbsp;</a></span>PruneTrees()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Grid::PruneTrees </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useSB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>fluxlimit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>THIS DOES NOT WORK YET!!! </p>
<p>Reduces the size of the tree by removing points and branches that are no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resolution</td><td>Maximum size of a cell to be removed. </td></tr>
    <tr><td class="paramname">useSB</td><td>If true it will not remove any point that has a flux above fluxlimit. </td></tr>
    <tr><td class="paramname">fluxlimit</td><td>flux limit threshold </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaae2b3f9fe8cc6a464852e3441f22d8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae2b3f9fe8cc6a464852e3441f22d8a9">&#9670;&nbsp;</a></span>RefreshSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Grid::RefreshSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">SourceHndl</a>&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness at every point without changing the positions of the grid or any lens properties. </p>
<p>Recalculate the surface brightness at all points on the grid. This is useful when changing the source model while preserving changes in the grid. Both i_tree and s_tree are both changed although only s_tree shows up here.</p>
<p>returns the sum of the surface brightnesses </p>

</div>
</div>
<a id="ga0893daf7e7db43564182f7847e8ee73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0893daf7e7db43564182f7847e8ee73e">&#9670;&nbsp;</a></span>ReShoot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::ReShoot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshoot the rays with the same image postions. </p>
<p>The source positions and source tree are updated to the current lens model. The advantage over <a class="el" href="group___image_finding.html#gaa24da72593941193758c4a98ee860b19" title="Reinitializes the grid so that it is back to the original coarse grid, but if the lens has changed th...">Grid::ReInitializeGrid()</a> is that the image plane refinements are preserved. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 26 2019 08:44:29 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
