<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Utilities Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><ul>
<li></li>
</ul>
 
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities_1_1_geometry.html">Geometry</a></td></tr>
<tr class="memdesc:namespace_utilities_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for geometrical functions mostly having to do with spherical coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities_1_1_i_o.html">IO</a></td></tr>
<tr class="memdesc:namespace_utilities_1_1_i_o"><td class="mdescLeft">&#160;</td><td class="mdescRight">namespace for input/output utilities <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d2_matrix.html">D2Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 dimensional matrix  <a href="class_utilities_1_1_d2_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d3_matrix.html">D3Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 dimensional matrix, fixed size  <a href="class_utilities_1_1_d3_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_data_frame.html">DataFrame</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for impoting data from a csv file and allowing label string lookup like a data frame.  <a href="class_utilities_1_1_data_frame.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_hilbert_curve.html">HilbertCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for calculating the Hilbert curve distance in two dimensions.  <a href="class_utilities_1_1_hilbert_curve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_interpolator.html">Interpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear interpolation class for interpolating from a 2D uniform grid.  <a href="class_utilities_1_1_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector.html">MixedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that can hold mixed objects all derived from a base class and retains the ability to access derived class functions/members.  <a href="class_utilities_1_1_mixed_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html">MixedVector&lt; BaseT * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_utilities_1_1_mixed_vector.html" title="A container that can hold mixed objects all derived from a base class and retains the ability to acce...">MixedVector</a> for pointers.  <a href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_random_numbers___n_r.html">RandomNumbers_NR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class for generating random numbers. It simplifies and fool proofs initialization and allows for multiple independent series of numbers.  <a href="class_utilities_1_1_random_numbers___n_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_shuffled_index.html">ShuffledIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a randomized sequence of numbers from 0 to N-1.  <a href="class_utilities_1_1_shuffled_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_s_u_m_m_e_r.html">SUMMER</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class for adding large amounts of numbers with less error than the simple sum  <a href="class_utilities_1_1_s_u_m_m_e_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_symmetric_matrix.html">SymmetricMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Symetric matrix.  <a href="class_utilities_1_1_symmetric_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83d3f6d35f48dd5cf7ff992a6c36ee8a" id="r_a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memItemLeft" align="right" valign="top"><a id="a83d3f6d35f48dd5cf7ff992a6c36ee8a" name="a83d3f6d35f48dd5cf7ff992a6c36ee8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_date</b> ()</td></tr>
<tr class="separator:a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f0a954728d751781e61918facba0e" id="r_a380f0a954728d751781e61918facba0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a380f0a954728d751781e61918facba0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a380f0a954728d751781e61918facba0e">fill_linear</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:a380f0a954728d751781e61918facba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aedfd83edf6f6637cc03da5413e94a" id="r_a47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a47aedfd83edf6f6637cc03da5413e94a">fill_logarithmic</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:a47aedfd83edf6f6637cc03da5413e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929db80c547c245b0d2c2703f33ff85e" id="r_a929db80c547c245b0d2c2703f33ff85e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a929db80c547c245b0d2c2703f33ff85e"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a929db80c547c245b0d2c2703f33ff85e">locate</a> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="separator:a929db80c547c245b0d2c2703f33ff85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7663a1f094849a77cab564e61fcca49" id="r_ab7663a1f094849a77cab564e61fcca49"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:ab7663a1f094849a77cab564e61fcca49"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab7663a1f094849a77cab564e61fcca49">locate</a> (const std::vector&lt; T &gt; &amp;v, F x, std::function&lt; bool(F, const T &amp;)&gt; less_than)</td></tr>
<tr class="separator:ab7663a1f094849a77cab564e61fcca49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66" id="r_a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplParams" colspan="2"><a id="a0cfb54fff515cfd5d684572962f50c66" name="a0cfb54fff515cfd5d684572962f50c66"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>locate</b> (T *v, unsigned long n, T x, unsigned long *index)</td></tr>
<tr class="separator:a0cfb54fff515cfd5d684572962f50c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc053736fab41bd2807991e8dfcab129" id="r_acc053736fab41bd2807991e8dfcab129"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc053736fab41bd2807991e8dfcab129"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc053736fab41bd2807991e8dfcab129">locate</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; size_t &gt; &amp;sorted_index, T value, size_t &amp;rank)</td></tr>
<tr class="memdesc:acc053736fab41bd2807991e8dfcab129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the element of a vector given a sorted index of the vector.  <br /></td></tr>
<tr class="separator:acc053736fab41bd2807991e8dfcab129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799" id="r_aa80185750e610681c64de174516f9799"><td class="memTemplParams" colspan="2"><a id="aa80185750e610681c64de174516f9799" name="aa80185750e610681c64de174516f9799"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>closest</b> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="memdesc:aa80185750e610681c64de174516f9799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element of v that is closest to x. v must be sorted. <br /></td></tr>
<tr class="separator:aa80185750e610681c64de174516f9799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6f9e86e55bf8ac250ed8a2849ba3e" id="r_af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5c6f9e86e55bf8ac250ed8a2849ba3e">InterpolateYvec</a> (std::vector&lt; PosType &gt; &amp;x, std::vector&lt; PosType &gt; &amp;y, PosType xi)</td></tr>
<tr class="separator:af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c02a235f698cf25dbc7edf34d4bf8f" id="r_a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memItemLeft" align="right" valign="top"><a id="a49c02a235f698cf25dbc7edf34d4bf8f" name="a49c02a235f698cf25dbc7edf34d4bf8f"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>arctanh</b> (PosType x)</td></tr>
<tr class="separator:a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473f872514990ed70931ddd9489301a7" id="r_a473f872514990ed70931ddd9489301a7"><td class="memItemLeft" align="right" valign="top"><a id="a473f872514990ed70931ddd9489301a7" name="a473f872514990ed70931ddd9489301a7"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmini</b> (PosType a, PosType b)</td></tr>
<tr class="separator:a473f872514990ed70931ddd9489301a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99adc537b02f26073243f0d32376def" id="r_af99adc537b02f26073243f0d32376def"><td class="memItemLeft" align="right" valign="top"><a id="af99adc537b02f26073243f0d32376def" name="af99adc537b02f26073243f0d32376def"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmaxi</b> (PosType a, PosType b)</td></tr>
<tr class="separator:af99adc537b02f26073243f0d32376def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec52aba262343bc391860a37da4d472" id="r_a1ec52aba262343bc391860a37da4d472"><td class="memTemplParams" colspan="2"><a id="a1ec52aba262343bc391860a37da4d472" name="a1ec52aba262343bc391860a37da4d472"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1ec52aba262343bc391860a37da4d472"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>median</b> (std::vector&lt; T &gt; vec)</td></tr>
<tr class="memdesc:a1ec52aba262343bc391860a37da4d472"><td class="mdescLeft">&#160;</td><td class="mdescRight">find median of vector <br /></td></tr>
<tr class="separator:a1ec52aba262343bc391860a37da4d472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60664d77331b21da7b83e6e0cc0c75c" id="r_ae60664d77331b21da7b83e6e0cc0c75c"><td class="memTemplParams" colspan="2"><a id="ae60664d77331b21da7b83e6e0cc0c75c" name="ae60664d77331b21da7b83e6e0cc0c75c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae60664d77331b21da7b83e6e0cc0c75c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range</b> (std::vector&lt; T &gt; vec, T &amp;max, T &amp;min)</td></tr>
<tr class="memdesc:ae60664d77331b21da7b83e6e0cc0c75c"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the maximum and minimum of a vector <br /></td></tr>
<tr class="separator:ae60664d77331b21da7b83e6e0cc0c75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d" id="r_a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplParams" colspan="2"><a id="a85e6e176b88221d17c1a0d6c83a6846d" name="a85e6e176b88221d17c1a0d6c83a6846d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>polintT</b> (T xa[], T ya[], int n, T x, T *y, T *dy)</td></tr>
<tr class="memdesc:a85e6e176b88221d17c1a0d6c83a6846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolation <br /></td></tr>
<tr class="separator:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d" id="r_a7679e167450f3450c86c345cd8de373d"><td class="memTemplParams" colspan="2"><a id="a7679e167450f3450c86c345cd8de373d" name="a7679e167450f3450c86c345cd8de373d"></a>
template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>trapz</b> (FunctorType &amp;func, T a, T b, int n, T *s2)</td></tr>
<tr class="memdesc:a7679e167450f3450c86c345cd8de373d"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in trapizoidal integral <br /></td></tr>
<tr class="separator:a7679e167450f3450c86c345cd8de373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98" id="r_afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplParams" colspan="2">template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb7f32cbe2c0f17c06a106dee6726e98">nintegrateF</a> (FunctorType func, T a, T b, T tols)</td></tr>
<tr class="separator:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82fcbd40d2ef2b1d3091916c96afff26" id="r_a82fcbd40d2ef2b1d3091916c96afff26"><td class="memItemLeft" align="right" valign="top"><a id="a82fcbd40d2ef2b1d3091916c96afff26" name="a82fcbd40d2ef2b1d3091916c96afff26"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>lmin</b> (long a, long b)</td></tr>
<tr class="separator:a82fcbd40d2ef2b1d3091916c96afff26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e91e92e30e6084b2400012f23bd52b" id="r_a50e91e92e30e6084b2400012f23bd52b"><td class="memItemLeft" align="right" valign="top"><a id="a50e91e92e30e6084b2400012f23bd52b" name="a50e91e92e30e6084b2400012f23bd52b"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>lmax</b> (long a, long b)</td></tr>
<tr class="separator:a50e91e92e30e6084b2400012f23bd52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31db9f78433a6de800437aedfd1b2eb5" id="r_a31db9f78433a6de800437aedfd1b2eb5"><td class="memItemLeft" align="right" valign="top"><a id="a31db9f78433a6de800437aedfd1b2eb5" name="a31db9f78433a6de800437aedfd1b2eb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotation</b> (float *xout, float *xin, PosType theta)</td></tr>
<tr class="memdesc:a31db9f78433a6de800437aedfd1b2eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a31db9f78433a6de800437aedfd1b2eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad140aa2e74c584b82ff6416ff16622" id="r_a8ad140aa2e74c584b82ff6416ff16622"><td class="memItemLeft" align="right" valign="top"><a id="a8ad140aa2e74c584b82ff6416ff16622" name="a8ad140aa2e74c584b82ff6416ff16622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rotation</b> (PosType *xout, PosType const *xin, PosType theta)</td></tr>
<tr class="memdesc:a8ad140aa2e74c584b82ff6416ff16622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a8ad140aa2e74c584b82ff6416ff16622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0855636bdb71f103a4412555b9711e98" id="r_a0855636bdb71f103a4412555b9711e98"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0855636bdb71f103a4412555b9711e98">RandomFromTable</a> (PosType *table, unsigned long Ntable, long *seed)</td></tr>
<tr class="memdesc:a0855636bdb71f103a4412555b9711e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table.  <br /></td></tr>
<tr class="separator:a0855636bdb71f103a4412555b9711e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d" id="r_aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplParams" colspan="2"><a id="aae5ae9b5d81618c5ab06016357dc6c7d" name="aae5ae9b5d81618c5ab06016357dc6c7d"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract</b> (T &amp;p1, P &amp;p2)</td></tr>
<tr class="separator:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f" id="r_a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplParams" colspan="2"><a id="a34ba39540d95cbeaa6a00631c640ca7f" name="a34ba39540d95cbeaa6a00631c640ca7f"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crossD</b> (P &amp;O, P &amp;A, P &amp;B)</td></tr>
<tr class="separator:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96" id="r_a02302245829df0b35aca33fc6415cb96"><td class="memTemplParams" colspan="2"><a id="a02302245829df0b35aca33fc6415cb96" name="a02302245829df0b35aca33fc6415cb96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>RemoveIntersections</b> (std::vector&lt; T &gt; &amp;curve)</td></tr>
<tr class="memdesc:a02302245829df0b35aca33fc6415cb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the intersections of the curve <br /></td></tr>
<tr class="separator:a02302245829df0b35aca33fc6415cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f2aed1fb05038e399bf1287d64b56ec" id="r_a7f2aed1fb05038e399bf1287d64b56ec"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f2aed1fb05038e399bf1287d64b56ec">TighterHull</a> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v)</td></tr>
<tr class="separator:a7f2aed1fb05038e399bf1287d64b56ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c2b9ec5013e30e7b10d2ba8279e91e" id="r_ac6c2b9ec5013e30e7b10d2ba8279e91e"><td class="memItemLeft" align="right" valign="top"><a id="ac6c2b9ec5013e30e7b10d2ba8279e91e" name="ac6c2b9ec5013e30e7b10d2ba8279e91e"></a>
std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TightestHull</b> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:ac6c2b9ec5013e30e7b10d2ba8279e91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a concave envolope for an arbitrary closed curve. This is done by gridding and then finding points that are withing a sertain distance of a segment of the curve. The outer bounding curve is found and then the cuve is shrunck to the closest point on a segment. This should be fool proof, but is relatively slow and might clip some points. <br /></td></tr>
<tr class="separator:ac6c2b9ec5013e30e7b10d2ba8279e91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf99510eca3c45fe58e3dbb9ca49903" id="r_abdf99510eca3c45fe58e3dbb9ca49903"><td class="memItemLeft" align="right" valign="top"><a id="abdf99510eca3c45fe58e3dbb9ca49903" name="abdf99510eca3c45fe58e3dbb9ca49903"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RandomInTriangle</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x1, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x2, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x3, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="memdesc:abdf99510eca3c45fe58e3dbb9ca49903"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns random point within a trinagle <br /></td></tr>
<tr class="separator:abdf99510eca3c45fe58e3dbb9ca49903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf33af36f9a2b838dd1d875d10c94e68" id="r_acf33af36f9a2b838dd1d875d10c94e68"><td class="memItemLeft" align="right" valign="top"><a id="acf33af36f9a2b838dd1d875d10c94e68" name="acf33af36f9a2b838dd1d875d10c94e68"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RandomInConvexPoly</b> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="memdesc:acf33af36f9a2b838dd1d875d10c94e68"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a point within a convex polygon <br /></td></tr>
<tr class="separator:acf33af36f9a2b838dd1d875d10c94e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec39f1ef6af129844e062e851a691ed" id="r_abec39f1ef6af129844e062e851a691ed"><td class="memItemLeft" align="right" valign="top"><a id="abec39f1ef6af129844e062e851a691ed" name="abec39f1ef6af129844e062e851a691ed"></a>
std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RandomInConvexPoly</b> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, int N, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="separator:abec39f1ef6af129844e062e851a691ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f11f01f953cf74005513ad55a31dde4" id="r_a1f11f01f953cf74005513ad55a31dde4"><td class="memItemLeft" align="right" valign="top"><a id="a1f11f01f953cf74005513ad55a31dde4" name="a1f11f01f953cf74005513ad55a31dde4"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RandomInPoly</b> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="memdesc:a1f11f01f953cf74005513ad55a31dde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a point within a polygon that doesn't need to be convex <br /></td></tr>
<tr class="separator:a1f11f01f953cf74005513ad55a31dde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6503ec67bb7c13479823174345af21f" id="r_ae6503ec67bb7c13479823174345af21f"><td class="memItemLeft" align="right" valign="top"><a id="ae6503ec67bb7c13479823174345af21f" name="ae6503ec67bb7c13479823174345af21f"></a>
std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RandomInPoly</b> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, int N, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="separator:ae6503ec67bb7c13479823174345af21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f29cb220d5013f55306a8fb6f245a2" id="r_af8f29cb220d5013f55306a8fb6f245a2"><td class="memItemLeft" align="right" valign="top"><a id="af8f29cb220d5013f55306a8fb6f245a2" name="af8f29cb220d5013f55306a8fb6f245a2"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RandomNearPoly</b> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, double R, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="memdesc:af8f29cb220d5013f55306a8fb6f245a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a point within distance R of a polygon, i.e. the center of a cicle that intersects the interior of a polygon <br /></td></tr>
<tr class="separator:af8f29cb220d5013f55306a8fb6f245a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1394fabbbd7c898a96579347b9817652" id="r_a1394fabbbd7c898a96579347b9817652"><td class="memItemLeft" align="right" valign="top"><a id="a1394fabbbd7c898a96579347b9817652" name="a1394fabbbd7c898a96579347b9817652"></a>
std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RandomNearPoly</b> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;pp, int N, double R, <a class="el" href="class_utilities_1_1_random_numbers___n_r.html">Utilities::RandomNumbers_NR</a> &amp;ran)</td></tr>
<tr class="separator:a1394fabbbd7c898a96579347b9817652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ded74005933c13892203f9ad15cdbb0" id="r_a3ded74005933c13892203f9ad15cdbb0"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a3ded74005933c13892203f9ad15cdbb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3ded74005933c13892203f9ad15cdbb0">find_boundaries</a> (std::vector&lt; bool &gt; &amp;bitmap, long nx, std::vector&lt; std::vector&lt; P &gt; &gt; &amp;points, std::vector&lt; bool &gt; &amp;hits_edge, bool add_to_vector=false, bool outer_only=false)</td></tr>
<tr class="memdesc:a3ded74005933c13892203f9ad15cdbb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds ordered boundaries to regions where bitmap == true  <br /></td></tr>
<tr class="separator:a3ded74005933c13892203f9ad15cdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed791a1510ae7571dde0bd77ff4d1891" id="r_aed791a1510ae7571dde0bd77ff4d1891"><td class="memItemLeft" align="right" valign="top"><a id="aed791a1510ae7571dde0bd77ff4d1891" name="aed791a1510ae7571dde0bd77ff4d1891"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>find_islands</b> (std::vector&lt; bool &gt; &amp;bitmap, long nx, std::vector&lt; std::vector&lt; long &gt; &gt; &amp;indexes, std::vector&lt; bool &gt; &amp;hits_edge, bool add_to_vector=false)</td></tr>
<tr class="memdesc:aed791a1510ae7571dde0bd77ff4d1891"><td class="mdescLeft">&#160;</td><td class="mdescRight">find the indexes of areas with bitmap[]=true broken up into diconnected islands <br /></td></tr>
<tr class="separator:aed791a1510ae7571dde0bd77ff4d1891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d1b7298e1abe02b0d631ce556621b8" id="r_a69d1b7298e1abe02b0d631ce556621b8"><td class="memItemLeft" align="right" valign="top"><a id="a69d1b7298e1abe02b0d631ce556621b8" name="a69d1b7298e1abe02b0d631ce556621b8"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>interior_mass</b> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;alpha, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;x)</td></tr>
<tr class="memdesc:a69d1b7298e1abe02b0d631ce556621b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">this returns area within the curve x average kappa iwithin the curve <br /></td></tr>
<tr class="separator:a69d1b7298e1abe02b0d631ce556621b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd97747d61e6407e4c421eef6f04441" id="r_afdd97747d61e6407e4c421eef6f04441"><td class="memItemLeft" align="right" valign="top"><a id="afdd97747d61e6407e4c421eef6f04441" name="afdd97747d61e6407e4c421eef6f04441"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>interior_mass</b> (const std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;rays)</td></tr>
<tr class="memdesc:afdd97747d61e6407e4c421eef6f04441"><td class="mdescLeft">&#160;</td><td class="mdescRight">this returns area within the curve x average kappa iwithin the curve <br /></td></tr>
<tr class="separator:afdd97747d61e6407e4c421eef6f04441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc30c5f6b7875ed50bcae884432756" id="r_ac0dc30c5f6b7875ed50bcae884432756"><td class="memTemplParams" colspan="2"><a id="ac0dc30c5f6b7875ed50bcae884432756" name="ac0dc30c5f6b7875ed50bcae884432756"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0dc30c5f6b7875ed50bcae884432756"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>convex_hull</b> (const std::vector&lt; T &gt; &amp;PP)</td></tr>
<tr class="memdesc:ac0dc30c5f6b7875ed50bcae884432756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:ac0dc30c5f6b7875ed50bcae884432756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181252f6287df861af9107445a4cac7f" id="r_a181252f6287df861af9107445a4cac7f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a181252f6287df861af9107445a4cac7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a181252f6287df861af9107445a4cac7f">convex_hull</a> (const std::vector&lt; T &gt; &amp;P, std::vector&lt; size_t &gt; &amp;hull)</td></tr>
<tr class="separator:a181252f6287df861af9107445a4cac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051" id="r_a6d17c2495bead70b18b91c376c28c051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d17c2495bead70b18b91c376c28c051">concave</a> (std::vector&lt; T &gt; &amp;init_points, std::vector&lt; T &gt; &amp;hull_out, double scale)</td></tr>
<tr class="memdesc:a6d17c2495bead70b18b91c376c28c051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm.  <br /></td></tr>
<tr class="separator:a6d17c2495bead70b18b91c376c28c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0d6ff1e45b34802a2489b00778973a" id="r_ada0d6ff1e45b34802a2489b00778973a"><td class="memTemplParams" colspan="2"><a id="ada0d6ff1e45b34802a2489b00778973a" name="ada0d6ff1e45b34802a2489b00778973a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ada0d6ff1e45b34802a2489b00778973a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concave2</b> (std::vector&lt; T &gt; &amp;init_points, double scale)</td></tr>
<tr class="separator:ada0d6ff1e45b34802a2489b00778973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa741aedb82522c567b5124153cdea583" id="r_aa741aedb82522c567b5124153cdea583"><td class="memTemplParams" colspan="2"><a id="aa741aedb82522c567b5124153cdea583" name="aa741aedb82522c567b5124153cdea583"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:aa741aedb82522c567b5124153cdea583"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance_to_segment</b> (const Ptype &amp;P, const Ptype &amp;S1, const Ptype &amp;S2)</td></tr>
<tr class="separator:aa741aedb82522c567b5124153cdea583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581ceebfd95eafc258f7a8d932a2d2e8" id="r_a581ceebfd95eafc258f7a8d932a2d2e8"><td class="memTemplParams" colspan="2"><a id="a581ceebfd95eafc258f7a8d932a2d2e8" name="a581ceebfd95eafc258f7a8d932a2d2e8"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:a581ceebfd95eafc258f7a8d932a2d2e8"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>distance_to_segment</b> (const Ptype &amp;P, const Ptype &amp;S1, const Ptype &amp;S2, Ptype &amp;closest_point)</td></tr>
<tr class="separator:a581ceebfd95eafc258f7a8d932a2d2e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7806b8fa0368de7ee40f453c05c4561" id="r_ad7806b8fa0368de7ee40f453c05c4561"><td class="memTemplParams" colspan="2"><a id="ad7806b8fa0368de7ee40f453c05c4561" name="ad7806b8fa0368de7ee40f453c05c4561"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:ad7806b8fa0368de7ee40f453c05c4561"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>segments_cross</b> (const Ptype &amp;a1, const Ptype &amp;a2, const Ptype &amp;b1, const Ptype &amp;b2)</td></tr>
<tr class="separator:ad7806b8fa0368de7ee40f453c05c4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7611a51add4102b0f2109c5d652a20" id="r_afc7611a51add4102b0f2109c5d652a20"><td class="memTemplParams" colspan="2"><a id="afc7611a51add4102b0f2109c5d652a20" name="afc7611a51add4102b0f2109c5d652a20"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:afc7611a51add4102b0f2109c5d652a20"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inCurve</b> (const Ptype &amp;x, const std::vector&lt; Ptype &gt; &amp;H)</td></tr>
<tr class="separator:afc7611a51add4102b0f2109c5d652a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af814c998581b6e9f30a929c7508a1eff" id="r_af814c998581b6e9f30a929c7508a1eff"><td class="memTemplParams" colspan="2"><a id="af814c998581b6e9f30a929c7508a1eff" name="af814c998581b6e9f30a929c7508a1eff"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:af814c998581b6e9f30a929c7508a1eff"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inhull</b> (PosType x[], const std::vector&lt; Ptype &gt; &amp;H)</td></tr>
<tr class="separator:af814c998581b6e9f30a929c7508a1eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c697ef2e7c68ba5b3d68ffa0f1bb65b" id="r_a1c697ef2e7c68ba5b3d68ffa0f1bb65b"><td class="memItemLeft" align="right" valign="top"><a id="a1c697ef2e7c68ba5b3d68ffa0f1bb65b" name="a1c697ef2e7c68ba5b3d68ffa0f1bb65b"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a1c697ef2e7c68ba5b3d68ffa0f1bb65b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inhull&lt; Point * &gt;</b> (PosType x[], const std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;H)</td></tr>
<tr class="separator:a1c697ef2e7c68ba5b3d68ffa0f1bb65b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c8c08716d4ebdceb0b8c31d543773a" id="r_a85c8c08716d4ebdceb0b8c31d543773a"><td class="memItemLeft" align="right" valign="top"><a id="a85c8c08716d4ebdceb0b8c31d543773a" name="a85c8c08716d4ebdceb0b8c31d543773a"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a85c8c08716d4ebdceb0b8c31d543773a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inhull&lt; RAY &gt;</b> (PosType x[], const std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;H)</td></tr>
<tr class="memdesc:a85c8c08716d4ebdceb0b8c31d543773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds in x is within the curve discribed by the H[].x points ie image points <br /></td></tr>
<tr class="separator:a85c8c08716d4ebdceb0b8c31d543773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5cdf470897a1c0fa3f63c06ce8a1ce" id="r_a5f5cdf470897a1c0fa3f63c06ce8a1ce"><td class="memItemLeft" align="right" valign="top"><a id="a5f5cdf470897a1c0fa3f63c06ce8a1ce" name="a5f5cdf470897a1c0fa3f63c06ce8a1ce"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5f5cdf470897a1c0fa3f63c06ce8a1ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inhull&lt; PosType * &gt;</b> (PosType x[], const std::vector&lt; PosType * &gt; &amp;H)</td></tr>
<tr class="separator:a5f5cdf470897a1c0fa3f63c06ce8a1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe345295eb171c0665350842426124bd" id="r_abe345295eb171c0665350842426124bd"><td class="memTemplParams" colspan="2">template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:abe345295eb171c0665350842426124bd"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; Ptype &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abe345295eb171c0665350842426124bd">concaveK</a> (std::vector&lt; Ptype &gt; &amp;points, int &amp;k, bool check=true)</td></tr>
<tr class="separator:abe345295eb171c0665350842426124bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a073b41b6e45e881bc03e94bd2548ebad" id="r_a073b41b6e45e881bc03e94bd2548ebad"><td class="memTemplParams" colspan="2"><a id="a073b41b6e45e881bc03e94bd2548ebad" name="a073b41b6e45e881bc03e94bd2548ebad"></a>
template&lt;typename Ptype &gt; </td></tr>
<tr class="memitem:a073b41b6e45e881bc03e94bd2548ebad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>testconcaveK</b> ()</td></tr>
<tr class="separator:a073b41b6e45e881bc03e94bd2548ebad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55b9c3d5f503bd2c5544cdec2d5aa42" id="r_af55b9c3d5f503bd2c5544cdec2d5aa42"><td class="memItemLeft" align="right" valign="top"><a id="af55b9c3d5f503bd2c5544cdec2d5aa42" name="af55b9c3d5f503bd2c5544cdec2d5aa42"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>line_intersection</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;v1, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;v2, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;w1, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;w2)</td></tr>
<tr class="memdesc:af55b9c3d5f503bd2c5544cdec2d5aa42"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the interesetion point of line defined by v1,v2 and w1,w2 <br /></td></tr>
<tr class="separator:af55b9c3d5f503bd2c5544cdec2d5aa42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0243f1746707bddd91dd1295795f9e" id="r_afc0243f1746707bddd91dd1295795f9e"><td class="memItemLeft" align="right" valign="top"><a id="afc0243f1746707bddd91dd1295795f9e" name="afc0243f1746707bddd91dd1295795f9e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>circleIntersetsCurve</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, double r, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:afc0243f1746707bddd91dd1295795f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a circle of radius r around the point x intersects with the curve v. Does not include case where one compleatly encloses the other. <br /></td></tr>
<tr class="separator:afc0243f1746707bddd91dd1295795f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8667e8dfb7a5c44ae73262f63dd2ba" id="r_aed8667e8dfb7a5c44ae73262f63dd2ba"><td class="memItemLeft" align="right" valign="top"><a id="aed8667e8dfb7a5c44ae73262f63dd2ba" name="aed8667e8dfb7a5c44ae73262f63dd2ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>circleOverlapsCurve</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, double r, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:aed8667e8dfb7a5c44ae73262f63dd2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is any overlap between a curve and a circle. This includea cases where one compleatly encloses the other. <br /></td></tr>
<tr class="separator:aed8667e8dfb7a5c44ae73262f63dd2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3b3327085b03c3dcbb1afadd59fcd4" id="r_a6b3b3327085b03c3dcbb1afadd59fcd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b3b3327085b03c3dcbb1afadd59fcd4">envelope</a> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a6b3b3327085b03c3dcbb1afadd59fcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a curve that is made up of segments from v and w that surrounds them and does not self intersect.  <br /></td></tr>
<tr class="separator:a6b3b3327085b03c3dcbb1afadd59fcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baf3c89ecca31f0771e2d781a856f20" id="r_a8baf3c89ecca31f0771e2d781a856f20"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8baf3c89ecca31f0771e2d781a856f20">envelope2</a> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;w)</td></tr>
<tr class="memdesc:a8baf3c89ecca31f0771e2d781a856f20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a curve that is made up of segments from v and w that surrounds them and does not self intersect.  <br /></td></tr>
<tr class="separator:a8baf3c89ecca31f0771e2d781a856f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de229537fd082d389db103bd918160a" id="r_a8de229537fd082d389db103bd918160a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8de229537fd082d389db103bd918160a">thicken_poly</a> (const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;v, double R)</td></tr>
<tr class="memdesc:a8de229537fd082d389db103bd918160a"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the boundaries of the region that is within R of the curve v  <br /></td></tr>
<tr class="separator:a8de229537fd082d389db103bd918160a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7be26dfecdca30048dd4d3842077a2" id="r_abc7be26dfecdca30048dd4d3842077a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc7be26dfecdca30048dd4d3842077a2">ReadFileNames</a> (std::string dir, const std::string filespec, std::vector&lt; std::string &gt; &amp;filenames, const std::string file_non_spec=&quot; &quot;, bool verbose=false)</td></tr>
<tr class="memdesc:abc7be26dfecdca30048dd4d3842077a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the fits files in a directory into a vector of PixelMaps.  <br /></td></tr>
<tr class="separator:abc7be26dfecdca30048dd4d3842077a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce4c9e1180dd33a9f4c0c416643a9e" id="r_af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memItemLeft" align="right" valign="top"><a id="af1ce4c9e1180dd33a9f4c0c416643a9e" name="af1ce4c9e1180dd33a9f4c0c416643a9e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>sepSQR</b> (PosType *xx, PosType *yy)</td></tr>
<tr class="memdesc:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separation squared between two positions in 2 dimensions. <br /></td></tr>
<tr class="separator:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c5422e8b232b598bfdf69131a7a41" id="r_a367c5422e8b232b598bfdf69131a7a41"><td class="memItemLeft" align="right" valign="top"><a id="a367c5422e8b232b598bfdf69131a7a41" name="a367c5422e8b232b598bfdf69131a7a41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>double_sort</b> (unsigned long n, PosType *arr, unsigned long *brr)</td></tr>
<tr class="separator:a367c5422e8b232b598bfdf69131a7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484765a953bdbceb52b23f6790d59cf2" id="r_a484765a953bdbceb52b23f6790d59cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a484765a953bdbceb52b23f6790d59cf2">double_sort_points</a> (unsigned long n, PosType *arr, <a class="el" href="struct_point.html">Point</a> *brr)</td></tr>
<tr class="memdesc:a484765a953bdbceb52b23f6790d59cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points in a point array.  <br /></td></tr>
<tr class="separator:a484765a953bdbceb52b23f6790d59cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e88bf3ba4576f526f75cd607954d4" id="r_a069e88bf3ba4576f526f75cd607954d4"><td class="memItemLeft" align="right" valign="top"><a id="a069e88bf3ba4576f526f75cd607954d4" name="a069e88bf3ba4576f526f75cd607954d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksortPoints</b> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N)</td></tr>
<tr class="memdesc:a069e88bf3ba4576f526f75cd607954d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points from smallest to largest according to the value of arr[]. Sorts arr[] and pointarray[] simultaneously. <br /></td></tr>
<tr class="separator:a069e88bf3ba4576f526f75cd607954d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0f971972428328fbfecb023efa932b" id="r_afe0f971972428328fbfecb023efa932b"><td class="memItemLeft" align="right" valign="top"><a id="afe0f971972428328fbfecb023efa932b" name="afe0f971972428328fbfecb023efa932b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksortPoints</b> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N)</td></tr>
<tr class="separator:afe0f971972428328fbfecb023efa932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616805c8dcc25692640ce161f5d4d6be" id="r_a616805c8dcc25692640ce161f5d4d6be"><td class="memTemplParams" colspan="2"><a id="a616805c8dcc25692640ce161f5d4d6be" name="a616805c8dcc25692640ce161f5d4d6be"></a>
template&lt;typename D &gt; </td></tr>
<tr class="memitem:a616805c8dcc25692640ce161f5d4d6be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quicksort</b> (unsigned long *particles, D *arr, unsigned long N)</td></tr>
<tr class="separator:a616805c8dcc25692640ce161f5d4d6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6be6f6a86b7b31f27b6d38ebcb93d6c" id="r_aa6be6f6a86b7b31f27b6d38ebcb93d6c"><td class="memTemplParams" colspan="2"><a id="aa6be6f6a86b7b31f27b6d38ebcb93d6c" name="aa6be6f6a86b7b31f27b6d38ebcb93d6c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa6be6f6a86b7b31f27b6d38ebcb93d6c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickPartition</b> (T pivotvalue, unsigned long *pivotindex, unsigned long *particles, T *arr, unsigned long N)</td></tr>
<tr class="separator:aa6be6f6a86b7b31f27b6d38ebcb93d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0087080ad4336acd526aeb64e114176e" id="r_a0087080ad4336acd526aeb64e114176e"><td class="memTemplParams" colspan="2"><a id="a0087080ad4336acd526aeb64e114176e" name="a0087080ad4336acd526aeb64e114176e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0087080ad4336acd526aeb64e114176e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickPartitionPoints</b> (T pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointarray, T *arr, unsigned long N)</td></tr>
<tr class="separator:a0087080ad4336acd526aeb64e114176e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed119e61f1d5a87c46cbc2e4e5e574e1" id="r_aed119e61f1d5a87c46cbc2e4e5e574e1"><td class="memTemplParams" colspan="2"><a id="aed119e61f1d5a87c46cbc2e4e5e574e1" name="aed119e61f1d5a87c46cbc2e4e5e574e1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aed119e61f1d5a87c46cbc2e4e5e574e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quickPartitionPoints</b> (T pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointarray, T(*func)(<a class="el" href="struct_point.html">Point</a> &amp;p), unsigned long N)</td></tr>
<tr class="separator:aed119e61f1d5a87c46cbc2e4e5e574e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f4aebc622ae58090979fda604d1fc" id="r_a606f4aebc622ae58090979fda604d1fc"><td class="memItemLeft" align="right" valign="top"><a id="a606f4aebc622ae58090979fda604d1fc" name="a606f4aebc622ae58090979fda604d1fc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>log_polar_grid</b> (<a class="el" href="struct_point.html">Point</a> *i_points, PosType rmax, PosType rmin, PosType *center, long Ngrid)</td></tr>
<tr class="separator:a606f4aebc622ae58090979fda604d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5dac005305573c90d3c46db67967a0" id="r_a7c5dac005305573c90d3c46db67967a0"><td class="memItemLeft" align="right" valign="top"><a id="a7c5dac005305573c90d3c46db67967a0" name="a7c5dac005305573c90d3c46db67967a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findarea</b> (<a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo)</td></tr>
<tr class="separator:a7c5dac005305573c90d3c46db67967a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771b5ff9b3034f364adcee471cb754d" id="r_a7771b5ff9b3034f364adcee471cb754d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7771b5ff9b3034f364adcee471cb754d">writeCurves</a> (int m, <a class="el" href="struct_image_info.html">ImageInfo</a> *critical, int Ncrit, int index)</td></tr>
<tr class="separator:a7771b5ff9b3034f364adcee471cb754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66dea830e7b8f4390339d39eca8af68" id="r_ac66dea830e7b8f4390339d39eca8af68"><td class="memItemLeft" align="right" valign="top"><a id="ac66dea830e7b8f4390339d39eca8af68" name="ac66dea830e7b8f4390339d39eca8af68"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="struct_point.html">Point</a> *O, const <a class="el" href="struct_point.html">Point</a> *A, const <a class="el" href="struct_point.html">Point</a> *B)</td></tr>
<tr class="separator:ac66dea830e7b8f4390339d39eca8af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b802d503f1acd2f3d92eb903b9228" id="r_ac42b802d503f1acd2f3d92eb903b9228"><td class="memItemLeft" align="right" valign="top"><a id="ac42b802d503f1acd2f3d92eb903b9228" name="ac42b802d503f1acd2f3d92eb903b9228"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:ac42b802d503f1acd2f3d92eb903b9228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff8c370817f6c178c77b361cca0292" id="r_a62ff8c370817f6c178c77b361cca0292"><td class="memItemLeft" align="right" valign="top"><a id="a62ff8c370817f6c178c77b361cca0292" name="a62ff8c370817f6c178c77b361cca0292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:a62ff8c370817f6c178c77b361cca0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6171a36bf18a88838285e19f90d63" id="r_afbe6171a36bf18a88838285e19f90d63"><td class="memItemLeft" align="right" valign="top"><a id="afbe6171a36bf18a88838285e19f90d63" name="afbe6171a36bf18a88838285e19f90d63"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (const double *O, const double *A, const double *B)</td></tr>
<tr class="separator:afbe6171a36bf18a88838285e19f90d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee147c1f79d2a84f9426c0dd7848ef4" id="r_a6ee147c1f79d2a84f9426c0dd7848ef4"><td class="memItemLeft" align="right" valign="top"><a id="a6ee147c1f79d2a84f9426c0dd7848ef4" name="a6ee147c1f79d2a84f9426c0dd7848ef4"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;O, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;A, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;B)</td></tr>
<tr class="separator:a6ee147c1f79d2a84f9426c0dd7848ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6997f6bfc95f466039c9652c6c50274f" id="r_a6997f6bfc95f466039c9652c6c50274f"><td class="memItemLeft" align="right" valign="top"><a id="a6997f6bfc95f466039c9652c6c50274f" name="a6997f6bfc95f466039c9652c6c50274f"></a>
std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convex_hull</b> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P)</td></tr>
<tr class="memdesc:a6997f6bfc95f466039c9652c6c50274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a6997f6bfc95f466039c9652c6c50274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0699a4c75e3899f853dee3fe6a442a25" id="r_a0699a4c75e3899f853dee3fe6a442a25"><td class="memItemLeft" align="right" valign="top"><a id="a0699a4c75e3899f853dee3fe6a442a25" name="a0699a4c75e3899f853dee3fe6a442a25"></a>
std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>convex_hull</b> (std::vector&lt; double * &gt; &amp;P)</td></tr>
<tr class="memdesc:a0699a4c75e3899f853dee3fe6a442a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a0699a4c75e3899f853dee3fe6a442a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82634714ad53172788a38cef165b07" id="r_aca82634714ad53172788a38cef165b07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca82634714ad53172788a38cef165b07">concave_hull</a> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P, int k, bool test=false)</td></tr>
<tr class="memdesc:aca82634714ad53172788a38cef165b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <br /></td></tr>
<tr class="separator:aca82634714ad53172788a38cef165b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadfff44acbcae923eac1bec385ae6e4" id="r_afadfff44acbcae923eac1bec385ae6e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afadfff44acbcae923eac1bec385ae6e4">concave_hull</a> (std::vector&lt; double * &gt; &amp;P, int k)</td></tr>
<tr class="memdesc:afadfff44acbcae923eac1bec385ae6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <br /></td></tr>
<tr class="separator:afadfff44acbcae923eac1bec385ae6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ef3b7c0383a2ca61eb5d479d8490d" id="r_ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac71ef3b7c0383a2ca61eb5d479d8490d">contour_ellipse</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, <a class="el" href="struct_point__2d.html">Point_2d</a> center, unsigned long Npoints, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;C, double *ellipticity, double *ellipse_area)</td></tr>
<tr class="memdesc:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour).  <br /></td></tr>
<tr class="separator:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6187b4dcc9357787a98f62c63b5b716" id="r_ab6187b4dcc9357787a98f62c63b5b716"><td class="memItemLeft" align="right" valign="top"><a id="ab6187b4dcc9357787a98f62c63b5b716" name="ab6187b4dcc9357787a98f62c63b5b716"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>contour_ellipse</b> (std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;P, <a class="el" href="struct_point__2d.html">Point_2d</a> center, unsigned long Npoints, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;C, double *ellipticity, double *ellipse_area)</td></tr>
<tr class="separator:ab6187b4dcc9357787a98f62c63b5b716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d73667d76a5a58e44042a4a73c974" id="r_a512d73667d76a5a58e44042a4a73c974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a512d73667d76a5a58e44042a4a73c974">contour_center</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, unsigned long Npoints)</td></tr>
<tr class="memdesc:a512d73667d76a5a58e44042a4a73c974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another.  <br /></td></tr>
<tr class="separator:a512d73667d76a5a58e44042a4a73c974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1adbf25f771564249b51be04a10b09" id="r_a3c1adbf25f771564249b51be04a10b09"><td class="memItemLeft" align="right" valign="top"><a id="a3c1adbf25f771564249b51be04a10b09" name="a3c1adbf25f771564249b51be04a10b09"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>contour_center</b> (std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;P, unsigned long Npoints)</td></tr>
<tr class="separator:a3c1adbf25f771564249b51be04a10b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa727547d253bdbd88ac47cae3f7c65c4" id="r_aa727547d253bdbd88ac47cae3f7c65c4"><td class="memItemLeft" align="right" valign="top"><a id="aa727547d253bdbd88ac47cae3f7c65c4" name="aa727547d253bdbd88ac47cae3f7c65c4"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType *x, long Npixels, PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>, const PosType *center)</td></tr>
<tr class="separator:aa727547d253bdbd88ac47cae3f7c65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68bfc533f3ce300625ec2b97073800" id="r_afa68bfc533f3ce300625ec2b97073800"><td class="memItemLeft" align="right" valign="top"><a id="afa68bfc533f3ce300625ec2b97073800" name="afa68bfc533f3ce300625ec2b97073800"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PositionFromIndex</b> (unsigned long i, PosType *x, long Npixels, PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>, PosType const *center)</td></tr>
<tr class="memdesc:afa68bfc533f3ce300625ec2b97073800"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square regions. <br /></td></tr>
<tr class="separator:afa68bfc533f3ce300625ec2b97073800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a19e41534673a4234e99cce59b0a23" id="r_a97a19e41534673a4234e99cce59b0a23"><td class="memItemLeft" align="right" valign="top"><a id="a97a19e41534673a4234e99cce59b0a23" name="a97a19e41534673a4234e99cce59b0a23"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType x, long Npixels, PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>, PosType center)</td></tr>
<tr class="separator:a97a19e41534673a4234e99cce59b0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d063fcd59fdf742b8cbf0c57ef29104" id="r_a2d063fcd59fdf742b8cbf0c57ef29104"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d063fcd59fdf742b8cbf0c57ef29104">TwoDInterpolator</a> (PosType *x,int Npixels,PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>,PosType *center,PosType *map,bool init)</td></tr>
<tr class="memdesc:a2d063fcd59fdf742b8cbf0c57ef29104"><td class="mdescLeft">&#160;</td><td class="mdescRight">bilinear interpolation from a map.  <br /></td></tr>
<tr class="separator:a2d063fcd59fdf742b8cbf0c57ef29104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cbfc7c5cbcb4525faabc04298eb54d" id="r_af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memItemLeft" align="right" valign="top"><a id="af1cbfc7c5cbcb4525faabc04298eb54d" name="af1cbfc7c5cbcb4525faabc04298eb54d"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>TwoDInterpolator</b> (PosType *map)</td></tr>
<tr class="separator:af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712b815d57f9f34d4d2e02209bfc1c2b" id="r_a712b815d57f9f34d4d2e02209bfc1c2b"><td class="memTemplParams" colspan="2"><a id="a712b815d57f9f34d4d2e02209bfc1c2b" name="a712b815d57f9f34d4d2e02209bfc1c2b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a712b815d57f9f34d4d2e02209bfc1c2b"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cutbox</b> (const T *center, T *p1, T *p2, float rmax)</td></tr>
<tr class="separator:a712b815d57f9f34d4d2e02209bfc1c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f" id="r_ac985ac1b171f2d550864536530bbac2f"><td class="memTemplParams" colspan="2"><a id="ac985ac1b171f2d550864536530bbac2f" name="ac985ac1b171f2d550864536530bbac2f"></a>
template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quicksortPoints_multithread</b> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac985ac1b171f2d550864536530bbac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The last parameter should be left out when calling so that it takes the default value. <br /></td></tr>
<tr class="separator:ac985ac1b171f2d550864536530bbac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a" id="r_ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplParams" colspan="2">template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac980fbca67c1ca7531d28e98433e669a">quicksortPoints_multithread</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac980fbca67c1ca7531d28e98433e669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value.  <br /></td></tr>
<tr class="separator:ac980fbca67c1ca7531d28e98433e669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48" id="r_ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplParams" colspan="2"><a id="ac7ddbf6268cb6f39b3e6d1b046ff1a48" name="ac7ddbf6268cb6f39b3e6d1b046ff1a48"></a>
template&lt;typename T , int lev&gt; </td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>quicksort_multithread</b> (T *array, double(*func)(T &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a T type and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. std::swap() is used to swap elements of the array. <br /></td></tr>
<tr class="separator:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f92371d63e47b1c09977312f15a15f0" id="r_a0f92371d63e47b1c09977312f15a15f0"><td class="memItemLeft" align="right" valign="top"><a id="a0f92371d63e47b1c09977312f15a15f0" name="a0f92371d63e47b1c09977312f15a15f0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (<a class="el" href="struct_point.html">Point</a> *p0, <a class="el" href="struct_point.html">Point</a> *p1, PosType *x)</td></tr>
<tr class="separator:a0f92371d63e47b1c09977312f15a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281a4ca91cc4e6ba6380b946ed5457af" id="r_a281a4ca91cc4e6ba6380b946ed5457af"><td class="memItemLeft" align="right" valign="top"><a id="a281a4ca91cc4e6ba6380b946ed5457af" name="a281a4ca91cc4e6ba6380b946ed5457af"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p0, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p1, const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x)</td></tr>
<tr class="separator:a281a4ca91cc4e6ba6380b946ed5457af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61342a713adf7115f351e3342a2b79" id="r_abe61342a713adf7115f351e3342a2b79"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe61342a713adf7115f351e3342a2b79">prevpower</a> (unsigned long k)</td></tr>
<tr class="separator:abe61342a713adf7115f351e3342a2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42846299720c47decf597f70d448464" id="r_ac42846299720c47decf597f70d448464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac42846299720c47decf597f70d448464">windings</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:ac42846299720c47decf597f70d448464"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="#ac42846299720c47decf597f70d448464" title="windings(): winding number test for a point in a polygon Returns: Number of times a curves winds arou...">windings()</a>: winding number test for a point in a polygon Returns: Number of times a curves winds around the point x.  <br /></td></tr>
<tr class="separator:ac42846299720c47decf597f70d448464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964e6781b61f0d76240eda24a4f9ffa" id="r_ad964e6781b61f0d76240eda24a4f9ffa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad964e6781b61f0d76240eda24a4f9ffa">windings</a> (PosType *x, <a class="el" href="struct_point.html">Point</a> **points, unsigned long Npoints, PosType *area, short image=0)</td></tr>
<tr class="separator:ad964e6781b61f0d76240eda24a4f9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f4dcf28911d550c9bd20eeba202f5f" id="r_a09f4dcf28911d550c9bd20eeba202f5f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09f4dcf28911d550c9bd20eeba202f5f">windings</a> (const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;point, PosType *area)</td></tr>
<tr class="separator:a09f4dcf28911d550c9bd20eeba202f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc8d337b886b466535a29068af0b4994" id="r_afc8d337b886b466535a29068af0b4994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc8d337b886b466535a29068af0b4994">windings</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;point, PosType *area)</td></tr>
<tr class="separator:afc8d337b886b466535a29068af0b4994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db30634cbf18e1652cd2a9ec7f95aa" id="r_aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7db30634cbf18e1652cd2a9ec7f95aa">windings</a> (PosType *x, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *kist, PosType *area, short image=0)</td></tr>
<tr class="separator:aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de03dea8a3f77f15fd209a783a8065" id="r_a70de03dea8a3f77f15fd209a783a8065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70de03dea8a3f77f15fd209a783a8065">windings2</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points_original,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:a70de03dea8a3f77f15fd209a783a8065"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether a point is inside a curve, that has been stretched 1.2 times returns the area of the stretched curve  <br /></td></tr>
<tr class="separator:a70de03dea8a3f77f15fd209a783a8065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fb3cc522fc36c51e33bccac70089c7" id="r_af2fb3cc522fc36c51e33bccac70089c7"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2fb3cc522fc36c51e33bccac70089c7">order_curve4</a> (<a class="el" href="struct_point.html">Point</a> *curve, long Npoints)</td></tr>
<tr class="memdesc:af2fb3cc522fc36c51e33bccac70089c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if it is in the curve and 0 if it is out. Borders count as in.  <br /></td></tr>
<tr class="separator:af2fb3cc522fc36c51e33bccac70089c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e95a7c17ef4a5d5c4a31fac956140c" id="r_ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memItemLeft" align="right" valign="top"><a id="ab9e95a7c17ef4a5d5c4a31fac956140c" name="ab9e95a7c17ef4a5d5c4a31fac956140c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>order_curve4</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads and is dependent on version that takes a point array. Returns number of points that have been ordered. Remaining, unordered points are left at the end of the kist. <br /></td></tr>
<tr class="separator:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8293f72cb05db408c84e3d101a56e41" id="r_ad8293f72cb05db408c84e3d101a56e41"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8293f72cb05db408c84e3d101a56e41">order_curve5</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ad8293f72cb05db408c84e3d101a56e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">For odering the curve by the convex hull method. Warning: Does not work very well.  <br /></td></tr>
<tr class="separator:ad8293f72cb05db408c84e3d101a56e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ad22484d4cfaaefd6317d73a74934" id="r_a742ad22484d4cfaaefd6317d73a74934"><td class="memItemLeft" align="right" valign="top"><a id="a742ad22484d4cfaaefd6317d73a74934" name="a742ad22484d4cfaaefd6317d73a74934"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_convexhull</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a742ad22484d4cfaaefd6317d73a74934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve-&gt;imagekist with its convex hull. The number of points will change. <br /></td></tr>
<tr class="separator:a742ad22484d4cfaaefd6317d73a74934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8efda5cf4838d1780ea6e08e155566f" id="r_aa8efda5cf4838d1780ea6e08e155566f"><td class="memItemLeft" align="right" valign="top"><a id="aa8efda5cf4838d1780ea6e08e155566f" name="aa8efda5cf4838d1780ea6e08e155566f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_shrink_wrap</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:aa8efda5cf4838d1780ea6e08e155566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a7f052ffe8de55dfdc33d06dc541c" id="r_ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memItemLeft" align="right" valign="top"><a id="ac95a7f052ffe8de55dfdc33d06dc541c" name="ac95a7f052ffe8de55dfdc33d06dc541c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_concavehull</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c4f1f38a91d8b3d4e07fdfea16bd0" id="r_a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a865c4f1f38a91d8b3d4e07fdfea16bd0">ConvexHullArea</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve with its convex hull. The number of points will change.  <br /></td></tr>
<tr class="separator:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6368539a2249ac91796f3ff043e39d" id="r_a1a6368539a2249ac91796f3ff043e39d"><td class="memTemplParams" colspan="2"><a id="a1a6368539a2249ac91796f3ff043e39d" name="a1a6368539a2249ac91796f3ff043e39d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a6368539a2249ac91796f3ff043e39d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric</b> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a1a6368539a2249ac91796f3ff043e39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a string to a numerical value of various types <br /></td></tr>
<tr class="separator:a1a6368539a2249ac91796f3ff043e39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55417d380d1000c91b7a59253cd0b82c" id="r_a55417d380d1000c91b7a59253cd0b82c"><td class="memItemLeft" align="right" valign="top"><a id="a55417d380d1000c91b7a59253cd0b82c" name="a55417d380d1000c91b7a59253cd0b82c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a55417d380d1000c91b7a59253cd0b82c"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; long &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a55417d380d1000c91b7a59253cd0b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d114df3356f5498414ff9a481f2173" id="r_a35d114df3356f5498414ff9a481f2173"><td class="memItemLeft" align="right" valign="top"><a id="a35d114df3356f5498414ff9a481f2173" name="a35d114df3356f5498414ff9a481f2173"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a35d114df3356f5498414ff9a481f2173"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; int &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a35d114df3356f5498414ff9a481f2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a01d1a182e6b247d4702062aab5a32f" id="r_a0a01d1a182e6b247d4702062aab5a32f"><td class="memItemLeft" align="right" valign="top"><a id="a0a01d1a182e6b247d4702062aab5a32f" name="a0a01d1a182e6b247d4702062aab5a32f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0a01d1a182e6b247d4702062aab5a32f"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; float &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a0a01d1a182e6b247d4702062aab5a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b8518238ba6cedc16d8012904c70f" id="r_a5b3b8518238ba6cedc16d8012904c70f"><td class="memItemLeft" align="right" valign="top"><a id="a5b3b8518238ba6cedc16d8012904c70f" name="a5b3b8518238ba6cedc16d8012904c70f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5b3b8518238ba6cedc16d8012904c70f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; double &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a5b3b8518238ba6cedc16d8012904c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32849c92ee172e983b4223072587ae6d" id="r_a32849c92ee172e983b4223072587ae6d"><td class="memTemplParams" colspan="2"><a id="a32849c92ee172e983b4223072587ae6d" name="a32849c92ee172e983b4223072587ae6d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32849c92ee172e983b4223072587ae6d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlwaysTrue</b> (T t)</td></tr>
<tr class="separator:a32849c92ee172e983b4223072587ae6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab47b3f15baa661c5bb9cfd66acea8758" id="r_ab47b3f15baa661c5bb9cfd66acea8758"><td class="memTemplParams" colspan="2"><a id="ab47b3f15baa661c5bb9cfd66acea8758" name="ab47b3f15baa661c5bb9cfd66acea8758"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab47b3f15baa661c5bb9cfd66acea8758"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AlwaysFalse</b> (T t)</td></tr>
<tr class="separator:ab47b3f15baa661c5bb9cfd66acea8758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf3959325f408179babef5fc09a0a24" id="r_abdf3959325f408179babef5fc09a0a24"><td class="memTemplParams" colspan="2"><a id="abdf3959325f408179babef5fc09a0a24" name="abdf3959325f408179babef5fc09a0a24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abdf3959325f408179babef5fc09a0a24"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vec_sum</b> (const std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="separator:abdf3959325f408179babef5fc09a0a24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b" id="r_a5364acb5691c4969be66653956508e6b"><td class="memTemplParams" colspan="2"><a id="a5364acb5691c4969be66653956508e6b" name="a5364acb5691c4969be66653956508e6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Matrix</b> (T **matrix, long rows, long cols)</td></tr>
<tr class="separator:a5364acb5691c4969be66653956508e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa" id="r_acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplParams" colspan="2"><a id="acdc7f37bdbbd9f9893af797a98f601aa" name="acdc7f37bdbbd9f9893af797a98f601aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>free_Matrix</b> (T **matrix, long rows, long)</td></tr>
<tr class="separator:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab156e03bf2f71c3c0de9e267dcb39b" id="r_aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memItemLeft" align="right" valign="top"><a id="aeab156e03bf2f71c3c0de9e267dcb39b" name="aeab156e03bf2f71c3c0de9e267dcb39b"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (size_t rows, size_t cols)</td></tr>
<tr class="separator:aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee12be6dc37bf892ebfbeff4b835084" id="r_a9ee12be6dc37bf892ebfbeff4b835084"><td class="memItemLeft" align="right" valign="top"><a id="a9ee12be6dc37bf892ebfbeff4b835084" name="a9ee12be6dc37bf892ebfbeff4b835084"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, size_t rows, size_t cols)</td></tr>
<tr class="separator:a9ee12be6dc37bf892ebfbeff4b835084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8540dba0d1bf112290a7389379fefa" id="r_aee8540dba0d1bf112290a7389379fefa"><td class="memItemLeft" align="right" valign="top"><a id="aee8540dba0d1bf112290a7389379fefa" name="aee8540dba0d1bf112290a7389379fefa"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aee8540dba0d1bf112290a7389379fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f8b847fdd13e67af70275c2df84ef9" id="r_aa8f8b847fdd13e67af70275c2df84ef9"><td class="memItemLeft" align="right" valign="top"><a id="aa8f8b847fdd13e67af70275c2df84ef9" name="aa8f8b847fdd13e67af70275c2df84ef9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aa8f8b847fdd13e67af70275c2df84ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5" id="r_a355e53765bbce52485685f2cf11632d5"><td class="memTemplParams" colspan="2"><a id="a355e53765bbce52485685f2cf11632d5" name="a355e53765bbce52485685f2cf11632d5"></a>
template&lt;class BaseT &gt; </td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (std::vector&lt; BaseT * &gt; &amp;items, PosType target)</td></tr>
<tr class="separator:a355e53765bbce52485685f2cf11632d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874" id="r_ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplParams" colspan="2"><a id="ab5fbd0455bb23cf8290252d8ddef0874" name="ab5fbd0455bb23cf8290252d8ddef0874"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>delete_container</b> (Container &amp;c)</td></tr>
<tr class="memdesc:ab5fbd0455bb23cf8290252d8ddef0874"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the objects that are pointed to in a container of pointers <br /></td></tr>
<tr class="separator:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec" id="r_a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplParams" colspan="2"><a id="a42da2b93e07ba858edd0d2b9ca7032ec" name="a42da2b93e07ba858edd0d2b9ca7032ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>between</b> (const T &amp;x, const T &amp;l, const T &amp;u)</td></tr>
<tr class="separator:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9906f7f742a4940019f2a58cabdb05c" id="r_aa9906f7f742a4940019f2a58cabdb05c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:aa9906f7f742a4940019f2a58cabdb05c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9906f7f742a4940019f2a58cabdb05c">shuffle</a> (std::vector&lt; T &gt; &amp;vec, R &amp;ran)</td></tr>
<tr class="memdesc:aa9906f7f742a4940019f2a58cabdb05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles a vector into a random order.  <br /></td></tr>
<tr class="separator:aa9906f7f742a4940019f2a58cabdb05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577" id="r_a9b44ff17b26b627e429e9984d4908577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b44ff17b26b627e429e9984d4908577">sort_indexes</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:a9b44ff17b26b627e429e9984d4908577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in asending order.  <br /></td></tr>
<tr class="separator:a9b44ff17b26b627e429e9984d4908577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581" id="r_a357b69312972120ce046eff265e6b581"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a357b69312972120ce046eff265e6b581">sort_indexes</a> (const T *v, std::vector&lt; size_t &gt; &amp;index, size_t N)</td></tr>
<tr class="separator:a357b69312972120ce046eff265e6b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe" id="r_aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aec9c85bddb9c124c7df2bc04fbf350fe">sort_indexes_decending</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in descending order.  <br /></td></tr>
<tr class="separator:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d" id="r_abd8109e832d4f887939cbaef421a101d"><td class="memTemplParams" colspan="2"><a id="abd8109e832d4f887939cbaef421a101d" name="abd8109e832d4f887939cbaef421a101d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (T *vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:abd8109e832d4f887939cbaef421a101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043" id="r_a173a48bc6f7d6968101fca85c6998043"><td class="memTemplParams" colspan="2"><a id="a173a48bc6f7d6968101fca85c6998043" name="a173a48bc6f7d6968101fca85c6998043"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (std::vector&lt; T &gt; &amp;vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:a173a48bc6f7d6968101fca85c6998043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586082194e51dc17b62453f79b012310" id="r_a586082194e51dc17b62453f79b012310"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a586082194e51dc17b62453f79b012310">powerspectrum2d</a> (std::valarray&lt; double &gt; const &amp;aa, std::valarray&lt; double &gt; const &amp;bb, long nx, long ny, double boxlx, double boxly, std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl, double zeropaddingfactor)</td></tr>
<tr class="memdesc:a586082194e51dc17b62453f79b012310"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates power spectrum from a 2d map or the cross-power spectrum between two 2d maps.  <br /></td></tr>
<tr class="separator:a586082194e51dc17b62453f79b012310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da3b0a449dad814f7c6c804fc323a4d" id="r_a1da3b0a449dad814f7c6c804fc323a4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1da3b0a449dad814f7c6c804fc323a4d">powerspectrum2d</a> (std::valarray&lt; double &gt; &amp;aa, long nx, long ny, double boxlx, double boxly, std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl)</td></tr>
<tr class="separator:a1da3b0a449dad814f7c6c804fc323a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf9204e09d3023ddd66cf4a3d440181" id="r_adbf9204e09d3023ddd66cf4a3d440181"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbf9204e09d3023ddd66cf4a3d440181">powerspectrum2dprebin</a> (std::valarray&lt; double &gt; &amp;aa, long nx, long ny, double boxlx, double boxly, const std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl, std::vector&lt; double &gt; &amp;llave)</td></tr>
<tr class="separator:adbf9204e09d3023ddd66cf4a3d440181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae84841923bdfd928af1928c94464313" id="r_aae84841923bdfd928af1928c94464313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae84841923bdfd928af1928c94464313">powerspectrum2d</a> (std::valarray&lt; float &gt; const &amp;aa, std::valarray&lt; float &gt; const &amp;bb, long nx, long ny, double boxlx, double boxly, std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl, double zeropaddingfactor)</td></tr>
<tr class="separator:aae84841923bdfd928af1928c94464313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee3342e8438958ee6d2befb1d239f7c" id="r_a8ee3342e8438958ee6d2befb1d239f7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ee3342e8438958ee6d2befb1d239f7c">powerspectrum2d</a> (std::valarray&lt; float &gt; &amp;aa, long nx, long ny, double boxlx, double boxly, std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl)</td></tr>
<tr class="separator:a8ee3342e8438958ee6d2befb1d239f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604490c5c8fae106fff74568d9706f93" id="r_a604490c5c8fae106fff74568d9706f93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a604490c5c8fae106fff74568d9706f93">powerspectrum2dprebin</a> (std::valarray&lt; float &gt; &amp;aa, int nx, int ny, double boxlx, double boxly, const std::vector&lt; double &gt; &amp;ll, std::vector&lt; double &gt; &amp;Pl, std::vector&lt; double &gt; &amp;llave)</td></tr>
<tr class="separator:a604490c5c8fae106fff74568d9706f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa654746e24cd77549f412bed8d3ee26" id="r_afa654746e24cd77549f412bed8d3ee26"><td class="memItemLeft" align="right" valign="top"><a id="afa654746e24cd77549f412bed8d3ee26" name="afa654746e24cd77549f412bed8d3ee26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>GetNThreads</b> ()</td></tr>
<tr class="memdesc:afa654746e24cd77549f412bed8d3ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the compiler variable N_THREADS that is maximum number of threads to be used. <br /></td></tr>
<tr class="separator:afa654746e24cd77549f412bed8d3ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede0e6fa297e5d2f12c89724110bc25" id="r_acede0e6fa297e5d2f12c89724110bc25"><td class="memItemLeft" align="right" valign="top"><a id="acede0e6fa297e5d2f12c89724110bc25" name="acede0e6fa297e5d2f12c89724110bc25"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>splitstring</b> (std::string &amp;line, std::vector&lt; std::string &gt; &amp;vec, const std::string &amp;delimiter)</td></tr>
<tr class="memdesc:acede0e6fa297e5d2f12c89724110bc25"><td class="mdescLeft">&#160;</td><td class="mdescRight">split string into vector of seporate strings that were seporated by <br /></td></tr>
<tr class="separator:acede0e6fa297e5d2f12c89724110bc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bcb1b508d1a083903f7efe1cef059c6" id="r_a9bcb1b508d1a083903f7efe1cef059c6"><td class="memTemplParams" colspan="2"><a id="a9bcb1b508d1a083903f7efe1cef059c6" name="a9bcb1b508d1a083903f7efe1cef059c6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9bcb1b508d1a083903f7efe1cef059c6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KleinSum</b> (std::vector&lt; T &gt; &amp;input)</td></tr>
<tr class="separator:a9bcb1b508d1a083903f7efe1cef059c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cc851578407384fcfddcecd75d32c0e" id="r_a9cc851578407384fcfddcecd75d32c0e"><td class="memTemplParams" colspan="2"><a id="a9cc851578407384fcfddcecd75d32c0e" name="a9cc851578407384fcfddcecd75d32c0e"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:a9cc851578407384fcfddcecd75d32c0e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PairWiseSum</b> (T *begin, T *end, F value)</td></tr>
<tr class="separator:a9cc851578407384fcfddcecd75d32c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24b7bf4d27bbe77e4b9f68e879015d4" id="r_af24b7bf4d27bbe77e4b9f68e879015d4"><td class="memTemplParams" colspan="2"><a id="af24b7bf4d27bbe77e4b9f68e879015d4" name="af24b7bf4d27bbe77e4b9f68e879015d4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af24b7bf4d27bbe77e4b9f68e879015d4"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PairWiseSum</b> (T *begin, T *end)</td></tr>
<tr class="memdesc:af24b7bf4d27bbe77e4b9f68e879015d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a parwise sumation of a vector which incresses the precision of the sumation to ~O(epsilon log(n) ) <br /></td></tr>
<tr class="separator:af24b7bf4d27bbe77e4b9f68e879015d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb73b4921a044eff1a54293379118c2f" id="r_abb73b4921a044eff1a54293379118c2f"><td class="memTemplParams" colspan="2"><a id="abb73b4921a044eff1a54293379118c2f" name="abb73b4921a044eff1a54293379118c2f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abb73b4921a044eff1a54293379118c2f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PairWiseSum</b> (std::vector&lt; T &gt; &amp;v)</td></tr>
<tr class="memdesc:abb73b4921a044eff1a54293379118c2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does a parwise sumation of a vector which incresses the precision of the sumation to ~O(epsilon log(n) ) <br /></td></tr>
<tr class="separator:abb73b4921a044eff1a54293379118c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb47bcadb1b1b4c2662f37d26e84cf0e" id="r_afb47bcadb1b1b4c2662f37d26e84cf0e"><td class="memTemplParams" colspan="2"><a id="afb47bcadb1b1b4c2662f37d26e84cf0e" name="afb47bcadb1b1b4c2662f37d26e84cf0e"></a>
template&lt;typename T , typename F &gt; </td></tr>
<tr class="memitem:afb47bcadb1b1b4c2662f37d26e84cf0e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>PairWiseSum</b> (std::vector&lt; T &gt; &amp;v, F value)</td></tr>
<tr class="memdesc:afb47bcadb1b1b4c2662f37d26e84cf0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version allows you to specify a function( value(T * p) ), that returns the value of a pointer to a T type that is to be summed. This is useful for summing the squares or summing some a particular variable within a list of objects. A lambda function is particularly useful here. <br /></td></tr>
<tr class="separator:afb47bcadb1b1b4c2662f37d26e84cf0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775bfd83e477acd7cb1ab132c4e7f9ad" id="r_a775bfd83e477acd7cb1ab132c4e7f9ad"><td class="memTemplParams" colspan="2"><a id="a775bfd83e477acd7cb1ab132c4e7f9ad" name="a775bfd83e477acd7cb1ab132c4e7f9ad"></a>
template&lt;typename T  = double&gt; </td></tr>
<tr class="memitem:a775bfd83e477acd7cb1ab132c4e7f9ad"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>hypergeometric</b> (T a, T b, T c, T x)</td></tr>
<tr class="separator:a775bfd83e477acd7cb1ab132c4e7f9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3735cfea92026435e078b653adb29782" id="r_a3735cfea92026435e078b653adb29782"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3735cfea92026435e078b653adb29782"><td class="memTemplItemLeft" align="right" valign="top">std::valarray&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3735cfea92026435e078b653adb29782">AdaptiveSmooth</a> (const std::valarray&lt; T &gt; &amp;map_in, size_t Nx, size_t Ny, T value)</td></tr>
<tr class="memdesc:a3735cfea92026435e078b653adb29782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a 2 dimensional map stored in a valarray with a density dependent kernel.  <br /></td></tr>
<tr class="separator:a3735cfea92026435e078b653adb29782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae358b58a950d75ef089c7ad73f37a080" id="r_ae358b58a950d75ef089c7ad73f37a080"><td class="memItemLeft" align="right" valign="top"><a id="ae358b58a950d75ef089c7ad73f37a080" name="ae358b58a950d75ef089c7ad73f37a080"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:ae358b58a950d75ef089c7ad73f37a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa3e10d9b962622365a0916fb0fa01" id="r_a5baa3e10d9b962622365a0916fb0fa01"><td class="memItemLeft" align="right" valign="top"><a id="a5baa3e10d9b962622365a0916fb0fa01" name="a5baa3e10d9b962622365a0916fb0fa01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:a5baa3e10d9b962622365a0916fb0fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495d1ed407458779abf8694a2e4cda2" id="r_af495d1ed407458779abf8694a2e4cda2"><td class="memItemLeft" align="right" valign="top"><a id="af495d1ed407458779abf8694a2e4cda2" name="af495d1ed407458779abf8694a2e4cda2"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType *x, long Nx, long Ny, PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>, const PosType *center)</td></tr>
<tr class="memdesc:af495d1ed407458779abf8694a2e4cda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the nonsquare version of the function, it will return -1 is outside of region <br /></td></tr>
<tr class="separator:af495d1ed407458779abf8694a2e4cda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043901fd09c24707f46eb23b75548882" id="r_a043901fd09c24707f46eb23b75548882"><td class="memItemLeft" align="right" valign="top"><a id="a043901fd09c24707f46eb23b75548882" name="a043901fd09c24707f46eb23b75548882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PositionFromIndex</b> (unsigned long i, PosType *x, long Nx, long Ny, PosType <a class="el" href="#ae60664d77331b21da7b83e6e0cc0c75c">range</a>, PosType const *center)</td></tr>
<tr class="memdesc:a043901fd09c24707f46eb23b75548882"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square or rectangular regions as long as Npixels and range are the x-axis values and the pixels are square. <br /></td></tr>
<tr class="separator:a043901fd09c24707f46eb23b75548882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa9581800c9d5adc2444440dac76de955" id="r_aa9581800c9d5adc2444440dac76de955"><td class="memItemLeft" align="right" valign="top"><a id="aa9581800c9d5adc2444440dac76de955" name="aa9581800c9d5adc2444440dac76de955"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>nXbin</b> =64.</td></tr>
<tr class="separator:aa9581800c9d5adc2444440dac76de955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><ul>
<li></li>
</ul>
<p>The <a class="el" href="namespace_utilities.html">Utilities</a> namespace contains functions for wide use in many classes that perform generic tasks.</p>
<p>structure to construct, hold and destruct image and source points</p>
<ul>
<li>\ingEinstein_roup ChangeLens</li>
<li>\ingEinstein_roup ChangeLens</li>
<li>orders points in a curve, separates disconnected curves curves[0...Maxcurves] must be allocated before</li>
</ul>
<p>uses neighbors-of-neighbors to split into curves and then uses sorts by angle and then walks the ist sorting</p>
<p>can break down for crescent curves</p>
<p>The two functions below are inverses of each other for converting between a 1d array index and a square grid of positions Npixels in the number of point is 1 dimension index is between 0 and Npixels*Npixels-1 If x is outside of the region -1 is returned. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3735cfea92026435e078b653adb29782" name="a3735cfea92026435e078b653adb29782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3735cfea92026435e078b653adb29782">&#9670;&#160;</a></span>AdaptiveSmooth()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::valarray&lt; T &gt; Utilities::AdaptiveSmooth </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. </p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done. </p>

</div>
</div>
<a id="a6d17c2495bead70b18b91c376c28c051" name="a6d17c2495bead70b18b91c376c28c051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d17c2495bead70b18b91c376c28c051">&#9670;&#160;</a></span>concave()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::concave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>init_points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>hull_out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm. </p>
<p>The type of the input vector points must have an operator []. If the input vector is the same as the output vector it will be replaced, and the function will still work.</p>
<p>It is guaranteed that the resulting hull will surround the all the points. Any edge that is greater than scale will be refined until it is either smaller than scale or it cannot be refined further. As a result some edges might be larger than scale and some smaller.</p>
<p>This should be a NlogN algorithm.</p>
<p>The algorithm: 1) The convex hull is found. 2) The longest edge is found 3) all the points that are not in the hull are tested to see if they are within the rays extending from the end point perpendicular to the edge. 4) Of the points that are the one that makes the smallest area triangle with the end points is chosen and added 5) go back to 3 if there are edges that are larger than scale and new points exist to be added 6) remove all intersections in the hull </p>

</div>
</div>
<a id="afadfff44acbcae923eac1bec385ae6e4" name="afadfff44acbcae923eac1bec385ae6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadfff44acbcae923eac1bec385ae6e4">&#9670;&#160;</a></span>concave_hull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered.</p>
<p>This is an overloaded version of the other <a class="el" href="#aca82634714ad53172788a38cef165b07" title="Returns a vector of points on the convcave hull in counter-clockwise order.">concave_hull()</a> </p>

</div>
</div>
<a id="aca82634714ad53172788a38cef165b07" name="aca82634714ad53172788a38cef165b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca82634714ad53172788a38cef165b07">&#9670;&#160;</a></span>concave_hull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>test</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered. </p>

</div>
</div>
<a id="abe345295eb171c0665350842426124bd" name="abe345295eb171c0665350842426124bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe345295eb171c0665350842426124bd">&#9670;&#160;</a></span>concaveK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ptype &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Ptype &gt; Utilities::concaveK </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Ptype &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>check</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>will be added back later</p>

</div>
</div>
<a id="a512d73667d76a5a58e44042a4a73c974" name="a512d73667d76a5a58e44042a4a73c974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512d73667d76a5a58e44042a4a73c974">&#9670;&#160;</a></span>contour_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point__2d.html">Point_2d</a> Utilities::contour_center </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. </p>
<p>The performance of the algorithm is ~O(N^2). Less naive methods go like O(N) at best. Most commonly a combined convex hull plus rotating calipers algorithm is used. Since we have the convex_hull already, we only need to implement the latter algorithm. </p>

</div>
</div>
<a id="ac71ef3b7c0383a2ca61eb5d479d8490d" name="ac71ef3b7c0383a2ca61eb5d479d8490d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71ef3b7c0383a2ca61eb5d479d8490d">&#9670;&#160;</a></span>contour_ellipse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::contour_ellipse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>ellipticity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>ellipse_area</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour). </p>
<p>The axis ratio of the ellipse b/a is equal to the ratio of the distances between center and the nearest contour point (i.e. b) and between center and the farthest contour point (i.e. a). NOTE that the center used to calculate a and b is an input parameter. The definition of the center is crucial to the meaning of above output parameters. The center of the convex_hull produces for even slightly distorted hulls significant offsets resulting in overestimated major axis values (a). The function <a class="el" href="#a512d73667d76a5a58e44042a4a73c974" title="Returns the center of a contour defined as the midpoint between the two points in the contour that ar...">Utilities::contour_center()</a> calculates the center as the midpoint between the two points in the contour that are farthest apart from one another, which gives already more reliable results. The output vector describing the ellipse is resized to match the size of the contour vector. </p>

</div>
</div>
<a id="a181252f6287df861af9107445a4cac7f" name="a181252f6287df861af9107445a4cac7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181252f6287df861af9107445a4cac7f">&#9670;&#160;</a></span>convex_hull()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::convex_hull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>P</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>hull</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of points on the convex hull in counter-clockwise order. </p>

</div>
</div>
<a id="a865c4f1f38a91d8b3d4e07fdfea16bd0" name="a865c4f1f38a91d8b3d4e07fdfea16bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865c4f1f38a91d8b3d4e07fdfea16bd0">&#9670;&#160;</a></span>ConvexHullArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::ConvexHullArea </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>curve</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces curve with its convex hull. The number of points will change. </p>
<p>gives the area within the convex hull of the curve </p>

</div>
</div>
<a id="a484765a953bdbceb52b23f6790d59cf2" name="a484765a953bdbceb52b23f6790d59cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484765a953bdbceb52b23f6790d59cf2">&#9670;&#160;</a></span>double_sort_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::double_sort_points </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>arr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>brr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts points in a point array. </p>
<p>arr array uses NR standard indexing i.e arr[1...n] but brr[0..n-1] if the point array is two-way-coupled to another point array the image pointers of that array will follow sort if the array is not two-way-coupled to another the image pointers in the other array will be untouched </p>

</div>
</div>
<a id="a6b3b3327085b03c3dcbb1afadd59fcd4" name="a6b3b3327085b03c3dcbb1afadd59fcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3b3327085b03c3dcbb1afadd59fcd4">&#9670;&#160;</a></span>envelope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; Utilities::envelope </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. </p>
<p>v and w can be non-self intersecting If they do not intersect and one is not inside the other an empty vector is returned.</p>
<p>Unlike <code><a class="el" href="#a6b3b3327085b03c3dcbb1afadd59fcd4" title="Find a curve that is made up of segments from v and w that surrounds them and does not self intersect...">Utilities::envelope()</a></code>, this algorithm is pretty foolproof. It uses the same concept as <code><a class="el" href="#ac6c2b9ec5013e30e7b10d2ba8279e91e" title="Finds a concave envolope for an arbitrary closed curve. This is done by gridding and then finding poi...">Utilities::TightestHull()</a></code>. There may be small segements that are not in either curve, but they should increase the area be a small fraction. </p>

</div>
</div>
<a id="a8baf3c89ecca31f0771e2d781a856f20" name="a8baf3c89ecca31f0771e2d781a856f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baf3c89ecca31f0771e2d781a856f20">&#9670;&#160;</a></span>envelope2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; Utilities::envelope2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>w</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. </p>
<p>v and w must be non-self intersecting If they do not intersect and one is not inside the other an empty vector is returned </p>

</div>
</div>
<a id="a380f0a954728d751781e61918facba0e" name="a380f0a954728d751781e61918facba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380f0a954728d751781e61918facba0e">&#9670;&#160;</a></span>fill_linear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::fill_linear </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector with equidistant points from [min, max]. </p>

</div>
</div>
<a id="a47aedfd83edf6f6637cc03da5413e94a" name="a47aedfd83edf6f6637cc03da5413e94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aedfd83edf6f6637cc03da5413e94a">&#9670;&#160;</a></span>fill_logarithmic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::fill_logarithmic </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>min</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>max</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector with logarithmically equidistant points from [min, max]. </p>

</div>
</div>
<a id="a3ded74005933c13892203f9ad15cdbb0" name="a3ded74005933c13892203f9ad15cdbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ded74005933c13892203f9ad15cdbb0">&#9670;&#160;</a></span>find_boundaries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::find_boundaries </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bitmap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; P &gt; &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>hits_edge</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>add_to_vector</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>outer_only</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds ordered boundaries to regions where bitmap == true </p>
<p>This can be used to find critical curves or contours. If the boundary curve touches the edge of the <code>bitmap</code> it will be indicated in <code>hits_boundary</code> as <code>true</code>.</p>
<p>Boundaries will never cross or lead off the grid. <br  />
 On the edges they will leave the edge pixels out even if they should be in. This is a technical compromise.</p>
<p>Output points are in pixel units with (0,0) being point (0,0) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer_only</td><td>finds only the fist boundary which will be the outer one if there are not seporated islands </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5c6f9e86e55bf8ac250ed8a2849ba3e" name="af5c6f9e86e55bf8ac250ed8a2849ba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c6f9e86e55bf8ac250ed8a2849ba3e">&#9670;&#160;</a></span>InterpolateYvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::InterpolateYvec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>xi</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate (cubic interpolation) the value of a function <picture><source srcset="form_6_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$ y=y(x) $" src="form_6.png" width="0" height="14"/></picture> given xi </p>

</div>
</div>
<a id="acc053736fab41bd2807991e8dfcab129" name="acc053736fab41bd2807991e8dfcab129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc053736fab41bd2807991e8dfcab129">&#9670;&#160;</a></span>locate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>sorted_index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;</td>          <td class="paramname"><span class="paramname"><em>rank</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the element of a vector given a sorted index of the vector. </p>
<p>The vector v does not need to be sorted, but the index does with Utiltites::sort_index(), Utilities::sort_index_decending() or in some other way.</p>
<p>returns the index of v that is the largest value that is &lt;= value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to search, does not need to be sorted  </td></tr>
    <tr><td class="paramname">sorted_index</td><td>sorted index for v, could be assending or decending  </td></tr>
    <tr><td class="paramname">value</td><td>value to be matched  </td></tr>
    <tr><td class="paramname">rank</td><td>index in sorted_index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a929db80c547c245b0d2c2703f33ff85e" name="a929db80c547c245b0d2c2703f33ff85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a929db80c547c245b0d2c2703f33ff85e">&#9670;&#160;</a></span>locate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -1 or n-1. </p>

</div>
</div>
<a id="ab7663a1f094849a77cab564e61fcca49" name="ab7663a1f094849a77cab564e61fcca49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7663a1f094849a77cab564e61fcca49">&#9670;&#160;</a></span>locate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(F, const T &amp;)&gt;</td>          <td class="paramname"><span class="paramname"><em>less_than</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -1 or n-1. </p>

</div>
</div>
<a id="afb7f32cbe2c0f17c06a106dee6726e98" name="afb7f32cbe2c0f17c06a106dee6726e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f32cbe2c0f17c06a106dee6726e98">&#9670;&#160;</a></span>nintegrateF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorType , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::nintegrateF </td>
          <td>(</td>
          <td class="paramtype">FunctorType</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T</td>          <td class="paramname"><span class="paramname"><em>tols</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>struct or class to be integrated  </td></tr>
    <tr><td class="paramname">a</td><td>limit of integrations  </td></tr>
    <tr><td class="paramname">b</td><td>limit of integrations  </td></tr>
    <tr><td class="paramname">tols</td><td>target fractional error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2fb3cc522fc36c51e33bccac70089c7" name="af2fb3cc522fc36c51e33bccac70089c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fb3cc522fc36c51e33bccac70089c7">&#9670;&#160;</a></span>order_curve4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::order_curve4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>curve</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns 1 if it is in the curve and 0 if it is out. Borders count as in. </p>
<p>Orders points on a closed curve.</p>
<p>returns 1 if it is in the curve and 0 if it is out. Borders count as in. returns 1 if it is in the curve and 0 if it is out. Borders count as in.</p>
<p>The algorithm first finds the "center" of the curve. It then does a rough ordering according to the angle around this center. It then walks the curve jumping to a neighbor cell each step choosing a neighbor along one of the x or y-axis before taking a diagonal step. If it comes to the point where there is no more neighbors (as may occur after going through a self-intersection and then returning to it) the algorithm backtracks until it finds a point in the ordered list that is also a neighbor to a point in the not yet ordered list and attaches this to the end of the ordered list and continuous to walk. This algorithm works well at finding a closed loop. It can cut off points from the curve that are either in loops or if four cells intersect and are all on the curve as can happen when there is a lot of structure in the curve that is not resolved at the gridsize used. The points that are cut off are at the end of the array in no guaranteed order.</p>
<p>Returns the number of point that have been ordered - total number minus the cuttout points.</p>
<p>This algorithm could be improve by inserting the remaining points, if any, into the existing curve and recursively calling itself. </p>

</div>
</div>
<a id="ad8293f72cb05db408c84e3d101a56e41" name="ad8293f72cb05db408c84e3d101a56e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8293f72cb05db408c84e3d101a56e41">&#9670;&#160;</a></span>order_curve5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::order_curve5 </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>curve</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For odering the curve by the convex hull method. Warning: Does not work very well. </p>
<p>The convex hull is found for the points in the kist. Then each additional point is inserted into the curve where it will increase the length of the curve the least. This method leaves loops where they shouldn't be and probably doesn't handle self-intersections well. </p>

</div>
</div>
<a id="a1da3b0a449dad814f7c6c804fc323a4d" name="a1da3b0a449dad814f7c6c804fc323a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da3b0a449dad814f7c6c804fc323a4d">&#9670;&#160;</a></span>powerspectrum2d() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2d </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a586082194e51dc17b62453f79b012310" name="a586082194e51dc17b62453f79b012310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586082194e51dc17b62453f79b012310">&#9670;&#160;</a></span>powerspectrum2d() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2d </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; double &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; double &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>zeropaddingfactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates power spectrum from a 2d map or the cross-power spectrum between two 2d maps. </p>
<p>Adapted from Carlo Giocoli's pl() routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">bb</td><td>second realspace map, same as aa to get power spectrum  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ee3342e8438958ee6d2befb1d239f7c" name="a8ee3342e8438958ee6d2befb1d239f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee3342e8438958ee6d2befb1d239f7c">&#9670;&#160;</a></span>powerspectrum2d() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2d </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae84841923bdfd928af1928c94464313" name="aae84841923bdfd928af1928c94464313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae84841923bdfd928af1928c94464313">&#9670;&#160;</a></span>powerspectrum2d() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2d </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; float &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::valarray&lt; float &gt; const &amp;</td>          <td class="paramname"><span class="paramname"><em>bb</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>zeropaddingfactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">bb</td><td>second realspace map, same as aa to get power spectrum  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbf9204e09d3023ddd66cf4a3d440181" name="adbf9204e09d3023ddd66cf4a3d440181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf9204e09d3023ddd66cf4a3d440181">&#9670;&#160;</a></span>powerspectrum2dprebin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2dprebin </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>llave</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum  </td></tr>
    <tr><td class="paramname">llave</td><td>average value of Fourier node in bins </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a604490c5c8fae106fff74568d9706f93" name="a604490c5c8fae106fff74568d9706f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604490c5c8fae106fff74568d9706f93">&#9670;&#160;</a></span>powerspectrum2dprebin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::powerspectrum2dprebin </td>
          <td>(</td>
          <td class="paramtype">std::valarray&lt; float &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>aa</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxlx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>boxly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ll</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>Pl</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>llave</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aa</td><td>first realspace map to be  </td></tr>
    <tr><td class="paramname">nx</td><td>number of pixels in x direction  </td></tr>
    <tr><td class="paramname">ny</td><td>number of pixels in y direction  </td></tr>
    <tr><td class="paramname">boxlx</td><td>range of image in x direction  </td></tr>
    <tr><td class="paramname">boxly</td><td>range of image in y direction  </td></tr>
    <tr><td class="paramname">ll</td><td>output multiplot number of bins  </td></tr>
    <tr><td class="paramname">Pl</td><td>output binned power spectrum  </td></tr>
    <tr><td class="paramname">llave</td><td>average value of Fourier node in bins </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe61342a713adf7115f351e3342a2b79" name="abe61342a713adf7115f351e3342a2b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe61342a713adf7115f351e3342a2b79">&#9670;&#160;</a></span>prevpower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::prevpower </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>k</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finds the largest power of 2 that is &lt; k </p>

</div>
</div>
<a id="ac980fbca67c1ca7531d28e98433e669a" name="ac980fbca67c1ca7531d28e98433e669a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980fbca67c1ca7531d28e98433e669a">&#9670;&#160;</a></span>quicksortPoints_multithread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int lev&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::quicksortPoints_multithread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>pointarray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*</td>          <td class="paramname"><span class="paramname"><em>func&#160;</em></span>)(<a class="el" href="struct_point.html">Point</a> &amp;), </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>level</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. </p>
<p>This function is different from <a class="el" href="#ac7ddbf6268cb6f39b3e6d1b046ff1a48" title="Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function func takes a T ty...">quicksort_multithread()</a> in that it uses SwapPointsInArray() instead of std::swap() which is needed to make the image pointers follow the swap. </p>

</div>
</div>
<a id="a0855636bdb71f103a4412555b9711e98" name="a0855636bdb71f103a4412555b9711e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0855636bdb71f103a4412555b9711e98">&#9670;&#160;</a></span>RandomFromTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::RandomFromTable </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>table</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Ntable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table. </p>
<p>\ingEinstein_roup Utill  </p>

</div>
</div>
<a id="abc7be26dfecdca30048dd4d3842077a2" name="abc7be26dfecdca30048dd4d3842077a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7be26dfecdca30048dd4d3842077a2">&#9670;&#160;</a></span>ReadFileNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::ReadFileNames </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>filespec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>filenames</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string</td>          <td class="paramname"><span class="paramname"><em>file_non_spec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the fits files in a directory into a vector of PixelMaps. </p>
<p>The input fits files must have .fits in their names in addition to the string filespec.</p>
<p>void Utilities::LoadFitsImages( std::string dir /// path to directory containing fits files ,const std::string&amp; filespec /// string of charactors in fits file name that are matched ,std::vector&lt;PixelMap&gt; &amp; images /// output vector of PixelMaps ,int maxN /// maximum number of images that will be read in ,double resolution /// resolution (rad) of fits image if not given in fits file, use default or -1 otherwise ,bool verbose /// lists files to stdout ){</p>
<p>DIR *dp = opendir( dir.c_str() ); struct dirent *dirp; struct stat filestat; std::string filepath,filename; size_t count = 0;</p>
<p>if (dp == NULL) { throw std::runtime_error("error opening directory"); return; }</p>
<p>while ((dirp = readdir( dp )) &amp;&amp; count &lt; maxN) { filepath = dir + "/" + dirp-&gt;d_name;</p>
<p>If the file is a directory (or is in some way invalid) we'll skip it if (stat( filepath.c_str(), &amp;filestat )) continue; if (S_ISDIR( filestat.st_mode )) continue;</p>
<p>filename = dirp-&gt;d_name; if(filename.find(".fits") != std::string::npos){ if(filename.find(filespec) != std::string::npos){ if(verbose) std::cout &lt;&lt; "reading " &lt;&lt; filepath &lt;&lt; std::endl; <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> map(filepath,resolution); images.push_back(std::move(map)); images.push_back(PixelMap(filepath,resolution)); ++count; } } }</p>
<p>closedir( dp );</p>
<p>std::cout &lt;&lt; count &lt;&lt; " fits files read." &lt;&lt; std::endl; return ; }</p>
<p>Reads all the fits files in a directory into a vector of PixelMaps.</p>
<p>The input fits files must have .fits in their names in addition to the string filespec.</p>
<p>void Utilities::LoadFitsImages( std::string dir /// path to directory containing fits files ,std::vector&lt;std::string&gt; filespecs /// string of charactors in fits file name that are matched ,std::vector&lt;std::string&gt; file_non_specs /// string of charactors in fits file name cannot have ,std::vector&lt;PixelMap&gt; &amp; images /// output vector of PixelMaps ,std::vector&lt;std::string&gt; &amp; names /// file names ,int maxN /// maximum number of images that will be read in ,double resolution /// resolution (rad) of fits image if not given in fits file, use default or -1 otherwise ,bool verbose /// lists files to stdout ){</p>
<p>DIR *dp = opendir( dir.c_str() ); struct dirent *dirp; struct stat filestat; std::string filepath,filename; size_t count = 0;</p>
<p>if (dp == NULL) { throw std::runtime_error("error opening directory"); return; }</p>
<p>while ((dirp = readdir( dp )) &amp;&amp; count &lt; maxN) { filepath = dir + "/" + dirp-&gt;d_name;</p>
<p>If the file is a directory (or is in some way invalid) we'll skip it if (stat( filepath.c_str(), &amp;filestat )) continue; if (S_ISDIR( filestat.st_mode )) continue;</p>
<p>filename = dirp-&gt;d_name; if(filename.find(".fits") != std::string::npos){ bool read =true; for(int i=0;i&lt;filespecs.size();++i) if(filename.find(filespecs[i]) == std::string::npos) read = false; for(int i=0;i&lt;file_non_specs.size();++i) if(filename.find(file_non_specs[i]) != std::string::npos) read = false;</p>
<p>if(read){ if(verbose) std::cout &lt;&lt; "reading " &lt;&lt; filepath &lt;&lt; std::endl; <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> map(filepath,resolution); images.push_back(std::move(map)); images.push_back(PixelMap(filepath,resolution)); names.push_back(filepath); ++count; } } }</p>
<p>closedir( dp );</p>
<p>std::cout &lt;&lt; count &lt;&lt; " fits files read." &lt;&lt; std::endl; return ; } </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files  </td></tr>
    <tr><td class="paramname">filespec</td><td>string of charactors in file name that are matched. It can be an empty string.  </td></tr>
    <tr><td class="paramname">filenames</td><td>output vector of PixelMaps  </td></tr>
    <tr><td class="paramname">file_non_spec</td><td>string of charactors in file name that file must not have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9906f7f742a4940019f2a58cabdb05c" name="aa9906f7f742a4940019f2a58cabdb05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9906f7f742a4940019f2a58cabdb05c">&#9670;&#160;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::shuffle </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>vec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;</td>          <td class="paramname"><span class="paramname"><em>ran</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles a vector into a random order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to be shuffled  </td></tr>
    <tr><td class="paramname">ran</td><td>a random number generator so that ran() gives a number between 0 and 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b44ff17b26b627e429e9984d4908577" name="a9b44ff17b26b627e429e9984d4908577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b44ff17b26b627e429e9984d4908577">&#9670;&#160;</a></span>sort_indexes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in asending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed  </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357b69312972120ce046eff265e6b581" name="a357b69312972120ce046eff265e6b581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b69312972120ce046eff265e6b581">&#9670;&#160;</a></span>sort_indexes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const T *</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed  </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec9c85bddb9c124c7df2bc04fbf350fe" name="aec9c85bddb9c124c7df2bc04fbf350fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9c85bddb9c124c7df2bc04fbf350fe">&#9670;&#160;</a></span>sort_indexes_decending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes_decending </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed  </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8de229537fd082d389db103bd918160a" name="a8de229537fd082d389db103bd918160a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de229537fd082d389db103bd918160a">&#9670;&#160;</a></span>thicken_poly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &gt; Utilities::thicken_poly </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>R</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the boundaries of the region that is within R of the curve v </p>
<p>If the radius R is small compared to the dimenstions of the polygon an approximation is make to save time in which parallel segments to each side of the polygon are used.</p>
<p>If the radius R is not small a gridding method is used which is more reliable. </p>

</div>
</div>
<a id="a7f2aed1fb05038e399bf1287d64b56ec" name="a7f2aed1fb05038e399bf1287d64b56ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f2aed1fb05038e399bf1287d64b56ec">&#9670;&#160;</a></span>TighterHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; Utilities::TighterHull </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>v</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>removes the intersections while removing interior loops The input curve needs to be ordered already. No points in the input curve will be outside the output hull. Will fail if there are overlapping segments on the hull. </p>

</div>
</div>
<a id="a2d063fcd59fdf742b8cbf0c57ef29104" name="a2d063fcd59fdf742b8cbf0c57ef29104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d063fcd59fdf742b8cbf0c57ef29104">&#9670;&#160;</a></span>TwoDInterpolator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::TwoDInterpolator </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>Npixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>init</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bilinear interpolation from a map. </p>
<p>Out of bounds points return 0. map is a i dimensional array representing a 2 dimensional map. Don't use init. After it is used once, later calls can use TwoDInterpolator(PosType *map) for the same point in the same coordinate system to save time in calculating the indexes. </p>
<p>bilinear interpolation</p>
<p>bilinear interpolation</p>

</div>
</div>
<a id="a09f4dcf28911d550c9bd20eeba202f5f" name="a09f4dcf28911d550c9bd20eeba202f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f4dcf28911d550c9bd20eeba202f5f">&#9670;&#160;</a></span>windings() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">point</td><td>The points on the border. These must be ordered.  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc8d337b886b466535a29068af0b4994" name="afc8d337b886b466535a29068af0b4994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc8d337b886b466535a29068af0b4994">&#9670;&#160;</a></span>windings() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">point</td><td>The points on the border. Uses image plane points  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7db30634cbf18e1652cd2a9ec7f95aa" name="aa7db30634cbf18e1652cd2a9ec7f95aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db30634cbf18e1652cd2a9ec7f95aa">&#9670;&#160;</a></span>windings() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>kist</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>image</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">kist</td><td>Kist of points on the border. These must be ordered.  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border  </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad964e6781b61f0d76240eda24a4f9ffa" name="ad964e6781b61f0d76240eda24a4f9ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad964e6781b61f0d76240eda24a4f9ffa">&#9670;&#160;</a></span>windings() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> **</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>image</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">points</td><td>The points on the border. These must be ordered.  </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border  </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac42846299720c47decf597f70d448464" name="ac42846299720c47decf597f70d448464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42846299720c47decf597f70d448464">&#9670;&#160;</a></span>windings() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>points</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>image</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="#ac42846299720c47decf597f70d448464" title="windings(): winding number test for a point in a polygon Returns: Number of times a curves winds arou...">windings()</a>: winding number test for a point in a polygon Returns: Number of times a curves winds around the point x. </p>
<p>The number of times the curve loops around a point is calculated.</p>
<p>The area of a self-intersecting curve will be the area of the regions encircled in a clockwise direction minus the regions encircled in a counterclockwise direction - an infinity symbol has zero area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">points</td><td>The points on the border. These must be ordered.  </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border  </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70de03dea8a3f77f15fd209a783a8065" name="a70de03dea8a3f77f15fd209a783a8065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70de03dea8a3f77f15fd209a783a8065">&#9670;&#160;</a></span>windings2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings2 </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>points_original</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Npoints</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>area</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short</td>          <td class="paramname"><span class="paramname"><em>image</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines whether a point is inside a curve, that has been stretched 1.2 times returns the area of the stretched curve </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated  </td></tr>
    <tr><td class="paramname">points_original</td><td>The points on the border. These must be ordered.  </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve  </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border  </td></tr>
    <tr><td class="paramname">image</td><td>if == 0 the image of the curve is used as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7771b5ff9b3034f364adcee471cb754d" name="a7771b5ff9b3034f364adcee471cb754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771b5ff9b3034f364adcee471cb754d">&#9670;&#160;</a></span>writeCurves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::writeCurves </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *</td>          <td class="paramname"><span class="paramname"><em>critical</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>Ncrit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>ind_caustic</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>writes in four files the critical curves and the caustics for all the curves found and also for a specified one (ind_causic) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>part of te filename, could be the number/index of the main lens  </td></tr>
    <tr><td class="paramname">critical</td><td>the crit curve  </td></tr>
    <tr><td class="paramname">Ncrit</td><td>the number of crit curves  </td></tr>
    <tr><td class="paramname">ind_caustic</td><td>the index of the cuvre of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 8 2024 19:31:04 for GLAMERDOC++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
