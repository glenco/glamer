<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLAMERDOC++: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference<div class="ingroups"><a class="el" href="group___utill.html">Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>convert a Band type to a string name.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_utilities_1_1_geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities_1_1_geometry.html">Geometry</a></td></tr>
<tr class="memdesc:namespace_utilities_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for geometrical functions mostly having to do with spherical coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d2_matrix.html">D2Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 dimensional matrix  <a href="class_utilities_1_1_d2_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d3_matrix.html">D3Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 dimensional matrix, fixed size  <a href="class_utilities_1_1_d3_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_hilbert_curve.html">HilbertCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for calculating the Hilbert curve distance in two dimensions.  <a href="class_utilities_1_1_hilbert_curve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_interpolator.html">Interpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear interpolation class for interpolating from a 2D uniform grid.  <a href="class_utilities_1_1_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector.html">MixedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that can hold mixed objects all derived from a base class and retains the ability to access derived class functions/members.  <a href="class_utilities_1_1_mixed_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html">MixedVector&lt; BaseT * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_utilities_1_1_mixed_vector.html" title="A container that can hold mixed objects all derived from a base class and retains the ability to acce...">MixedVector</a> for pointers.  <a href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_random_numbers___n_r.html">RandomNumbers_NR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class for generating random numbers. It simplifies and fool proofs initialization and allows for multiple independent series of numbers.  <a href="class_utilities_1_1_random_numbers___n_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a83d3f6d35f48dd5cf7ff992a6c36ee8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_date</b> ()</td></tr>
<tr class="separator:a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga380f0a954728d751781e61918facba0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga380f0a954728d751781e61918facba0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utill.html#ga380f0a954728d751781e61918facba0e">fill_linear</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:ga380f0a954728d751781e61918facba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utill.html#ga47aedfd83edf6f6637cc03da5413e94a">fill_logarithmic</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:ga47aedfd83edf6f6637cc03da5413e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ga7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memTemplItemLeft" align="right" valign="top">int long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utill.html#ga7bd6a986fd81b85b290cd9ab0034e3f8">locate</a> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="separator:ga7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf07d27fc678946de3bc659e5d7f9feda"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:gaf07d27fc678946de3bc659e5d7f9feda"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___utill.html#gaf07d27fc678946de3bc659e5d7f9feda">locate</a> (const std::vector&lt; T &gt; &amp;v, F x, std::function&lt; bool(F, const T &amp;)&gt; less_than)</td></tr>
<tr class="separator:gaf07d27fc678946de3bc659e5d7f9feda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplParams" colspan="2"><a class="anchor" id="a0cfb54fff515cfd5d684572962f50c66"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>locate</b> (T *v, unsigned long n, T x, unsigned long *index)</td></tr>
<tr class="separator:a0cfb54fff515cfd5d684572962f50c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa80185750e610681c64de174516f9799"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aa80185750e610681c64de174516f9799">closest</a> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="memdesc:aa80185750e610681c64de174516f9799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element of v that is closest to x. v must be sorted. <br /></td></tr>
<tr class="separator:aa80185750e610681c64de174516f9799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af5c6f9e86e55bf8ac250ed8a2849ba3e">InterpolateYvec</a> (std::vector&lt; PosType &gt; &amp;x, std::vector&lt; PosType &gt; &amp;y, PosType xi)</td></tr>
<tr class="separator:af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a49c02a235f698cf25dbc7edf34d4bf8f"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>arctanh</b> (PosType x)</td></tr>
<tr class="separator:a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473f872514990ed70931ddd9489301a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a473f872514990ed70931ddd9489301a7"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmini</b> (PosType a, PosType b)</td></tr>
<tr class="separator:a473f872514990ed70931ddd9489301a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99adc537b02f26073243f0d32376def"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af99adc537b02f26073243f0d32376def"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmaxi</b> (PosType a, PosType b)</td></tr>
<tr class="separator:af99adc537b02f26073243f0d32376def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9277fa3059d24e0c01845213a3947c36"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9277fa3059d24e0c01845213a3947c36"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>median</b> (std::vector&lt; PosType &gt; vec)</td></tr>
<tr class="separator:a9277fa3059d24e0c01845213a3947c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a85e6e176b88221d17c1a0d6c83a6846d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a85e6e176b88221d17c1a0d6c83a6846d">polintT</a> (T xa[], T ya[], int n, T x, T *y, T *dy)</td></tr>
<tr class="memdesc:a85e6e176b88221d17c1a0d6c83a6846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolation <br /></td></tr>
<tr class="separator:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7679e167450f3450c86c345cd8de373d"></a>
template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7679e167450f3450c86c345cd8de373d">trapz</a> (FunctorType &amp;func, T a, T b, int n, T *s2)</td></tr>
<tr class="memdesc:a7679e167450f3450c86c345cd8de373d"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in trapizoidal integral <br /></td></tr>
<tr class="separator:a7679e167450f3450c86c345cd8de373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplParams" colspan="2">template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afb7f32cbe2c0f17c06a106dee6726e98">nintegrateF</a> (FunctorType func, T a, T b, T tols)</td></tr>
<tr class="separator:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31db9f78433a6de800437aedfd1b2eb5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31db9f78433a6de800437aedfd1b2eb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a31db9f78433a6de800437aedfd1b2eb5">rotation</a> (float *xout, float *xin, PosType theta)</td></tr>
<tr class="memdesc:a31db9f78433a6de800437aedfd1b2eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a31db9f78433a6de800437aedfd1b2eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad140aa2e74c584b82ff6416ff16622"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8ad140aa2e74c584b82ff6416ff16622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a8ad140aa2e74c584b82ff6416ff16622">rotation</a> (PosType *xout, PosType const *xin, PosType theta)</td></tr>
<tr class="memdesc:a8ad140aa2e74c584b82ff6416ff16622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a8ad140aa2e74c584b82ff6416ff16622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0855636bdb71f103a4412555b9711e98"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a0855636bdb71f103a4412555b9711e98">RandomFromTable</a> (PosType *table, unsigned long Ntable, long *seed)</td></tr>
<tr class="memdesc:a0855636bdb71f103a4412555b9711e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table.  <a href="#a0855636bdb71f103a4412555b9711e98">More...</a><br /></td></tr>
<tr class="separator:a0855636bdb71f103a4412555b9711e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplParams" colspan="2"><a class="anchor" id="aae5ae9b5d81618c5ab06016357dc6c7d"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract</b> (T &amp;p1, P &amp;p2)</td></tr>
<tr class="separator:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplParams" colspan="2"><a class="anchor" id="a34ba39540d95cbeaa6a00631c640ca7f"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crossD</b> (P &amp;O, P &amp;A, P &amp;B)</td></tr>
<tr class="separator:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96"><td class="memTemplParams" colspan="2"><a class="anchor" id="a02302245829df0b35aca33fc6415cb96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a02302245829df0b35aca33fc6415cb96">RemoveIntersections</a> (std::vector&lt; T &gt; &amp;curve)</td></tr>
<tr class="memdesc:a02302245829df0b35aca33fc6415cb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the intersections of the curve <br /></td></tr>
<tr class="separator:a02302245829df0b35aca33fc6415cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dccd3d5a6b05220a4060b921cf318"><td class="memTemplParams" colspan="2"><a class="anchor" id="acd4dccd3d5a6b05220a4060b921cf318"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd4dccd3d5a6b05220a4060b921cf318"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#acd4dccd3d5a6b05220a4060b921cf318">convex_hull</a> (std::vector&lt; T &gt; &amp;P, std::vector&lt; T &gt; &amp;hull_out)</td></tr>
<tr class="memdesc:acd4dccd3d5a6b05220a4060b921cf318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:acd4dccd3d5a6b05220a4060b921cf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6d17c2495bead70b18b91c376c28c051">concave</a> (std::vector&lt; T &gt; &amp;init_points, std::vector&lt; T &gt; &amp;hull_out, double scale)</td></tr>
<tr class="memdesc:a6d17c2495bead70b18b91c376c28c051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm.  <a href="#a6d17c2495bead70b18b91c376c28c051">More...</a><br /></td></tr>
<tr class="separator:a6d17c2495bead70b18b91c376c28c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a74edb07bfa2d5cee2ef5450f0998ff57">LoadFitsImages</a> (std::string dir, const std::string &amp;filespec, std::vector&lt; <a class="el" href="class_pixel_map.html">PixelMap</a> &gt; &amp;images, int maxN, double resolution=-1, bool verbose=false)</td></tr>
<tr class="memdesc:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the fits files in a directory into a vector of PixelMaps.  <a href="#a74edb07bfa2d5cee2ef5450f0998ff57">More...</a><br /></td></tr>
<tr class="separator:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad3f190fa0f0cac4eb4b7c981d5131e5d">LoadFitsImages</a> (std::string dir, std::vector&lt; std::string &gt; filespecs, std::vector&lt; std::string &gt; file_non_specs, std::vector&lt; <a class="el" href="class_pixel_map.html">PixelMap</a> &gt; &amp;images, std::vector&lt; std::string &gt; &amp;names, int maxN, double resolution=-1, bool verbose=false)</td></tr>
<tr class="memdesc:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the fits files in a directory into a vector of PixelMaps.  <a href="#ad3f190fa0f0cac4eb4b7c981d5131e5d">More...</a><br /></td></tr>
<tr class="separator:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecac67b7051e410014dec29cc6721f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7ecac67b7051e410014dec29cc6721f4">ReadFileNames</a> (std::string dir, const std::string filespec, std::vector&lt; std::string &gt; &amp;filenames, bool verbose=false)</td></tr>
<tr class="memdesc:a7ecac67b7051e410014dec29cc6721f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the file names in a directory that contain a specific sub string.  <a href="#a7ecac67b7051e410014dec29cc6721f4">More...</a><br /></td></tr>
<tr class="separator:a7ecac67b7051e410014dec29cc6721f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99eb78332b2d654761336b8ecbde2da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab99eb78332b2d654761336b8ecbde2da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const Band &amp;band)</td></tr>
<tr class="separator:ab99eb78332b2d654761336b8ecbde2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1ce4c9e1180dd33a9f4c0c416643a9e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af1ce4c9e1180dd33a9f4c0c416643a9e">sepSQR</a> (PosType *xx, PosType *yy)</td></tr>
<tr class="memdesc:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separation squared between two positions in 2 dimensions. <br /></td></tr>
<tr class="separator:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c5422e8b232b598bfdf69131a7a41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a367c5422e8b232b598bfdf69131a7a41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>double_sort</b> (unsigned long n, PosType *arr, unsigned long *brr)</td></tr>
<tr class="separator:a367c5422e8b232b598bfdf69131a7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484765a953bdbceb52b23f6790d59cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a484765a953bdbceb52b23f6790d59cf2">double_sort_points</a> (unsigned long n, PosType *arr, <a class="el" href="struct_point.html">Point</a> *brr)</td></tr>
<tr class="memdesc:a484765a953bdbceb52b23f6790d59cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points in a point array.  <a href="#a484765a953bdbceb52b23f6790d59cf2">More...</a><br /></td></tr>
<tr class="separator:a484765a953bdbceb52b23f6790d59cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069e88bf3ba4576f526f75cd607954d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga069e88bf3ba4576f526f75cd607954d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#ga069e88bf3ba4576f526f75cd607954d4">quicksortPoints</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N)</td></tr>
<tr class="memdesc:ga069e88bf3ba4576f526f75cd607954d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points from smallest to largest according to the value of arr[]. Sorts arr[] and pointarray[] simultaneously. <br /></td></tr>
<tr class="separator:ga069e88bf3ba4576f526f75cd607954d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0f971972428328fbfecb023efa932b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe0f971972428328fbfecb023efa932b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksortPoints</b> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N)</td></tr>
<tr class="separator:afe0f971972428328fbfecb023efa932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0c3070a8f69f72a2f32a39f17ca277"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acf0c3070a8f69f72a2f32a39f17ca277"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksort</b> (unsigned long *particles, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:acf0c3070a8f69f72a2f32a39f17ca277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e7113bef6d90e6e85d0b25eaf06c93"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9e7113bef6d90e6e85d0b25eaf06c93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartition</b> (PosType pivotvalue, unsigned long *pivotindex, unsigned long *particles, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:ae9e7113bef6d90e6e85d0b25eaf06c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16748f779b70435ba98cef668ba62ac4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a16748f779b70435ba98cef668ba62ac4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartitionPoints</b> (PosType pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointsarray, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:a16748f779b70435ba98cef668ba62ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb92660db855441bddb128d39fb968b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cb92660db855441bddb128d39fb968b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartitionPoints</b> (PosType pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointarray, PosType(*func)(<a class="el" href="struct_point.html">Point</a> &amp;p), unsigned long N)</td></tr>
<tr class="separator:a9cb92660db855441bddb128d39fb968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426aa442b7ce674af0bc9ebb5eadedef"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a426aa442b7ce674af0bc9ebb5eadedef"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cutbox</b> (const PosType *center, PosType *p1, PosType *p2, float rmax)</td></tr>
<tr class="separator:a426aa442b7ce674af0bc9ebb5eadedef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f4aebc622ae58090979fda604d1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a606f4aebc622ae58090979fda604d1fc">log_polar_grid</a> (<a class="el" href="struct_point.html">Point</a> *i_points, PosType rmax, PosType rmin, PosType *center, long Ngrid)</td></tr>
<tr class="separator:a606f4aebc622ae58090979fda604d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5dac005305573c90d3c46db67967a0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c5dac005305573c90d3c46db67967a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findarea</b> (<a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo)</td></tr>
<tr class="separator:a7c5dac005305573c90d3c46db67967a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771b5ff9b3034f364adcee471cb754d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7771b5ff9b3034f364adcee471cb754d">writeCurves</a> (int m, <a class="el" href="struct_image_info.html">ImageInfo</a> *critical, int Ncrit, int index)</td></tr>
<tr class="separator:a7771b5ff9b3034f364adcee471cb754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66dea830e7b8f4390339d39eca8af68"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac66dea830e7b8f4390339d39eca8af68"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="struct_point.html">Point</a> *O, const <a class="el" href="struct_point.html">Point</a> *A, const <a class="el" href="struct_point.html">Point</a> *B)</td></tr>
<tr class="separator:ac66dea830e7b8f4390339d39eca8af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b802d503f1acd2f3d92eb903b9228"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac42b802d503f1acd2f3d92eb903b9228"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:ac42b802d503f1acd2f3d92eb903b9228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff8c370817f6c178c77b361cca0292"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a62ff8c370817f6c178c77b361cca0292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:a62ff8c370817f6c178c77b361cca0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6171a36bf18a88838285e19f90d63"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afbe6171a36bf18a88838285e19f90d63"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (const double *O, const double *A, const double *B)</td></tr>
<tr class="separator:afbe6171a36bf18a88838285e19f90d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c604b536630835c839b7975028165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab84c604b536630835c839b7975028165"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;O, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;A, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;B)</td></tr>
<tr class="separator:ab84c604b536630835c839b7975028165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6997f6bfc95f466039c9652c6c50274f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6997f6bfc95f466039c9652c6c50274f"></a>
std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6997f6bfc95f466039c9652c6c50274f">convex_hull</a> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P)</td></tr>
<tr class="memdesc:a6997f6bfc95f466039c9652c6c50274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a6997f6bfc95f466039c9652c6c50274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0699a4c75e3899f853dee3fe6a442a25"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0699a4c75e3899f853dee3fe6a442a25"></a>
std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a0699a4c75e3899f853dee3fe6a442a25">convex_hull</a> (std::vector&lt; double * &gt; &amp;P)</td></tr>
<tr class="memdesc:a0699a4c75e3899f853dee3fe6a442a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a0699a4c75e3899f853dee3fe6a442a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82634714ad53172788a38cef165b07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aca82634714ad53172788a38cef165b07">concave_hull</a> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P, int k, bool test=false)</td></tr>
<tr class="memdesc:aca82634714ad53172788a38cef165b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <a href="#aca82634714ad53172788a38cef165b07">More...</a><br /></td></tr>
<tr class="separator:aca82634714ad53172788a38cef165b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadfff44acbcae923eac1bec385ae6e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afadfff44acbcae923eac1bec385ae6e4">concave_hull</a> (std::vector&lt; double * &gt; &amp;P, int k)</td></tr>
<tr class="memdesc:afadfff44acbcae923eac1bec385ae6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <a href="#afadfff44acbcae923eac1bec385ae6e4">More...</a><br /></td></tr>
<tr class="separator:afadfff44acbcae923eac1bec385ae6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac71ef3b7c0383a2ca61eb5d479d8490d">contour_ellipse</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, <a class="el" href="struct_point__2d.html">Point_2d</a> center, unsigned long Npoints, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;C, double *ellipticity, double *ellipse_area)</td></tr>
<tr class="memdesc:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour).  <a href="#ac71ef3b7c0383a2ca61eb5d479d8490d">More...</a><br /></td></tr>
<tr class="separator:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d73667d76a5a58e44042a4a73c974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a512d73667d76a5a58e44042a4a73c974">contour_center</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, unsigned long Npoints)</td></tr>
<tr class="memdesc:a512d73667d76a5a58e44042a4a73c974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another.  <a href="#a512d73667d76a5a58e44042a4a73c974">More...</a><br /></td></tr>
<tr class="separator:a512d73667d76a5a58e44042a4a73c974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa727547d253bdbd88ac47cae3f7c65c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa727547d253bdbd88ac47cae3f7c65c4"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType *x, long Npixels, PosType range, const PosType *center)</td></tr>
<tr class="separator:aa727547d253bdbd88ac47cae3f7c65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68bfc533f3ce300625ec2b97073800"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa68bfc533f3ce300625ec2b97073800"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afa68bfc533f3ce300625ec2b97073800">PositionFromIndex</a> (unsigned long i, PosType *x, long Npixels, PosType range, PosType const *center)</td></tr>
<tr class="memdesc:afa68bfc533f3ce300625ec2b97073800"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square regions. <br /></td></tr>
<tr class="separator:afa68bfc533f3ce300625ec2b97073800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a19e41534673a4234e99cce59b0a23"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97a19e41534673a4234e99cce59b0a23"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType x, long Npixels, PosType range, PosType center)</td></tr>
<tr class="separator:a97a19e41534673a4234e99cce59b0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d063fcd59fdf742b8cbf0c57ef29104"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#ga2d063fcd59fdf742b8cbf0c57ef29104">TwoDInterpolator</a> (PosType *x,int Npixels,PosType range,PosType *center,PosType *map,bool init)</td></tr>
<tr class="memdesc:ga2d063fcd59fdf742b8cbf0c57ef29104"><td class="mdescLeft">&#160;</td><td class="mdescRight">bilinear interpolation from a map.  <a href="group___utill.html#ga2d063fcd59fdf742b8cbf0c57ef29104">More...</a><br /></td></tr>
<tr class="separator:ga2d063fcd59fdf742b8cbf0c57ef29104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af1cbfc7c5cbcb4525faabc04298eb54d"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>TwoDInterpolator</b> (PosType *map)</td></tr>
<tr class="separator:af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac985ac1b171f2d550864536530bbac2f"></a>
template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac985ac1b171f2d550864536530bbac2f">quicksortPoints_multithread</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac985ac1b171f2d550864536530bbac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The last parameter should be left out when calling so that it takes the default value. <br /></td></tr>
<tr class="separator:ac985ac1b171f2d550864536530bbac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplParams" colspan="2">template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac980fbca67c1ca7531d28e98433e669a">quicksortPoints_multithread</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac980fbca67c1ca7531d28e98433e669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value.  <a href="#ac980fbca67c1ca7531d28e98433e669a">More...</a><br /></td></tr>
<tr class="separator:ac980fbca67c1ca7531d28e98433e669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplParams" colspan="2"><a class="anchor" id="ac7ddbf6268cb6f39b3e6d1b046ff1a48"></a>
template&lt;typename T , int lev&gt; </td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac7ddbf6268cb6f39b3e6d1b046ff1a48">quicksort_multithread</a> (T *array, double(*func)(T &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a T type and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. std::swap() is used to swap elements of the array. <br /></td></tr>
<tr class="separator:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f92371d63e47b1c09977312f15a15f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0f92371d63e47b1c09977312f15a15f0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (<a class="el" href="struct_point.html">Point</a> *p0, <a class="el" href="struct_point.html">Point</a> *p1, PosType *x)</td></tr>
<tr class="separator:a0f92371d63e47b1c09977312f15a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac422420ab4fffbff7714f0015e1727"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7ac422420ab4fffbff7714f0015e1727"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p0, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p1, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x)</td></tr>
<tr class="separator:a7ac422420ab4fffbff7714f0015e1727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe61342a713adf7115f351e3342a2b79"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#gabe61342a713adf7115f351e3342a2b79">prevpower</a> (unsigned long k)</td></tr>
<tr class="separator:gabe61342a713adf7115f351e3342a2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac42846299720c47decf597f70d448464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#gac42846299720c47decf597f70d448464">windings</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:gac42846299720c47decf597f70d448464"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group___utill.html#gac42846299720c47decf597f70d448464" title="windings(): winding number test for a point in a polygon Returns: Number of times a curves winds arou...">windings()</a>: winding number test for a point in a polygon Returns: Number of times a curves winds around the point x.  <a href="group___utill.html#gac42846299720c47decf597f70d448464">More...</a><br /></td></tr>
<tr class="separator:gac42846299720c47decf597f70d448464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964e6781b61f0d76240eda24a4f9ffa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad964e6781b61f0d76240eda24a4f9ffa">windings</a> (PosType *x, <a class="el" href="struct_point.html">Point</a> **points, unsigned long Npoints, PosType *area, short image=0)</td></tr>
<tr class="separator:ad964e6781b61f0d76240eda24a4f9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cd4e52a3b543449c6ba0330f13f01e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a64cd4e52a3b543449c6ba0330f13f01e">windings</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;point, PosType *area)</td></tr>
<tr class="separator:a64cd4e52a3b543449c6ba0330f13f01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aa7db30634cbf18e1652cd2a9ec7f95aa">windings</a> (PosType *x, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *kist, PosType *area, short image=0)</td></tr>
<tr class="separator:aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70de03dea8a3f77f15fd209a783a8065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#ga70de03dea8a3f77f15fd209a783a8065">windings2</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points_original,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:ga70de03dea8a3f77f15fd209a783a8065"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether a point is inside a curve, that has been stretched 1.2 times returns the area of the stretched curve  <a href="group___utill.html#ga70de03dea8a3f77f15fd209a783a8065">More...</a><br /></td></tr>
<tr class="separator:ga70de03dea8a3f77f15fd209a783a8065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6113d02b4e7adef2372f1875990e3fe1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6113d02b4e7adef2372f1875990e3fe1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6113d02b4e7adef2372f1875990e3fe1">incurve</a> (PosType x[], std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; curve)</td></tr>
<tr class="memdesc:a6113d02b4e7adef2372f1875990e3fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if it is in the curve and 0 if it is out. Borders count as in. <br /></td></tr>
<tr class="separator:a6113d02b4e7adef2372f1875990e3fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc634a3e291c24e89a13c9e480e5b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a23cc634a3e291c24e89a13c9e480e5b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a23cc634a3e291c24e89a13c9e480e5b2">incurve</a> (PosType x[], std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; curve)</td></tr>
<tr class="memdesc:a23cc634a3e291c24e89a13c9e480e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if it is in the curve and 0 if it is out. Borders count as in. <br /></td></tr>
<tr class="separator:a23cc634a3e291c24e89a13c9e480e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2fb3cc522fc36c51e33bccac70089c7"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___utill.html#gaf2fb3cc522fc36c51e33bccac70089c7">order_curve4</a> (<a class="el" href="struct_point.html">Point</a> *curve, long Npoints)</td></tr>
<tr class="memdesc:gaf2fb3cc522fc36c51e33bccac70089c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders points on a closed curve.  <a href="group___utill.html#gaf2fb3cc522fc36c51e33bccac70089c7">More...</a><br /></td></tr>
<tr class="separator:gaf2fb3cc522fc36c51e33bccac70089c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab9e95a7c17ef4a5d5c4a31fac956140c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ab9e95a7c17ef4a5d5c4a31fac956140c">order_curve4</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads and is dependent on version that takes a point array. Returns number of points that have been ordered. Remaining, unordered points are left at the end of the kist. <br /></td></tr>
<tr class="separator:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8293f72cb05db408c84e3d101a56e41"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad8293f72cb05db408c84e3d101a56e41">order_curve5</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ad8293f72cb05db408c84e3d101a56e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">For odering the curve by the convex hull method. Warning: Does not work very well.  <a href="#ad8293f72cb05db408c84e3d101a56e41">More...</a><br /></td></tr>
<tr class="separator:ad8293f72cb05db408c84e3d101a56e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ad22484d4cfaaefd6317d73a74934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a742ad22484d4cfaaefd6317d73a74934"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a742ad22484d4cfaaefd6317d73a74934">ordered_convexhull</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a742ad22484d4cfaaefd6317d73a74934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve-&gt;imagekist with its convex hull. The number of points will change. <br /></td></tr>
<tr class="separator:a742ad22484d4cfaaefd6317d73a74934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8efda5cf4838d1780ea6e08e155566f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8efda5cf4838d1780ea6e08e155566f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_shrink_wrap</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:aa8efda5cf4838d1780ea6e08e155566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac95a7f052ffe8de55dfdc33d06dc541c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_concavehull</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a865c4f1f38a91d8b3d4e07fdfea16bd0">ConvexHullArea</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve with its convex hull. The number of points will change.  <a href="#a865c4f1f38a91d8b3d4e07fdfea16bd0">More...</a><br /></td></tr>
<tr class="separator:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b"><td class="memTemplParams" colspan="2"><a class="anchor" id="a5364acb5691c4969be66653956508e6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Matrix</b> (T **matrix, long rows, long cols)</td></tr>
<tr class="separator:a5364acb5691c4969be66653956508e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplParams" colspan="2"><a class="anchor" id="acdc7f37bdbbd9f9893af797a98f601aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>free_Matrix</b> (T **matrix, long rows, long)</td></tr>
<tr class="separator:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeab156e03bf2f71c3c0de9e267dcb39b"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (size_t rows, size_t cols)</td></tr>
<tr class="separator:aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee12be6dc37bf892ebfbeff4b835084"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9ee12be6dc37bf892ebfbeff4b835084"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, size_t rows, size_t cols)</td></tr>
<tr class="separator:a9ee12be6dc37bf892ebfbeff4b835084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8540dba0d1bf112290a7389379fefa"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aee8540dba0d1bf112290a7389379fefa"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aee8540dba0d1bf112290a7389379fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f8b847fdd13e67af70275c2df84ef9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa8f8b847fdd13e67af70275c2df84ef9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aa8f8b847fdd13e67af70275c2df84ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5"><td class="memTemplParams" colspan="2"><a class="anchor" id="a355e53765bbce52485685f2cf11632d5"></a>
template&lt;class BaseT &gt; </td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (std::vector&lt; BaseT * &gt; &amp;items, PosType target)</td></tr>
<tr class="separator:a355e53765bbce52485685f2cf11632d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplParams" colspan="2"><a class="anchor" id="ab5fbd0455bb23cf8290252d8ddef0874"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ab5fbd0455bb23cf8290252d8ddef0874">delete_container</a> (Container &amp;c)</td></tr>
<tr class="memdesc:ab5fbd0455bb23cf8290252d8ddef0874"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the objects that are pointed to in a container of pointers <br /></td></tr>
<tr class="separator:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplParams" colspan="2"><a class="anchor" id="a42da2b93e07ba858edd0d2b9ca7032ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>between</b> (const T &amp;x, const T &amp;l, const T &amp;u)</td></tr>
<tr class="separator:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae0bee38ec4c0f219f4f1d8320b0056"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:aeae0bee38ec4c0f219f4f1d8320b0056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aeae0bee38ec4c0f219f4f1d8320b0056">shuffle</a> (std::vector&lt; T &gt; &amp;vec, R ran)</td></tr>
<tr class="memdesc:aeae0bee38ec4c0f219f4f1d8320b0056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles a vector into a random order.  <a href="#aeae0bee38ec4c0f219f4f1d8320b0056">More...</a><br /></td></tr>
<tr class="separator:aeae0bee38ec4c0f219f4f1d8320b0056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a9b44ff17b26b627e429e9984d4908577">sort_indexes</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:a9b44ff17b26b627e429e9984d4908577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in asending order.  <a href="#a9b44ff17b26b627e429e9984d4908577">More...</a><br /></td></tr>
<tr class="separator:a9b44ff17b26b627e429e9984d4908577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a357b69312972120ce046eff265e6b581">sort_indexes</a> (const T *v, std::vector&lt; size_t &gt; &amp;index, size_t N)</td></tr>
<tr class="separator:a357b69312972120ce046eff265e6b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aec9c85bddb9c124c7df2bc04fbf350fe">sort_indexes_decending</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in descending order.  <a href="#aec9c85bddb9c124c7df2bc04fbf350fe">More...</a><br /></td></tr>
<tr class="separator:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d"><td class="memTemplParams" colspan="2"><a class="anchor" id="abd8109e832d4f887939cbaef421a101d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (T *vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:abd8109e832d4f887939cbaef421a101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043"><td class="memTemplParams" colspan="2"><a class="anchor" id="a173a48bc6f7d6968101fca85c6998043"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (std::vector&lt; T &gt; &amp;vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:a173a48bc6f7d6968101fca85c6998043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf43d7dba91cb2697307c22249bc12"><td class="memItemLeft" align="right" valign="top">std::valarray&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a1faf43d7dba91cb2697307c22249bc12">AdaptiveSmooth</a> (const std::valarray&lt; double &gt; &amp;map_in, size_t Nx, size_t Ny, double value)</td></tr>
<tr class="memdesc:a1faf43d7dba91cb2697307c22249bc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a 2 dimensional map stored in a valarray with a density dependent kernel.  <a href="#a1faf43d7dba91cb2697307c22249bc12">More...</a><br /></td></tr>
<tr class="separator:a1faf43d7dba91cb2697307c22249bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a144a1a0d2b8ea76c952f10b4a5f45369">AdaptiveSmooth</a> (const std::vector&lt; double &gt; &amp;map_in, size_t Nx, size_t Ny, double value)</td></tr>
<tr class="memdesc:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a 2 dimensional map stored in a valarray with a density dependent kernel.  <a href="#a144a1a0d2b8ea76c952f10b4a5f45369">More...</a><br /></td></tr>
<tr class="separator:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa654746e24cd77549f412bed8d3ee26"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa654746e24cd77549f412bed8d3ee26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afa654746e24cd77549f412bed8d3ee26">GetNThreads</a> ()</td></tr>
<tr class="memdesc:afa654746e24cd77549f412bed8d3ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the compiler variable N_THREADS that is maximum number of threads to be used. <br /></td></tr>
<tr class="separator:afa654746e24cd77549f412bed8d3ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3cdbb09da9d15ddb6562e887ad173d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:afd3cdbb09da9d15ddb6562e887ad173d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afd3cdbb09da9d15ddb6562e887ad173d">read2columnfile</a> (std::string filename, std::vector&lt; T1 &gt; &amp;x, std::vector&lt; T2 &gt; &amp;y, std::string delineator=&quot; &quot;, bool verbose=false)</td></tr>
<tr class="memdesc:afd3cdbb09da9d15ddb6562e887ad173d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in data from an ASCII file with two columns.  <a href="#afd3cdbb09da9d15ddb6562e887ad173d">More...</a><br /></td></tr>
<tr class="separator:afd3cdbb09da9d15ddb6562e887ad173d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef4783ad9c08c0e951893ad9aa21ba1"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 , class T3 &gt; </td></tr>
<tr class="memitem:abef4783ad9c08c0e951893ad9aa21ba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#abef4783ad9c08c0e951893ad9aa21ba1">read3columnfile</a> (std::string filename, std::vector&lt; T1 &gt; &amp;x, std::vector&lt; T2 &gt; &amp;y, std::vector&lt; T3 &gt; &amp;z, std::string delineator=&quot; &quot;, bool verbose=false)</td></tr>
<tr class="memdesc:abef4783ad9c08c0e951893ad9aa21ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read in data from an ASCII file with three columns.  <a href="#abef4783ad9c08c0e951893ad9aa21ba1">More...</a><br /></td></tr>
<tr class="separator:abef4783ad9c08c0e951893ad9aa21ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae358b58a950d75ef089c7ad73f37a080"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae358b58a950d75ef089c7ad73f37a080"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:ae358b58a950d75ef089c7ad73f37a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa3e10d9b962622365a0916fb0fa01"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5baa3e10d9b962622365a0916fb0fa01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:a5baa3e10d9b962622365a0916fb0fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495d1ed407458779abf8694a2e4cda2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af495d1ed407458779abf8694a2e4cda2"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af495d1ed407458779abf8694a2e4cda2">IndexFromPosition</a> (PosType *x, long Nx, long Ny, PosType range, const PosType *center)</td></tr>
<tr class="memdesc:af495d1ed407458779abf8694a2e4cda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the nonsquare version of the function, it will return -1 is outside of region <br /></td></tr>
<tr class="separator:af495d1ed407458779abf8694a2e4cda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043901fd09c24707f46eb23b75548882"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a043901fd09c24707f46eb23b75548882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a043901fd09c24707f46eb23b75548882">PositionFromIndex</a> (unsigned long i, PosType *x, long Nx, long Ny, PosType range, PosType const *center)</td></tr>
<tr class="memdesc:a043901fd09c24707f46eb23b75548882"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square or rectangular regions as long as Npixels and range are the x-axis values and the pixels are square. <br /></td></tr>
<tr class="separator:a043901fd09c24707f46eb23b75548882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa9581800c9d5adc2444440dac76de955"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa9581800c9d5adc2444440dac76de955"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>nXbin</b> =64.</td></tr>
<tr class="separator:aa9581800c9d5adc2444440dac76de955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>convert a Band type to a string name. </p>
<p>The <a class="el" href="namespace_utilities.html" title="convert a Band type to a string name. ">Utilities</a> namespace contains functions for wide use in many classes that perform generic tasks.</p>
<p>type for particle positions and boundaries etc</p>
<p>The two functions below are inverses of each other for converting between a 1d array index and a square grid of positions Npixels in the number of point is 1 dimension index is between 0 and Npixels*Npixels-1 If x is outside of the region -1 is returned. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1faf43d7dba91cb2697307c22249bc12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::valarray&lt; double &gt; Utilities::AdaptiveSmooth </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. </p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done. The </p>

</div>
</div>
<a class="anchor" id="a144a1a0d2b8ea76c952f10b4a5f45369"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Utilities::AdaptiveSmooth </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. </p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done.</p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done. The </p>

</div>
</div>
<a class="anchor" id="a6d17c2495bead70b18b91c376c28c051"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::concave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hull_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm. </p>
<p>The type of the input vector points must have an operator []. If the input vector is the same as the output vector it will be replaced, and the function will still work.</p>
<p>It is guaranteed that the resulting hull will surround the all the points. Any edge that is greater than scale will be refined until it is either smaller than scale or it cannot be refined further. As a result some edges might be larger than scale and some smaller.</p>
<p>This should be a NlogN algorithm.</p>
<p>The algorithm: 1) The convex hull is found. 2) The longest edge is found 3) all the points that are not in the hull are tested to see if they are within the rays extending from the end point perpendicular to the edge. 4) Of the points that are the one that makes the smallest area triangle with the end points is chosen and added 5) go back to 3 if there are edges that are larger than scale and new points exist to be added 6) remove all intersections in the hull </p>

</div>
</div>
<a class="anchor" id="aca82634714ad53172788a38cef165b07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>test</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered. </p>

</div>
</div>
<a class="anchor" id="afadfff44acbcae923eac1bec385ae6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered.</p>
<p>This is an overloaded version of the other <a class="el" href="namespace_utilities.html#aca82634714ad53172788a38cef165b07" title="Returns a vector of points on the convcave hull in counter-clockwise order. ">concave_hull()</a> </p>

</div>
</div>
<a class="anchor" id="a512d73667d76a5a58e44042a4a73c974"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point__2d.html">Point_2d</a> Utilities::contour_center </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. </p>
<p>The performance of the algorithm is ~O(N^2). Less naive methods go like O(N) at best. Most commonly a combined convex hull plus rotating calipers algorithm is used. Since we have the convex_hull already, we only need to implement the latter algorithm. </p>

</div>
</div>
<a class="anchor" id="ac71ef3b7c0383a2ca61eb5d479d8490d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::contour_ellipse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ellipticity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ellipse_area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour). </p>
<p>The axis ratio of the ellipse b/a is equal to the ratio of the distances between center and the nearest contour point (i.e. b) and between center and the farthest contour point (i.e. a). NOTE that the center used to calculate a and b is an input parameter. The definition of the center is crucial to the meaning of above output parameters. The center of the convex_hull produces for even slightly distorted hulls significant offsets resulting in overestimated major axis values (a). The function <a class="el" href="namespace_utilities.html#a512d73667d76a5a58e44042a4a73c974" title="Returns the center of a contour defined as the midpoint between the two points in the contour that ar...">Utilities::contour_center()</a> calculates the center as the midpoint between the two points in the contour that are farthest apart from one another, which gives already more reliable results. The output vector describing the ellipse is resized to match the size of the contour vector. </p>

</div>
</div>
<a class="anchor" id="a865c4f1f38a91d8b3d4e07fdfea16bd0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::ConvexHullArea </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces curve with its convex hull. The number of points will change. </p>
<p>gives the area within the convex hull of the curve </p>

</div>
</div>
<a class="anchor" id="a484765a953bdbceb52b23f6790d59cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::double_sort_points </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>brr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts points in a point array. </p>
<p>arr array uses NR standard indexing i.e arr[1...n] but brr[0..n-1] if the point array is two-way-coupled to another point array the image pointers of that array will follow sort if the array is not two-way-coupled to another the image pointers in the other array will be untouched </p>

</div>
</div>
<a class="anchor" id="af5c6f9e86e55bf8ac250ed8a2849ba3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::InterpolateYvec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>xi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate (cubic interpolation) the value of a function <img class="formulaInl" alt="$ y=y(x) $" src="form_6.png"/> given xi </p>

</div>
</div>
<a class="anchor" id="a74edb07bfa2d5cee2ef5450f0998ff57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::LoadFitsImages </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pixel_map.html">PixelMap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the fits files in a directory into a vector of PixelMaps. </p>
<p>The input fits files must have .fits in their names in addition to the string filespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespec</td><td>string of charactors in fits file name that are matched </td></tr>
    <tr><td class="paramname">images</td><td>output vector of PixelMaps </td></tr>
    <tr><td class="paramname">maxN</td><td>maximum number of images that will be read in </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution (rad) of fits image if not given in fits file, use default or -1 otherwise </td></tr>
    <tr><td class="paramname">verbose</td><td>lists files to stdout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad3f190fa0f0cac4eb4b7c981d5131e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::LoadFitsImages </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>filespecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>file_non_specs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_pixel_map.html">PixelMap</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the fits files in a directory into a vector of PixelMaps. </p>
<p>The input fits files must have .fits in their names in addition to the string filespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespecs</td><td>string of charactors in fits file name that are matched </td></tr>
    <tr><td class="paramname">file_non_specs</td><td>string of charactors in fits file name cannot have </td></tr>
    <tr><td class="paramname">images</td><td>output vector of PixelMaps </td></tr>
    <tr><td class="paramname">names</td><td>file names </td></tr>
    <tr><td class="paramname">maxN</td><td>maximum number of images that will be read in </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution (rad) of fits image if not given in fits file, use default or -1 otherwise </td></tr>
    <tr><td class="paramname">verbose</td><td>lists files to stdout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a606f4aebc622ae58090979fda604d1fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::log_polar_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>i_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ngrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>/ingroup Utill</p>
<p>make a new 2d grid with logarithmically distributed radii Ngrid - both the radial and asmuthal number of points, total number of points is Ngrid*Ngrid WARRNING: This should not be used as initial grid for adaptive grid calculations! These need to be done on a rectolinear grid. For testing the ray shooter only. </p>

</div>
</div>
<a class="anchor" id="afb7f32cbe2c0f17c06a106dee6726e98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorType , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::nintegrateF </td>
          <td>(</td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>struct or class to be integrated </td></tr>
    <tr><td class="paramname">a</td><td>limit of integrations </td></tr>
    <tr><td class="paramname">b</td><td>limit of integrations </td></tr>
    <tr><td class="paramname">tols</td><td>target fractional error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8293f72cb05db408c84e3d101a56e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::order_curve5 </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For odering the curve by the convex hull method. Warning: Does not work very well. </p>
<p>The convex hull is found for the points in the kist. Then each additional point is inserted into the curve where it will increase the length of the curve the least. This method leaves loops where they shouldn't be and probably doesn't handle self-intersections well. </p>

</div>
</div>
<a class="anchor" id="ac980fbca67c1ca7531d28e98433e669a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int lev&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::quicksortPoints_multithread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>pointarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(<a class="el" href="struct_point.html">Point</a> &amp;)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. </p>
<p>This function is different from <a class="el" href="namespace_utilities.html#ac7ddbf6268cb6f39b3e6d1b046ff1a48" title="Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function func takes a T ty...">quicksort_multithread()</a> in that it uses SwapPointsInArray() instead of std::swap() which is needed to make the image pointers follow the swap. </p>

</div>
</div>
<a class="anchor" id="a0855636bdb71f103a4412555b9711e98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::RandomFromTable </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Ntable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table. </p>
<p>Utill </p>

</div>
</div>
<a class="anchor" id="afd3cdbb09da9d15ddb6562e887ad173d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::read2columnfile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delineator</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in data from an ASCII file with two columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>input file name </td></tr>
    <tr><td class="paramname">x</td><td>vector that will contain the first column </td></tr>
    <tr><td class="paramname">y</td><td>vector that will contain the first column </td></tr>
    <tr><td class="paramname">delineator</td><td>specific string the seporates columns, ex. ",", "|", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abef4783ad9c08c0e951893ad9aa21ba1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 , class T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::read3columnfile </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>delineator</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read in data from an ASCII file with three columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>input file name </td></tr>
    <tr><td class="paramname">x</td><td>vector that will contain the first column </td></tr>
    <tr><td class="paramname">y</td><td>vector that will contain the first column </td></tr>
    <tr><td class="paramname">z</td><td>vector that will contain the first column </td></tr>
    <tr><td class="paramname">delineator</td><td>specific string the seporates columns, ex. ",", "|", etc. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7ecac67b7051e410014dec29cc6721f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::ReadFileNames </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the file names in a directory that contain a specific sub string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespec</td><td>string of charactors in file name that are matched. It can be an empty string. </td></tr>
    <tr><td class="paramname">filenames</td><td>output vector of PixelMaps </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aeae0bee38ec4c0f219f4f1d8320b0056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::shuffle </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R&#160;</td>
          <td class="paramname"><em>ran</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles a vector into a random order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to be shuffled </td></tr>
    <tr><td class="paramname">ran</td><td>a random number generator so that ran() gives a number between 0 and 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9b44ff17b26b627e429e9984d4908577"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in asending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a357b69312972120ce046eff265e6b581"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec9c85bddb9c124c7df2bc04fbf350fe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes_decending </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad964e6781b61f0d76240eda24a4f9ffa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> **&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities. ">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">points</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a64cd4e52a3b543449c6ba0330f13f01e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities. ">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">point</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7db30634cbf18e1652cd2a9ec7f95aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>kist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities. ">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">kist</td><td>Kist of points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7771b5ff9b3034f364adcee471cb754d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::writeCurves </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *&#160;</td>
          <td class="paramname"><em>critical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ncrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ind_caustic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>writes in four files the critical curves and the caustics for all the curves found and also for a specified one (ind_causic) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>part of te filename, could be the number/index of the main lens </td></tr>
    <tr><td class="paramname">critical</td><td>the crit curve </td></tr>
    <tr><td class="paramname">Ncrit</td><td>the number of crit curves </td></tr>
    <tr><td class="paramname">ind_caustic</td><td>the index of the cuvre of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 5 2017 15:47:25 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
