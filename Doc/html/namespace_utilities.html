<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Utilities Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Utilities Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>convert a Band type to a string name.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_utilities_1_1_geometry"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities_1_1_geometry.html">Geometry</a></td></tr>
<tr class="memdesc:namespace_utilities_1_1_geometry"><td class="mdescLeft">&#160;</td><td class="mdescRight">Namespace for geometrical functions mostly having to do with spherical coordinates. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d2_matrix.html">D2Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">2 dimensional matrix  <a href="class_utilities_1_1_d2_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_d3_matrix.html">D3Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">3 dimensional matrix, fixed size  <a href="class_utilities_1_1_d3_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_hilbert_curve.html">HilbertCurve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for calculating the Hilbert curve distance in two dimensions.  <a href="class_utilities_1_1_hilbert_curve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_interpolator.html">Interpolator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear interpolation class for interpolating from a 2D uniform grid.  <a href="class_utilities_1_1_interpolator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector.html">MixedVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container that can hold mixed objects all derived from a base class and retains the ability to access derived class functions/members.  <a href="class_utilities_1_1_mixed_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html">MixedVector&lt; BaseT * &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_utilities_1_1_mixed_vector.html" title="A container that can hold mixed objects all derived from a base class and retains the ability to acce...">MixedVector</a> for pointers.  <a href="class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_random_numbers___n_r.html">RandomNumbers_NR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a class for generating random numbers. It simplifies and fool proofs initialization and allows for multiple independent series of numbers.  <a href="class_utilities_1_1_random_numbers___n_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_utilities_1_1_shuffled_index.html">ShuffledIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gives a randomized sequence of numbers from 0 to N-1.  <a href="class_utilities_1_1_shuffled_index.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memItemLeft" align="right" valign="top"><a id="a83d3f6d35f48dd5cf7ff992a6c36ee8a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>print_date</b> ()</td></tr>
<tr class="separator:a83d3f6d35f48dd5cf7ff992a6c36ee8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a380f0a954728d751781e61918facba0e"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a380f0a954728d751781e61918facba0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a380f0a954728d751781e61918facba0e">fill_linear</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:a380f0a954728d751781e61918facba0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a47aedfd83edf6f6637cc03da5413e94a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a47aedfd83edf6f6637cc03da5413e94a">fill_logarithmic</a> (std::vector&lt; T &gt; &amp;v, size_t n, T min, T max)</td></tr>
<tr class="separator:a47aedfd83edf6f6637cc03da5413e94a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memTemplItemLeft" align="right" valign="top">int long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7bd6a986fd81b85b290cd9ab0034e3f8">locate</a> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="separator:a7bd6a986fd81b85b290cd9ab0034e3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07d27fc678946de3bc659e5d7f9feda"><td class="memTemplParams" colspan="2">template&lt;class T , class F &gt; </td></tr>
<tr class="memitem:af07d27fc678946de3bc659e5d7f9feda"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af07d27fc678946de3bc659e5d7f9feda">locate</a> (const std::vector&lt; T &gt; &amp;v, F x, std::function&lt; bool(F, const T &amp;)&gt; less_than)</td></tr>
<tr class="separator:af07d27fc678946de3bc659e5d7f9feda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplParams" colspan="2"><a id="a0cfb54fff515cfd5d684572962f50c66"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0cfb54fff515cfd5d684572962f50c66"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>locate</b> (T *v, unsigned long n, T x, unsigned long *index)</td></tr>
<tr class="separator:a0cfb54fff515cfd5d684572962f50c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc053736fab41bd2807991e8dfcab129"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acc053736fab41bd2807991e8dfcab129"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#acc053736fab41bd2807991e8dfcab129">locate</a> (const std::vector&lt; T &gt; &amp;v, const std::vector&lt; size_t &gt; &amp;sorted_index, T value, size_t &amp;rank)</td></tr>
<tr class="memdesc:acc053736fab41bd2807991e8dfcab129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the element of a vector given a sorted index of the vector.  <a href="#acc053736fab41bd2807991e8dfcab129">More...</a><br /></td></tr>
<tr class="separator:acc053736fab41bd2807991e8dfcab129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799"><td class="memTemplParams" colspan="2"><a id="aa80185750e610681c64de174516f9799"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:aa80185750e610681c64de174516f9799"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aa80185750e610681c64de174516f9799">closest</a> (const std::vector&lt; T &gt; &amp;v, const T x)</td></tr>
<tr class="memdesc:aa80185750e610681c64de174516f9799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the index of the element of v that is closest to x. v must be sorted. <br /></td></tr>
<tr class="separator:aa80185750e610681c64de174516f9799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af5c6f9e86e55bf8ac250ed8a2849ba3e">InterpolateYvec</a> (std::vector&lt; PosType &gt; &amp;x, std::vector&lt; PosType &gt; &amp;y, PosType xi)</td></tr>
<tr class="separator:af5c6f9e86e55bf8ac250ed8a2849ba3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memItemLeft" align="right" valign="top"><a id="a49c02a235f698cf25dbc7edf34d4bf8f"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>arctanh</b> (PosType x)</td></tr>
<tr class="separator:a49c02a235f698cf25dbc7edf34d4bf8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473f872514990ed70931ddd9489301a7"><td class="memItemLeft" align="right" valign="top"><a id="a473f872514990ed70931ddd9489301a7"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmini</b> (PosType a, PosType b)</td></tr>
<tr class="separator:a473f872514990ed70931ddd9489301a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af99adc537b02f26073243f0d32376def"><td class="memItemLeft" align="right" valign="top"><a id="af99adc537b02f26073243f0d32376def"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>fmaxi</b> (PosType a, PosType b)</td></tr>
<tr class="separator:af99adc537b02f26073243f0d32376def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9277fa3059d24e0c01845213a3947c36"><td class="memItemLeft" align="right" valign="top"><a id="a9277fa3059d24e0c01845213a3947c36"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>median</b> (std::vector&lt; PosType &gt; vec)</td></tr>
<tr class="separator:a9277fa3059d24e0c01845213a3947c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplParams" colspan="2"><a id="a85e6e176b88221d17c1a0d6c83a6846d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a85e6e176b88221d17c1a0d6c83a6846d">polintT</a> (T xa[], T ya[], int n, T x, T *y, T *dy)</td></tr>
<tr class="memdesc:a85e6e176b88221d17c1a0d6c83a6846d"><td class="mdescLeft">&#160;</td><td class="mdescRight">interpolation <br /></td></tr>
<tr class="separator:a85e6e176b88221d17c1a0d6c83a6846d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d"><td class="memTemplParams" colspan="2"><a id="a7679e167450f3450c86c345cd8de373d"></a>
template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:a7679e167450f3450c86c345cd8de373d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7679e167450f3450c86c345cd8de373d">trapz</a> (FunctorType &amp;func, T a, T b, int n, T *s2)</td></tr>
<tr class="memdesc:a7679e167450f3450c86c345cd8de373d"><td class="mdescLeft">&#160;</td><td class="mdescRight">used in trapizoidal integral <br /></td></tr>
<tr class="separator:a7679e167450f3450c86c345cd8de373d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplParams" colspan="2">template&lt;typename FunctorType , typename T  = double&gt; </td></tr>
<tr class="memitem:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afb7f32cbe2c0f17c06a106dee6726e98">nintegrateF</a> (FunctorType func, T a, T b, T tols)</td></tr>
<tr class="separator:afb7f32cbe2c0f17c06a106dee6726e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31db9f78433a6de800437aedfd1b2eb5"><td class="memItemLeft" align="right" valign="top"><a id="a31db9f78433a6de800437aedfd1b2eb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a31db9f78433a6de800437aedfd1b2eb5">rotation</a> (float *xout, float *xin, PosType theta)</td></tr>
<tr class="memdesc:a31db9f78433a6de800437aedfd1b2eb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a31db9f78433a6de800437aedfd1b2eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad140aa2e74c584b82ff6416ff16622"><td class="memItemLeft" align="right" valign="top"><a id="a8ad140aa2e74c584b82ff6416ff16622"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a8ad140aa2e74c584b82ff6416ff16622">rotation</a> (PosType *xout, PosType const *xin, PosType theta)</td></tr>
<tr class="memdesc:a8ad140aa2e74c584b82ff6416ff16622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotates 2 dimensional point without changing input point. <br /></td></tr>
<tr class="separator:a8ad140aa2e74c584b82ff6416ff16622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0855636bdb71f103a4412555b9711e98"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a0855636bdb71f103a4412555b9711e98">RandomFromTable</a> (PosType *table, unsigned long Ntable, long *seed)</td></tr>
<tr class="memdesc:a0855636bdb71f103a4412555b9711e98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table.  <a href="#a0855636bdb71f103a4412555b9711e98">More...</a><br /></td></tr>
<tr class="separator:a0855636bdb71f103a4412555b9711e98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplParams" colspan="2"><a id="aae5ae9b5d81618c5ab06016357dc6c7d"></a>
template&lt;typename T , typename P &gt; </td></tr>
<tr class="memitem:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract</b> (T &amp;p1, P &amp;p2)</td></tr>
<tr class="separator:aae5ae9b5d81618c5ab06016357dc6c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplParams" colspan="2"><a id="a34ba39540d95cbeaa6a00631c640ca7f"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>crossD</b> (P &amp;O, P &amp;A, P &amp;B)</td></tr>
<tr class="separator:a34ba39540d95cbeaa6a00631c640ca7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96"><td class="memTemplParams" colspan="2"><a id="a02302245829df0b35aca33fc6415cb96"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a02302245829df0b35aca33fc6415cb96"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a02302245829df0b35aca33fc6415cb96">RemoveIntersections</a> (std::vector&lt; T &gt; &amp;curve)</td></tr>
<tr class="memdesc:a02302245829df0b35aca33fc6415cb96"><td class="mdescLeft">&#160;</td><td class="mdescRight">removes the intersections of the curve <br /></td></tr>
<tr class="separator:a02302245829df0b35aca33fc6415cb96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4dccd3d5a6b05220a4060b921cf318"><td class="memTemplParams" colspan="2"><a id="acd4dccd3d5a6b05220a4060b921cf318"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd4dccd3d5a6b05220a4060b921cf318"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#acd4dccd3d5a6b05220a4060b921cf318">convex_hull</a> (std::vector&lt; T &gt; &amp;P, std::vector&lt; T &gt; &amp;hull_out)</td></tr>
<tr class="memdesc:acd4dccd3d5a6b05220a4060b921cf318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:acd4dccd3d5a6b05220a4060b921cf318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ffe5233ee836b82577a661cd137075d"><td class="memTemplParams" colspan="2"><a id="a3ffe5233ee836b82577a661cd137075d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3ffe5233ee836b82577a661cd137075d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a3ffe5233ee836b82577a661cd137075d">convex_hull</a> (std::vector&lt; T &gt; &amp;P, std::vector&lt; size_t &gt; &amp;hull_index)</td></tr>
<tr class="memdesc:a3ffe5233ee836b82577a661cd137075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a3ffe5233ee836b82577a661cd137075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d17c2495bead70b18b91c376c28c051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6d17c2495bead70b18b91c376c28c051">concave</a> (std::vector&lt; T &gt; &amp;init_points, std::vector&lt; T &gt; &amp;hull_out, double scale)</td></tr>
<tr class="memdesc:a6d17c2495bead70b18b91c376c28c051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm.  <a href="#a6d17c2495bead70b18b91c376c28c051">More...</a><br /></td></tr>
<tr class="separator:a6d17c2495bead70b18b91c376c28c051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f51d6512069fdc1b2fa93dbf409c20"><td class="memTemplParams" colspan="2"><a id="a50f51d6512069fdc1b2fa93dbf409c20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a50f51d6512069fdc1b2fa93dbf409c20"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>concave2</b> (std::vector&lt; T &gt; &amp;init_points, double scale)</td></tr>
<tr class="separator:a50f51d6512069fdc1b2fa93dbf409c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a74edb07bfa2d5cee2ef5450f0998ff57">LoadFitsImages</a> (std::string dir, const std::string &amp;filespec, std::vector&lt; PixelMap &gt; &amp;images, int maxN, double resolution=-1, bool verbose=false)</td></tr>
<tr class="memdesc:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the fits files in a directory into a vector of PixelMaps.  <a href="#a74edb07bfa2d5cee2ef5450f0998ff57">More...</a><br /></td></tr>
<tr class="separator:a74edb07bfa2d5cee2ef5450f0998ff57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad3f190fa0f0cac4eb4b7c981d5131e5d">LoadFitsImages</a> (std::string dir, std::vector&lt; std::string &gt; filespecs, std::vector&lt; std::string &gt; file_non_specs, std::vector&lt; PixelMap &gt; &amp;images, std::vector&lt; std::string &gt; &amp;names, int maxN, double resolution=-1, bool verbose=false)</td></tr>
<tr class="memdesc:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all the fits files in a directory into a vector of PixelMaps.  <a href="#ad3f190fa0f0cac4eb4b7c981d5131e5d">More...</a><br /></td></tr>
<tr class="separator:ad3f190fa0f0cac4eb4b7c981d5131e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7be26dfecdca30048dd4d3842077a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#abc7be26dfecdca30048dd4d3842077a2">ReadFileNames</a> (std::string dir, const std::string filespec, std::vector&lt; std::string &gt; &amp;filenames, const std::string file_non_spec=&quot; &quot;, bool verbose=false)</td></tr>
<tr class="separator:abc7be26dfecdca30048dd4d3842077a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99eb78332b2d654761336b8ecbde2da"><td class="memItemLeft" align="right" valign="top"><a id="ab99eb78332b2d654761336b8ecbde2da"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>to_string</b> (const Band &amp;band)</td></tr>
<tr class="separator:ab99eb78332b2d654761336b8ecbde2da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memItemLeft" align="right" valign="top"><a id="af1ce4c9e1180dd33a9f4c0c416643a9e"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af1ce4c9e1180dd33a9f4c0c416643a9e">sepSQR</a> (PosType *xx, PosType *yy)</td></tr>
<tr class="memdesc:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separation squared between two positions in 2 dimensions. <br /></td></tr>
<tr class="separator:af1ce4c9e1180dd33a9f4c0c416643a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c5422e8b232b598bfdf69131a7a41"><td class="memItemLeft" align="right" valign="top"><a id="a367c5422e8b232b598bfdf69131a7a41"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>double_sort</b> (unsigned long n, PosType *arr, unsigned long *brr)</td></tr>
<tr class="separator:a367c5422e8b232b598bfdf69131a7a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484765a953bdbceb52b23f6790d59cf2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a484765a953bdbceb52b23f6790d59cf2">double_sort_points</a> (unsigned long n, PosType *arr, <a class="el" href="struct_point.html">Point</a> *brr)</td></tr>
<tr class="memdesc:a484765a953bdbceb52b23f6790d59cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points in a point array.  <a href="#a484765a953bdbceb52b23f6790d59cf2">More...</a><br /></td></tr>
<tr class="separator:a484765a953bdbceb52b23f6790d59cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069e88bf3ba4576f526f75cd607954d4"><td class="memItemLeft" align="right" valign="top"><a id="a069e88bf3ba4576f526f75cd607954d4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a069e88bf3ba4576f526f75cd607954d4">quicksortPoints</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N)</td></tr>
<tr class="memdesc:a069e88bf3ba4576f526f75cd607954d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts points from smallest to largest according to the value of arr[]. Sorts arr[] and pointarray[] simultaneously. <br /></td></tr>
<tr class="separator:a069e88bf3ba4576f526f75cd607954d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0f971972428328fbfecb023efa932b"><td class="memItemLeft" align="right" valign="top"><a id="afe0f971972428328fbfecb023efa932b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksortPoints</b> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N)</td></tr>
<tr class="separator:afe0f971972428328fbfecb023efa932b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0c3070a8f69f72a2f32a39f17ca277"><td class="memItemLeft" align="right" valign="top"><a id="acf0c3070a8f69f72a2f32a39f17ca277"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quicksort</b> (unsigned long *particles, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:acf0c3070a8f69f72a2f32a39f17ca277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e7113bef6d90e6e85d0b25eaf06c93"><td class="memItemLeft" align="right" valign="top"><a id="ae9e7113bef6d90e6e85d0b25eaf06c93"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartition</b> (PosType pivotvalue, unsigned long *pivotindex, unsigned long *particles, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:ae9e7113bef6d90e6e85d0b25eaf06c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16748f779b70435ba98cef668ba62ac4"><td class="memItemLeft" align="right" valign="top"><a id="a16748f779b70435ba98cef668ba62ac4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartitionPoints</b> (PosType pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointsarray, PosType *arr, unsigned long N)</td></tr>
<tr class="separator:a16748f779b70435ba98cef668ba62ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb92660db855441bddb128d39fb968b"><td class="memItemLeft" align="right" valign="top"><a id="a9cb92660db855441bddb128d39fb968b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>quickPartitionPoints</b> (PosType pivotvalue, unsigned long *pivotindex, <a class="el" href="struct_point.html">Point</a> *pointarray, PosType(*func)(<a class="el" href="struct_point.html">Point</a> &amp;p), unsigned long N)</td></tr>
<tr class="separator:a9cb92660db855441bddb128d39fb968b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a606f4aebc622ae58090979fda604d1fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a606f4aebc622ae58090979fda604d1fc">log_polar_grid</a> (<a class="el" href="struct_point.html">Point</a> *i_points, PosType rmax, PosType rmin, PosType *center, long Ngrid)</td></tr>
<tr class="separator:a606f4aebc622ae58090979fda604d1fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5dac005305573c90d3c46db67967a0"><td class="memItemLeft" align="right" valign="top"><a id="a7c5dac005305573c90d3c46db67967a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>findarea</b> (<a class="el" href="struct_image_info.html">ImageInfo</a> *imageinfo)</td></tr>
<tr class="separator:a7c5dac005305573c90d3c46db67967a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7771b5ff9b3034f364adcee471cb754d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a7771b5ff9b3034f364adcee471cb754d">writeCurves</a> (int m, <a class="el" href="struct_image_info.html">ImageInfo</a> *critical, int Ncrit, int index)</td></tr>
<tr class="separator:a7771b5ff9b3034f364adcee471cb754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac66dea830e7b8f4390339d39eca8af68"><td class="memItemLeft" align="right" valign="top"><a id="ac66dea830e7b8f4390339d39eca8af68"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>cross</b> (const <a class="el" href="struct_point.html">Point</a> *O, const <a class="el" href="struct_point.html">Point</a> *A, const <a class="el" href="struct_point.html">Point</a> *B)</td></tr>
<tr class="separator:ac66dea830e7b8f4390339d39eca8af68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42b802d503f1acd2f3d92eb903b9228"><td class="memItemLeft" align="right" valign="top"><a id="ac42b802d503f1acd2f3d92eb903b9228"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:ac42b802d503f1acd2f3d92eb903b9228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ff8c370817f6c178c77b361cca0292"><td class="memItemLeft" align="right" valign="top"><a id="a62ff8c370817f6c178c77b361cca0292"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorder</b> (<a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="separator:a62ff8c370817f6c178c77b361cca0292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6171a36bf18a88838285e19f90d63"><td class="memItemLeft" align="right" valign="top"><a id="afbe6171a36bf18a88838285e19f90d63"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (const double *O, const double *A, const double *B)</td></tr>
<tr class="separator:afbe6171a36bf18a88838285e19f90d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c604b536630835c839b7975028165"><td class="memItemLeft" align="right" valign="top"><a id="ab84c604b536630835c839b7975028165"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>crossD</b> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;O, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;A, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;B)</td></tr>
<tr class="separator:ab84c604b536630835c839b7975028165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6997f6bfc95f466039c9652c6c50274f"><td class="memItemLeft" align="right" valign="top"><a id="a6997f6bfc95f466039c9652c6c50274f"></a>
std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6997f6bfc95f466039c9652c6c50274f">convex_hull</a> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P)</td></tr>
<tr class="memdesc:a6997f6bfc95f466039c9652c6c50274f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a6997f6bfc95f466039c9652c6c50274f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0699a4c75e3899f853dee3fe6a442a25"><td class="memItemLeft" align="right" valign="top"><a id="a0699a4c75e3899f853dee3fe6a442a25"></a>
std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a0699a4c75e3899f853dee3fe6a442a25">convex_hull</a> (std::vector&lt; double * &gt; &amp;P)</td></tr>
<tr class="memdesc:a0699a4c75e3899f853dee3fe6a442a25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convex hull in counter-clockwise order. <br /></td></tr>
<tr class="separator:a0699a4c75e3899f853dee3fe6a442a25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca82634714ad53172788a38cef165b07"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aca82634714ad53172788a38cef165b07">concave_hull</a> (std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;P, int k, bool test=false)</td></tr>
<tr class="memdesc:aca82634714ad53172788a38cef165b07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <a href="#aca82634714ad53172788a38cef165b07">More...</a><br /></td></tr>
<tr class="separator:aca82634714ad53172788a38cef165b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afadfff44acbcae923eac1bec385ae6e4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afadfff44acbcae923eac1bec385ae6e4">concave_hull</a> (std::vector&lt; double * &gt; &amp;P, int k)</td></tr>
<tr class="memdesc:afadfff44acbcae923eac1bec385ae6e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of points on the convcave hull in counter-clockwise order.  <a href="#afadfff44acbcae923eac1bec385ae6e4">More...</a><br /></td></tr>
<tr class="separator:afadfff44acbcae923eac1bec385ae6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac71ef3b7c0383a2ca61eb5d479d8490d">contour_ellipse</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, <a class="el" href="struct_point__2d.html">Point_2d</a> center, unsigned long Npoints, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;C, double *ellipticity, double *ellipse_area)</td></tr>
<tr class="memdesc:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour).  <a href="#ac71ef3b7c0383a2ca61eb5d479d8490d">More...</a><br /></td></tr>
<tr class="separator:ac71ef3b7c0383a2ca61eb5d479d8490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d73667d76a5a58e44042a4a73c974"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a512d73667d76a5a58e44042a4a73c974">contour_center</a> (std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;P, unsigned long Npoints)</td></tr>
<tr class="memdesc:a512d73667d76a5a58e44042a4a73c974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another.  <a href="#a512d73667d76a5a58e44042a4a73c974">More...</a><br /></td></tr>
<tr class="separator:a512d73667d76a5a58e44042a4a73c974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa727547d253bdbd88ac47cae3f7c65c4"><td class="memItemLeft" align="right" valign="top"><a id="aa727547d253bdbd88ac47cae3f7c65c4"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType *x, long Npixels, PosType range, const PosType *center)</td></tr>
<tr class="separator:aa727547d253bdbd88ac47cae3f7c65c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68bfc533f3ce300625ec2b97073800"><td class="memItemLeft" align="right" valign="top"><a id="afa68bfc533f3ce300625ec2b97073800"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afa68bfc533f3ce300625ec2b97073800">PositionFromIndex</a> (unsigned long i, PosType *x, long Npixels, PosType range, PosType const *center)</td></tr>
<tr class="memdesc:afa68bfc533f3ce300625ec2b97073800"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square regions. <br /></td></tr>
<tr class="separator:afa68bfc533f3ce300625ec2b97073800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a19e41534673a4234e99cce59b0a23"><td class="memItemLeft" align="right" valign="top"><a id="a97a19e41534673a4234e99cce59b0a23"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>IndexFromPosition</b> (PosType x, long Npixels, PosType range, PosType center)</td></tr>
<tr class="separator:a97a19e41534673a4234e99cce59b0a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d063fcd59fdf742b8cbf0c57ef29104"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a2d063fcd59fdf742b8cbf0c57ef29104">TwoDInterpolator</a> (PosType *x,int Npixels,PosType range,PosType *center,PosType *map,bool init)</td></tr>
<tr class="memdesc:a2d063fcd59fdf742b8cbf0c57ef29104"><td class="mdescLeft">&#160;</td><td class="mdescRight">bilinear interpolation from a map.  <a href="#a2d063fcd59fdf742b8cbf0c57ef29104">More...</a><br /></td></tr>
<tr class="separator:a2d063fcd59fdf742b8cbf0c57ef29104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memItemLeft" align="right" valign="top"><a id="af1cbfc7c5cbcb4525faabc04298eb54d"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>TwoDInterpolator</b> (PosType *map)</td></tr>
<tr class="separator:af1cbfc7c5cbcb4525faabc04298eb54d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca843ce18cb36d8002f0878719ef7f24"><td class="memTemplParams" colspan="2"><a id="aca843ce18cb36d8002f0878719ef7f24"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aca843ce18cb36d8002f0878719ef7f24"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>cutbox</b> (const T *center, PosType *p1, PosType *p2, float rmax)</td></tr>
<tr class="separator:aca843ce18cb36d8002f0878719ef7f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f"><td class="memTemplParams" colspan="2"><a id="ac985ac1b171f2d550864536530bbac2f"></a>
template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac985ac1b171f2d550864536530bbac2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac985ac1b171f2d550864536530bbac2f">quicksortPoints_multithread</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, PosType *arr, unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac985ac1b171f2d550864536530bbac2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The last parameter should be left out when calling so that it takes the default value. <br /></td></tr>
<tr class="separator:ac985ac1b171f2d550864536530bbac2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplParams" colspan="2">template&lt;int lev&gt; </td></tr>
<tr class="memitem:ac980fbca67c1ca7531d28e98433e669a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac980fbca67c1ca7531d28e98433e669a">quicksortPoints_multithread</a> (<a class="el" href="struct_point.html">Point</a> *pointarray, double(*func)(<a class="el" href="struct_point.html">Point</a> &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac980fbca67c1ca7531d28e98433e669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value.  <a href="#ac980fbca67c1ca7531d28e98433e669a">More...</a><br /></td></tr>
<tr class="separator:ac980fbca67c1ca7531d28e98433e669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplParams" colspan="2"><a id="ac7ddbf6268cb6f39b3e6d1b046ff1a48"></a>
template&lt;typename T , int lev&gt; </td></tr>
<tr class="memitem:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac7ddbf6268cb6f39b3e6d1b046ff1a48">quicksort_multithread</a> (T *array, double(*func)(T &amp;), unsigned long N, int level=0)</td></tr>
<tr class="memdesc:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a T type and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. std::swap() is used to swap elements of the array. <br /></td></tr>
<tr class="separator:ac7ddbf6268cb6f39b3e6d1b046ff1a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f92371d63e47b1c09977312f15a15f0"><td class="memItemLeft" align="right" valign="top"><a id="a0f92371d63e47b1c09977312f15a15f0"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (<a class="el" href="struct_point.html">Point</a> *p0, <a class="el" href="struct_point.html">Point</a> *p1, PosType *x)</td></tr>
<tr class="separator:a0f92371d63e47b1c09977312f15a15f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac422420ab4fffbff7714f0015e1727"><td class="memItemLeft" align="right" valign="top"><a id="a7ac422420ab4fffbff7714f0015e1727"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>isLeft</b> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p0, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;p1, <a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x)</td></tr>
<tr class="separator:a7ac422420ab4fffbff7714f0015e1727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe61342a713adf7115f351e3342a2b79"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#abe61342a713adf7115f351e3342a2b79">prevpower</a> (unsigned long k)</td></tr>
<tr class="separator:abe61342a713adf7115f351e3342a2b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42846299720c47decf597f70d448464"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ac42846299720c47decf597f70d448464">windings</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:ac42846299720c47decf597f70d448464"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="namespace_utilities.html#ac42846299720c47decf597f70d448464" title="windings(): winding number test for a point in a polygon Returns: Number of times a curves winds arou...">windings()</a>: winding number test for a point in a polygon Returns: Number of times a curves winds around the point x.  <a href="#ac42846299720c47decf597f70d448464">More...</a><br /></td></tr>
<tr class="separator:ac42846299720c47decf597f70d448464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad964e6781b61f0d76240eda24a4f9ffa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad964e6781b61f0d76240eda24a4f9ffa">windings</a> (PosType *x, <a class="el" href="struct_point.html">Point</a> **points, unsigned long Npoints, PosType *area, short image=0)</td></tr>
<tr class="separator:ad964e6781b61f0d76240eda24a4f9ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cd4e52a3b543449c6ba0330f13f01e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a64cd4e52a3b543449c6ba0330f13f01e">windings</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> &amp;x, std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;point, PosType *area)</td></tr>
<tr class="separator:a64cd4e52a3b543449c6ba0330f13f01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aa7db30634cbf18e1652cd2a9ec7f95aa">windings</a> (PosType *x, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *kist, PosType *area, short image=0)</td></tr>
<tr class="separator:aa7db30634cbf18e1652cd2a9ec7f95aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70de03dea8a3f77f15fd209a783a8065"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a70de03dea8a3f77f15fd209a783a8065">windings2</a> (PosType *x,<a class="el" href="struct_point.html">Point</a> *points_original,unsigned long Npoints,PosType *area,short image)</td></tr>
<tr class="memdesc:a70de03dea8a3f77f15fd209a783a8065"><td class="mdescLeft">&#160;</td><td class="mdescRight">determines whether a point is inside a curve, that has been stretched 1.2 times returns the area of the stretched curve  <a href="#a70de03dea8a3f77f15fd209a783a8065">More...</a><br /></td></tr>
<tr class="separator:a70de03dea8a3f77f15fd209a783a8065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6113d02b4e7adef2372f1875990e3fe1"><td class="memItemLeft" align="right" valign="top"><a id="a6113d02b4e7adef2372f1875990e3fe1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a6113d02b4e7adef2372f1875990e3fe1">incurve</a> (PosType x[], std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; curve)</td></tr>
<tr class="memdesc:a6113d02b4e7adef2372f1875990e3fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if it is in the curve and 0 if it is out. Borders count as in. <br /></td></tr>
<tr class="separator:a6113d02b4e7adef2372f1875990e3fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cc634a3e291c24e89a13c9e480e5b2"><td class="memItemLeft" align="right" valign="top"><a id="a23cc634a3e291c24e89a13c9e480e5b2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a23cc634a3e291c24e89a13c9e480e5b2">incurve</a> (PosType x[], std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; curve)</td></tr>
<tr class="memdesc:a23cc634a3e291c24e89a13c9e480e5b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns 1 if it is in the curve and 0 if it is out. Borders count as in. <br /></td></tr>
<tr class="separator:a23cc634a3e291c24e89a13c9e480e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fb3cc522fc36c51e33bccac70089c7"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af2fb3cc522fc36c51e33bccac70089c7">order_curve4</a> (<a class="el" href="struct_point.html">Point</a> *curve, long Npoints)</td></tr>
<tr class="memdesc:af2fb3cc522fc36c51e33bccac70089c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orders points on a closed curve.  <a href="#af2fb3cc522fc36c51e33bccac70089c7">More...</a><br /></td></tr>
<tr class="separator:af2fb3cc522fc36c51e33bccac70089c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memItemLeft" align="right" valign="top"><a id="ab9e95a7c17ef4a5d5c4a31fac956140c"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ab9e95a7c17ef4a5d5c4a31fac956140c">order_curve4</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloads and is dependent on version that takes a point array. Returns number of points that have been ordered. Remaining, unordered points are left at the end of the kist. <br /></td></tr>
<tr class="separator:ab9e95a7c17ef4a5d5c4a31fac956140c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8293f72cb05db408c84e3d101a56e41"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ad8293f72cb05db408c84e3d101a56e41">order_curve5</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:ad8293f72cb05db408c84e3d101a56e41"><td class="mdescLeft">&#160;</td><td class="mdescRight">For odering the curve by the convex hull method. Warning: Does not work very well.  <a href="#ad8293f72cb05db408c84e3d101a56e41">More...</a><br /></td></tr>
<tr class="separator:ad8293f72cb05db408c84e3d101a56e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742ad22484d4cfaaefd6317d73a74934"><td class="memItemLeft" align="right" valign="top"><a id="a742ad22484d4cfaaefd6317d73a74934"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a742ad22484d4cfaaefd6317d73a74934">ordered_convexhull</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a742ad22484d4cfaaefd6317d73a74934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve-&gt;imagekist with its convex hull. The number of points will change. <br /></td></tr>
<tr class="separator:a742ad22484d4cfaaefd6317d73a74934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8efda5cf4838d1780ea6e08e155566f"><td class="memItemLeft" align="right" valign="top"><a id="aa8efda5cf4838d1780ea6e08e155566f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_shrink_wrap</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:aa8efda5cf4838d1780ea6e08e155566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memItemLeft" align="right" valign="top"><a id="ac95a7f052ffe8de55dfdc33d06dc541c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ordered_concavehull</b> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="separator:ac95a7f052ffe8de55dfdc33d06dc541c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a865c4f1f38a91d8b3d4e07fdfea16bd0">ConvexHullArea</a> (Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *curve)</td></tr>
<tr class="memdesc:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces curve with its convex hull. The number of points will change.  <a href="#a865c4f1f38a91d8b3d4e07fdfea16bd0">More...</a><br /></td></tr>
<tr class="separator:a865c4f1f38a91d8b3d4e07fdfea16bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6368539a2249ac91796f3ff043e39d"><td class="memTemplParams" colspan="2"><a id="a1a6368539a2249ac91796f3ff043e39d"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a1a6368539a2249ac91796f3ff043e39d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a1a6368539a2249ac91796f3ff043e39d">to_numeric</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a1a6368539a2249ac91796f3ff043e39d"><td class="mdescLeft">&#160;</td><td class="mdescRight">convert a string to a numerical value of various types <br /></td></tr>
<tr class="separator:a1a6368539a2249ac91796f3ff043e39d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55417d380d1000c91b7a59253cd0b82c"><td class="memTemplParams" colspan="2"><a id="a55417d380d1000c91b7a59253cd0b82c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a55417d380d1000c91b7a59253cd0b82c"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; long &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a55417d380d1000c91b7a59253cd0b82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d114df3356f5498414ff9a481f2173"><td class="memTemplParams" colspan="2"><a id="a35d114df3356f5498414ff9a481f2173"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a35d114df3356f5498414ff9a481f2173"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; int &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a35d114df3356f5498414ff9a481f2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a01d1a182e6b247d4702062aab5a32f"><td class="memTemplParams" colspan="2"><a id="a0a01d1a182e6b247d4702062aab5a32f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a0a01d1a182e6b247d4702062aab5a32f"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; float &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a0a01d1a182e6b247d4702062aab5a32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b3b8518238ba6cedc16d8012904c70f"><td class="memTemplParams" colspan="2"><a id="a5b3b8518238ba6cedc16d8012904c70f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a5b3b8518238ba6cedc16d8012904c70f"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>to_numeric&lt; double &gt;</b> (const std::string &amp;str)</td></tr>
<tr class="separator:a5b3b8518238ba6cedc16d8012904c70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b"><td class="memTemplParams" colspan="2"><a id="a5364acb5691c4969be66653956508e6b"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a5364acb5691c4969be66653956508e6b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Matrix</b> (T **matrix, long rows, long cols)</td></tr>
<tr class="separator:a5364acb5691c4969be66653956508e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplParams" colspan="2"><a id="acdc7f37bdbbd9f9893af797a98f601aa"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>free_Matrix</b> (T **matrix, long rows, long)</td></tr>
<tr class="separator:acdc7f37bdbbd9f9893af797a98f601aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memItemLeft" align="right" valign="top"><a id="aeab156e03bf2f71c3c0de9e267dcb39b"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (size_t rows, size_t cols)</td></tr>
<tr class="separator:aeab156e03bf2f71c3c0de9e267dcb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee12be6dc37bf892ebfbeff4b835084"><td class="memItemLeft" align="right" valign="top"><a id="a9ee12be6dc37bf892ebfbeff4b835084"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, size_t rows, size_t cols)</td></tr>
<tr class="separator:a9ee12be6dc37bf892ebfbeff4b835084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8540dba0d1bf112290a7389379fefa"><td class="memItemLeft" align="right" valign="top"><a id="aee8540dba0d1bf112290a7389379fefa"></a>
PosType **&#160;</td><td class="memItemRight" valign="bottom"><b>PosTypeMatrix</b> (long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aee8540dba0d1bf112290a7389379fefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f8b847fdd13e67af70275c2df84ef9"><td class="memItemLeft" align="right" valign="top"><a id="aa8f8b847fdd13e67af70275c2df84ef9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>free_PosTypeMatrix</b> (PosType **matrix, long rows1, long rows2, long cols1, long cols2)</td></tr>
<tr class="separator:aa8f8b847fdd13e67af70275c2df84ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5"><td class="memTemplParams" colspan="2"><a id="a355e53765bbce52485685f2cf11632d5"></a>
template&lt;class BaseT &gt; </td></tr>
<tr class="memitem:a355e53765bbce52485685f2cf11632d5"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lower_bound</b> (std::vector&lt; BaseT * &gt; &amp;items, PosType target)</td></tr>
<tr class="separator:a355e53765bbce52485685f2cf11632d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplParams" colspan="2"><a id="ab5fbd0455bb23cf8290252d8ddef0874"></a>
template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#ab5fbd0455bb23cf8290252d8ddef0874">delete_container</a> (Container &amp;c)</td></tr>
<tr class="memdesc:ab5fbd0455bb23cf8290252d8ddef0874"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete the objects that are pointed to in a container of pointers <br /></td></tr>
<tr class="separator:ab5fbd0455bb23cf8290252d8ddef0874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplParams" colspan="2"><a id="a42da2b93e07ba858edd0d2b9ca7032ec"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>between</b> (const T &amp;x, const T &amp;l, const T &amp;u)</td></tr>
<tr class="separator:a42da2b93e07ba858edd0d2b9ca7032ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9906f7f742a4940019f2a58cabdb05c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename R &gt; </td></tr>
<tr class="memitem:aa9906f7f742a4940019f2a58cabdb05c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aa9906f7f742a4940019f2a58cabdb05c">shuffle</a> (std::vector&lt; T &gt; &amp;vec, R &amp;ran)</td></tr>
<tr class="memdesc:aa9906f7f742a4940019f2a58cabdb05c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles a vector into a random order.  <a href="#aa9906f7f742a4940019f2a58cabdb05c">More...</a><br /></td></tr>
<tr class="separator:aa9906f7f742a4940019f2a58cabdb05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b44ff17b26b627e429e9984d4908577"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a9b44ff17b26b627e429e9984d4908577">sort_indexes</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:a9b44ff17b26b627e429e9984d4908577"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in asending order.  <a href="#a9b44ff17b26b627e429e9984d4908577">More...</a><br /></td></tr>
<tr class="separator:a9b44ff17b26b627e429e9984d4908577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a357b69312972120ce046eff265e6b581"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a357b69312972120ce046eff265e6b581">sort_indexes</a> (const T *v, std::vector&lt; size_t &gt; &amp;index, size_t N)</td></tr>
<tr class="separator:a357b69312972120ce046eff265e6b581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#aec9c85bddb9c124c7df2bc04fbf350fe">sort_indexes_decending</a> (const std::vector&lt; T &gt; &amp;v, std::vector&lt; size_t &gt; &amp;index)</td></tr>
<tr class="memdesc:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indexes that sort a vector in descending order.  <a href="#aec9c85bddb9c124c7df2bc04fbf350fe">More...</a><br /></td></tr>
<tr class="separator:aec9c85bddb9c124c7df2bc04fbf350fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d"><td class="memTemplParams" colspan="2"><a id="abd8109e832d4f887939cbaef421a101d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd8109e832d4f887939cbaef421a101d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (T *vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:abd8109e832d4f887939cbaef421a101d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043"><td class="memTemplParams" colspan="2"><a id="a173a48bc6f7d6968101fca85c6998043"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a173a48bc6f7d6968101fca85c6998043"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>apply_permutation</b> (std::vector&lt; T &gt; &amp;vec, const std::vector&lt; std::size_t &gt; &amp;p)</td></tr>
<tr class="separator:a173a48bc6f7d6968101fca85c6998043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1faf43d7dba91cb2697307c22249bc12"><td class="memItemLeft" align="right" valign="top">std::valarray&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a1faf43d7dba91cb2697307c22249bc12">AdaptiveSmooth</a> (const std::valarray&lt; double &gt; &amp;map_in, size_t Nx, size_t Ny, double value)</td></tr>
<tr class="memdesc:a1faf43d7dba91cb2697307c22249bc12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a 2 dimensional map stored in a valarray with a density dependent kernel.  <a href="#a1faf43d7dba91cb2697307c22249bc12">More...</a><br /></td></tr>
<tr class="separator:a1faf43d7dba91cb2697307c22249bc12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a144a1a0d2b8ea76c952f10b4a5f45369">AdaptiveSmooth</a> (const std::vector&lt; double &gt; &amp;map_in, size_t Nx, size_t Ny, double value)</td></tr>
<tr class="memdesc:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smooth a 2 dimensional map stored in a valarray with a density dependent kernel.  <a href="#a144a1a0d2b8ea76c952f10b4a5f45369">More...</a><br /></td></tr>
<tr class="separator:a144a1a0d2b8ea76c952f10b4a5f45369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa654746e24cd77549f412bed8d3ee26"><td class="memItemLeft" align="right" valign="top"><a id="afa654746e24cd77549f412bed8d3ee26"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#afa654746e24cd77549f412bed8d3ee26">GetNThreads</a> ()</td></tr>
<tr class="memdesc:afa654746e24cd77549f412bed8d3ee26"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the compiler variable N_THREADS that is maximum number of threads to be used. <br /></td></tr>
<tr class="separator:afa654746e24cd77549f412bed8d3ee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae358b58a950d75ef089c7ad73f37a080"><td class="memItemLeft" align="right" valign="top"><a id="ae358b58a950d75ef089c7ad73f37a080"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:ae358b58a950d75ef089c7ad73f37a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baa3e10d9b962622365a0916fb0fa01"><td class="memItemLeft" align="right" valign="top"><a id="a5baa3e10d9b962622365a0916fb0fa01"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>yorderD</b> (double *p1, double *p2)</td></tr>
<tr class="separator:a5baa3e10d9b962622365a0916fb0fa01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af495d1ed407458779abf8694a2e4cda2"><td class="memItemLeft" align="right" valign="top"><a id="af495d1ed407458779abf8694a2e4cda2"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#af495d1ed407458779abf8694a2e4cda2">IndexFromPosition</a> (PosType *x, long Nx, long Ny, PosType range, const PosType *center)</td></tr>
<tr class="memdesc:af495d1ed407458779abf8694a2e4cda2"><td class="mdescLeft">&#160;</td><td class="mdescRight">this is the nonsquare version of the function, it will return -1 is outside of region <br /></td></tr>
<tr class="separator:af495d1ed407458779abf8694a2e4cda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043901fd09c24707f46eb23b75548882"><td class="memItemLeft" align="right" valign="top"><a id="a043901fd09c24707f46eb23b75548882"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utilities.html#a043901fd09c24707f46eb23b75548882">PositionFromIndex</a> (unsigned long i, PosType *x, long Nx, long Ny, PosType range, PosType const *center)</td></tr>
<tr class="memdesc:a043901fd09c24707f46eb23b75548882"><td class="mdescLeft">&#160;</td><td class="mdescRight">This should work for square or rectangular regions as long as Npixels and range are the x-axis values and the pixels are square. <br /></td></tr>
<tr class="separator:a043901fd09c24707f46eb23b75548882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aa9581800c9d5adc2444440dac76de955"><td class="memItemLeft" align="right" valign="top"><a id="aa9581800c9d5adc2444440dac76de955"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>nXbin</b> =64.</td></tr>
<tr class="separator:aa9581800c9d5adc2444440dac76de955"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>convert a Band type to a string name. </p>
<p>The <a class="el" href="namespace_utilities.html" title="convert a Band type to a string name.">Utilities</a> namespace contains functions for wide use in many classes that perform generic tasks.</p>
<p>The two functions below are inverses of each other for converting between a 1d array index and a square grid of positions Npixels in the number of point is 1 dimension index is between 0 and Npixels*Npixels-1 If x is outside of the region -1 is returned. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a1faf43d7dba91cb2697307c22249bc12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1faf43d7dba91cb2697307c22249bc12">&#9670;&nbsp;</a></span>AdaptiveSmooth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::valarray&lt; double &gt; Utilities::AdaptiveSmooth </td>
          <td>(</td>
          <td class="paramtype">const std::valarray&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. </p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done. The </p>

</div>
</div>
<a id="a144a1a0d2b8ea76c952f10b4a5f45369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144a1a0d2b8ea76c952f10b4a5f45369">&#9670;&nbsp;</a></span>AdaptiveSmooth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; Utilities::AdaptiveSmooth </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>map_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. </p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done.</p>
<p>The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)*(number of neighbours) an approximate N nearest neighbour smoothing is done. The </p>

</div>
</div>
<a id="a6d17c2495bead70b18b91c376c28c051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d17c2495bead70b18b91c376c28c051">&#9670;&nbsp;</a></span>concave()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::concave </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>init_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>hull_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates the concave hull of a group of 2 dimensional points by the shrink-wrap algorithm. </p>
<p>The type of the input vector points must have an operator []. If the input vector is the same as the output vector it will be replaced, and the function will still work.</p>
<p>It is guaranteed that the resulting hull will surround the all the points. Any edge that is greater than scale will be refined until it is either smaller than scale or it cannot be refined further. As a result some edges might be larger than scale and some smaller.</p>
<p>This should be a NlogN algorithm.</p>
<p>The algorithm: 1) The convex hull is found. 2) The longest edge is found 3) all the points that are not in the hull are tested to see if they are within the rays extending from the end point perpendicular to the edge. 4) Of the points that are the one that makes the smallest area triangle with the end points is chosen and added 5) go back to 3 if there are edges that are larger than scale and new points exist to be added 6) remove all intersections in the hull </p>

</div>
</div>
<a id="aca82634714ad53172788a38cef165b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca82634714ad53172788a38cef165b07">&#9670;&nbsp;</a></span>concave_hull() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>test</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered. </p>

</div>
</div>
<a id="afadfff44acbcae923eac1bec385ae6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afadfff44acbcae923eac1bec385ae6e4">&#9670;&nbsp;</a></span>concave_hull() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double * &gt; Utilities::concave_hull </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double * &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of points on the convcave hull in counter-clockwise order. </p>
<p>This uses a K-nearest neighbour adapted from Moreira &amp; Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered.</p>
<p>This is an overloaded version of the other <a class="el" href="namespace_utilities.html#aca82634714ad53172788a38cef165b07" title="Returns a vector of points on the convcave hull in counter-clockwise order.">concave_hull()</a> </p>

</div>
</div>
<a id="a512d73667d76a5a58e44042a4a73c974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512d73667d76a5a58e44042a4a73c974">&#9670;&nbsp;</a></span>contour_center()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point__2d.html">Point_2d</a> Utilities::contour_center </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. </p>
<p>The performance of the algorithm is ~O(N^2). Less naive methods go like O(N) at best. Most commonly a combined convex hull plus rotating calipers algorithm is used. Since we have the convex_hull already, we only need to implement the latter algorithm. </p>

</div>
</div>
<a id="ac71ef3b7c0383a2ca61eb5d479d8490d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac71ef3b7c0383a2ca61eb5d479d8490d">&#9670;&nbsp;</a></span>contour_ellipse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::contour_ellipse </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ellipticity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>ellipse_area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns axis ratio, area and points of an ellipse engulfed by some contour (e.g. a contour of same convergence calculated with find_contour). </p>
<p>The axis ratio of the ellipse b/a is equal to the ratio of the distances between center and the nearest contour point (i.e. b) and between center and the farthest contour point (i.e. a). NOTE that the center used to calculate a and b is an input parameter. The definition of the center is crucial to the meaning of above output parameters. The center of the convex_hull produces for even slightly distorted hulls significant offsets resulting in overestimated major axis values (a). The function <a class="el" href="namespace_utilities.html#a512d73667d76a5a58e44042a4a73c974" title="Returns the center of a contour defined as the midpoint between the two points in the contour that ar...">Utilities::contour_center()</a> calculates the center as the midpoint between the two points in the contour that are farthest apart from one another, which gives already more reliable results. The output vector describing the ellipse is resized to match the size of the contour vector. </p>

</div>
</div>
<a id="a865c4f1f38a91d8b3d4e07fdfea16bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865c4f1f38a91d8b3d4e07fdfea16bd0">&#9670;&nbsp;</a></span>ConvexHullArea()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::ConvexHullArea </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces curve with its convex hull. The number of points will change. </p>
<p>gives the area within the convex hull of the curve </p>

</div>
</div>
<a id="a484765a953bdbceb52b23f6790d59cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484765a953bdbceb52b23f6790d59cf2">&#9670;&nbsp;</a></span>double_sort_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::double_sort_points </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>arr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>brr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sorts points in a point array. </p>
<p>arr array uses NR standard indexing i.e arr[1...n] but brr[0..n-1] if the point array is two-way-coupled to another point array the image pointers of that array will follow sort if the array is not two-way-coupled to another the image pointers in the other array will be untouched </p>

</div>
</div>
<a id="a380f0a954728d751781e61918facba0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a380f0a954728d751781e61918facba0e">&#9670;&nbsp;</a></span>fill_linear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::fill_linear </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector with equidistant points from [min, max]. </p>

</div>
</div>
<a id="a47aedfd83edf6f6637cc03da5413e94a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47aedfd83edf6f6637cc03da5413e94a">&#9670;&nbsp;</a></span>fill_logarithmic()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::fill_logarithmic </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a vector with logarithmically equidistant points from [min, max]. </p>

</div>
</div>
<a id="af5c6f9e86e55bf8ac250ed8a2849ba3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c6f9e86e55bf8ac250ed8a2849ba3e">&#9670;&nbsp;</a></span>InterpolateYvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::InterpolateYvec </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PosType &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>xi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate (cubic interpolation) the value of a function <img class="formulaInl" alt="$ y=y(x) $" src="form_6.png"/> given xi </p>

</div>
</div>
<a id="a74edb07bfa2d5cee2ef5450f0998ff57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74edb07bfa2d5cee2ef5450f0998ff57">&#9670;&nbsp;</a></span>LoadFitsImages() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::LoadFitsImages </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PixelMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the fits files in a directory into a vector of PixelMaps. </p>
<p>The input fits files must have .fits in their names in addition to the string filespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespec</td><td>string of charactors in fits file name that are matched </td></tr>
    <tr><td class="paramname">images</td><td>output vector of PixelMaps </td></tr>
    <tr><td class="paramname">maxN</td><td>maximum number of images that will be read in </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution (rad) of fits image if not given in fits file, use default or -1 otherwise </td></tr>
    <tr><td class="paramname">verbose</td><td>lists files to stdout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3f190fa0f0cac4eb4b7c981d5131e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f190fa0f0cac4eb4b7c981d5131e5d">&#9670;&nbsp;</a></span>LoadFitsImages() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::LoadFitsImages </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>filespecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>file_non_specs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; PixelMap &gt; &amp;&#160;</td>
          <td class="paramname"><em>images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxN</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all the fits files in a directory into a vector of PixelMaps. </p>
<p>The input fits files must have .fits in their names in addition to the string filespec. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespecs</td><td>string of charactors in fits file name that are matched </td></tr>
    <tr><td class="paramname">file_non_specs</td><td>string of charactors in fits file name cannot have </td></tr>
    <tr><td class="paramname">images</td><td>output vector of PixelMaps </td></tr>
    <tr><td class="paramname">names</td><td>file names </td></tr>
    <tr><td class="paramname">maxN</td><td>maximum number of images that will be read in </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution (rad) of fits image if not given in fits file, use default or -1 otherwise </td></tr>
    <tr><td class="paramname">verbose</td><td>lists files to stdout </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7bd6a986fd81b85b290cd9ab0034e3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bd6a986fd81b85b290cd9ab0034e3f8">&#9670;&nbsp;</a></span>locate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int long Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -1 or n-1. </p>

</div>
</div>
<a id="af07d27fc678946de3bc659e5d7f9feda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07d27fc678946de3bc659e5d7f9feda">&#9670;&nbsp;</a></span>locate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(F, const T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>less_than</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -1 or n-1. </p>

</div>
</div>
<a id="acc053736fab41bd2807991e8dfcab129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc053736fab41bd2807991e8dfcab129">&#9670;&nbsp;</a></span>locate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t Utilities::locate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the element of a vector given a sorted index of the vector. </p>
<p>The vector v does not need to be sorted, but the index does with Utiltites::sort_index(), Utilities::sort_index_decending() or in some other way.</p>
<p>returns the index of v that is the largest value that is &lt;= value </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector to search, does not need to be sorted </td></tr>
    <tr><td class="paramname">sorted_index</td><td>sorted index for v, could be assending or decending </td></tr>
    <tr><td class="paramname">value</td><td>value to be matched </td></tr>
    <tr><td class="paramname">rank</td><td>index in sorted_index </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a606f4aebc622ae58090979fda604d1fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a606f4aebc622ae58090979fda604d1fc">&#9670;&nbsp;</a></span>log_polar_grid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::log_polar_grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>i_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Ngrid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>/ingroup Utill</p>
<p>make a new 2d grid with logarithmically distributed radii Ngrid - both the radial and asmuthal number of points, total number of points is Ngrid*Ngrid WARRNING: This should not be used as initial grid for adaptive grid calculations! These need to be done on a rectolinear grid. For testing the ray shooter only. </p>

</div>
</div>
<a id="afb7f32cbe2c0f17c06a106dee6726e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7f32cbe2c0f17c06a106dee6726e98">&#9670;&nbsp;</a></span>nintegrateF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FunctorType , typename T  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::nintegrateF </td>
          <td>(</td>
          <td class="paramtype">FunctorType&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>tols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>struct or class to be integrated </td></tr>
    <tr><td class="paramname">a</td><td>limit of integrations </td></tr>
    <tr><td class="paramname">b</td><td>limit of integrations </td></tr>
    <tr><td class="paramname">tols</td><td>target fractional error </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af2fb3cc522fc36c51e33bccac70089c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2fb3cc522fc36c51e33bccac70089c7">&#9670;&nbsp;</a></span>order_curve4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::order_curve4 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>Npoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orders points on a closed curve. </p>
<p>The algorithm first finds the "center" of the curve. It then does a rough ordering according to the angle around this center. It then walks the curve jumping to a neighbor cell each step choosing a neighbor along one of the x or y-axis before taking a diagonal step. If it comes to the point where there is no more neighbors (as may occur after going through a self-intersection and then returning to it) the algorithm backtracks until it finds a point in the ordered list that is also a neighbor to a point in the not yet ordered list and attaches this to the end of the ordered list and continuous to walk. This algorithm works well at finding a closed loop. It can cut off points from the curve that are either in loops or if four cells intersect and are all on the curve as can happen when there is a lot of structure in the curve that is not resolved at the gridsize used. The points that are cut off are at the end of the array in no guaranteed order.</p>
<p>Returns the number of point that have been ordered - total number minus the cuttout points.</p>
<p>This algorithm could be improve by inserting the remaining points, if any, into the existing curve and recursively calling itself. </p>

</div>
</div>
<a id="ad8293f72cb05db408c84e3d101a56e41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8293f72cb05db408c84e3d101a56e41">&#9670;&nbsp;</a></span>order_curve5()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::order_curve5 </td>
          <td>(</td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For odering the curve by the convex hull method. Warning: Does not work very well. </p>
<p>The convex hull is found for the points in the kist. Then each additional point is inserted into the curve where it will increase the length of the curve the least. This method leaves loops where they shouldn't be and probably doesn't handle self-intersections well. </p>

</div>
</div>
<a id="abe61342a713adf7115f351e3342a2b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe61342a713adf7115f351e3342a2b79">&#9670;&nbsp;</a></span>prevpower()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Utilities::prevpower </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function finds the largest power of 2 that is &lt; k </p>

</div>
</div>
<a id="ac980fbca67c1ca7531d28e98433e669a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac980fbca67c1ca7531d28e98433e669a">&#9670;&nbsp;</a></span>quicksortPoints_multithread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int lev&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::quicksortPoints_multithread </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>pointarray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double(*)(<a class="el" href="struct_point.html">Point</a> &amp;)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function <code>func</code> takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. </p>
<p>This function is different from <a class="el" href="namespace_utilities.html#ac7ddbf6268cb6f39b3e6d1b046ff1a48" title="Multi-threaded quicksort. The maximum number of threads used is 2^lev. The function func takes a T ty...">quicksort_multithread()</a> in that it uses SwapPointsInArray() instead of std::swap() which is needed to make the image pointers follow the swap. </p>

</div>
</div>
<a id="a0855636bdb71f103a4412555b9711e98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0855636bdb71f103a4412555b9711e98">&#9670;&nbsp;</a></span>RandomFromTable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::RandomFromTable </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Ntable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random deviates drawn fEinstein_rom appEinstein_roximately the same as the values of table. </p>
<p>\ingEinstein_roup Utill </p>

</div>
</div>
<a id="abc7be26dfecdca30048dd4d3842077a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7be26dfecdca30048dd4d3842077a2">&#9670;&nbsp;</a></span>ReadFileNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::ReadFileNames </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filespec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file_non_spec</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir</td><td>path to directory containing fits files </td></tr>
    <tr><td class="paramname">filespec</td><td>string of charactors in file name that are matched. It can be an empty string. </td></tr>
    <tr><td class="paramname">filenames</td><td>output vector of PixelMaps </td></tr>
    <tr><td class="paramname">file_non_spec</td><td>string of charactors in file name that file must not have. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9906f7f742a4940019f2a58cabdb05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9906f7f742a4940019f2a58cabdb05c">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::shuffle </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>ran</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shuffles a vector into a random order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The vector to be shuffled </td></tr>
    <tr><td class="paramname">ran</td><td>a random number generator so that ran() gives a number between 0 and 1 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b44ff17b26b627e429e9984d4908577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b44ff17b26b627e429e9984d4908577">&#9670;&nbsp;</a></span>sort_indexes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in asending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a357b69312972120ce046eff265e6b581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b69312972120ce046eff265e6b581">&#9670;&nbsp;</a></span>sort_indexes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec9c85bddb9c124c7df2bc04fbf350fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec9c85bddb9c124c7df2bc04fbf350fe">&#9670;&nbsp;</a></span>sort_indexes_decending()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::sort_indexes_decending </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indexes that sort a vector in descending order. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>the original data that is not changed </td></tr>
    <tr><td class="paramname">index</td><td>vector of indexes that if put into v will sort it </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d063fcd59fdf742b8cbf0c57ef29104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d063fcd59fdf742b8cbf0c57ef29104">&#9670;&nbsp;</a></span>TwoDInterpolator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Utilities::TwoDInterpolator </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>bilinear interpolation from a map. </p>
<p>Out of bounds points return 0. map is a i dimensional array representing a 2 dimensional map. Don't use init. After it is used once, later calls can use TwoDInterpolator(PosType *map) for the same point in the same coordinate system to save time in calculating the indexes. </p>
<p>bilinear interpolation</p>
<p>bilinear interpolation </p>

</div>
</div>
<a id="ac42846299720c47decf597f70d448464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42846299720c47decf597f70d448464">&#9670;&nbsp;</a></span>windings() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="namespace_utilities.html#ac42846299720c47decf597f70d448464" title="windings(): winding number test for a point in a polygon Returns: Number of times a curves winds arou...">windings()</a>: winding number test for a point in a polygon Returns: Number of times a curves winds around the point x. </p>
<p>The number of times the curve loops around a point is calculated.</p>
<p>The area of a self-intersecting curve will be the area of the regions encircled in a clockwise direction minus the regions encircled in a counterclockwise direction - an infinity symbol has zero area. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">points</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad964e6781b61f0d76240eda24a4f9ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad964e6781b61f0d76240eda24a4f9ffa">&#9670;&nbsp;</a></span>windings() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> **&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">points</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64cd4e52a3b543449c6ba0330f13f01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cd4e52a3b543449c6ba0330f13f01e">&#9670;&nbsp;</a></span>windings() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point__2d.html">Point_2d</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">point</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7db30634cbf18e1652cd2a9ec7f95aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7db30634cbf18e1652cd2a9ec7f95aa">&#9670;&nbsp;</a></span>windings() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>kist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">kist</td><td>Kist of points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 1 the image of the curve is uses as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70de03dea8a3f77f15fd209a783a8065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70de03dea8a3f77f15fd209a783a8065">&#9670;&nbsp;</a></span>windings2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Utilities::windings2 </td>
          <td>(</td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>points_original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>area</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>image</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>determines whether a point is inside a curve, that has been stretched 1.2 times returns the area of the stretched curve </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td><a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> for which the winding number is calculated </td></tr>
    <tr><td class="paramname">points_original</td><td>The points on the border. These must be ordered. </td></tr>
    <tr><td class="paramname">Npoints</td><td>number of points in curve </td></tr>
    <tr><td class="paramname">area</td><td>returns absolute the area within the curve with oriented border </td></tr>
    <tr><td class="paramname">image</td><td>if == 0 the image of the curve is used as the curve </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7771b5ff9b3034f364adcee471cb754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7771b5ff9b3034f364adcee471cb754d">&#9670;&nbsp;</a></span>writeCurves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::writeCurves </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> *&#160;</td>
          <td class="paramname"><em>critical</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ncrit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ind_caustic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>writes in four files the critical curves and the caustics for all the curves found and also for a specified one (ind_causic) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>part of te filename, could be the number/index of the main lens </td></tr>
    <tr><td class="paramname">critical</td><td>the crit curve </td></tr>
    <tr><td class="paramname">Ncrit</td><td>the number of crit curves </td></tr>
    <tr><td class="paramname">ind_caustic</td><td>the index of the cuvre of interest </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 28 2019 11:59:03 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
