<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Grid Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_grid-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Grid Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Structure to contain both source and image trees.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Grid:</div>
<div class="dyncontent">
<div class="center"><img src="struct_grid__coll__graph.png" border="0" usemap="#a_grid_coll__map" alt="Collaboration graph"/></div>
<map name="a_grid_coll__map" id="a_grid_coll__map">
<area shape="rect" title="Structure to contain both source and image trees." alt="" coords="23,199,70,225"/>
<area shape="rect" href="struct_tree_struct.html" title="Tree: Exported struct." alt="" coords="5,95,88,121"/>
<area shape="rect" href="struct_point_list.html" title="link list for points, uses the linking pointers within the Point type unlike Kist" alt="" coords="10,5,83,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a830c6822b5e6a6b022d11923dfebcefc" id="r_a830c6822b5e6a6b022d11923dfebcefc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a830c6822b5e6a6b022d11923dfebcefc">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:a830c6822b5e6a6b022d11923dfebcefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing square grid.  <br /></td></tr>
<tr class="separator:a830c6822b5e6a6b022d11923dfebcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892ed0bb5f45b92505d8d82cfe408c9e" id="r_a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a892ed0bb5f45b92505d8d82cfe408c9e">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long Nx, const PosType center[2], PosType rangeX, PosType rangeY)</td></tr>
<tr class="memdesc:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing rectangular grid.  <br /></td></tr>
<tr class="separator:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661d0a7f998caaaf8627d7a67072116" id="r_a3661d0a7f998caaaf8627d7a67072116"><td class="memItemLeft" align="right" valign="top"><a id="a3661d0a7f998caaaf8627d7a67072116" name="a3661d0a7f998caaaf8627d7a67072116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~Grid</b> ()</td></tr>
<tr class="memdesc:a3661d0a7f998caaaf8627d7a67072116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a>. Frees all memory. <br /></td></tr>
<tr class="separator:a3661d0a7f998caaaf8627d7a67072116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0943bbb27be32f316a85d4a3bc1d793" id="r_aa0943bbb27be32f316a85d4a3bc1d793"><td class="memItemLeft" align="right" valign="top"><a id="aa0943bbb27be32f316a85d4a3bc1d793" name="aa0943bbb27be32f316a85d4a3bc1d793"></a>
<a class="el" href="struct_grid.html">Grid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReInitialize</b> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:aa0943bbb27be32f316a85d4a3bc1d793"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new grid that has not been refined but has the same intial image grid, but calculated with a new lens. <br /></td></tr>
<tr class="separator:aa0943bbb27be32f316a85d4a3bc1d793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd646880c0c5f33af5869aab6b7c0f8" id="r_a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dd646880c0c5f33af5869aab6b7c0f8">zoom</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, double *center, double scale, <a class="el" href="struct_branch.html">Branch</a> *top=NULL)</td></tr>
<tr class="memdesc:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if point is in a region of uniform magnification using the kappa and gamma calculated from the rayshooter.  <br /></td></tr>
<tr class="separator:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0974cb2286d5bc2ff4220fe57ab59875" id="r_a0974cb2286d5bc2ff4220fe57ab59875"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0974cb2286d5bc2ff4220fe57ab59875">RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">Source</a> *source)</td></tr>
<tr class="memdesc:a0974cb2286d5bc2ff4220fe57ab59875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshoot the rays with the same image postions.  <br /></td></tr>
<tr class="separator:a0974cb2286d5bc2ff4220fe57ab59875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a277e7811838b96b41b578c83879b7afa" id="r_a277e7811838b96b41b578c83879b7afa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277e7811838b96b41b578c83879b7afa">AddSurfaceBrightnesses</a> (<a class="el" href="class_source.html">Source</a> *source)</td></tr>
<tr class="memdesc:a277e7811838b96b41b578c83879b7afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness just like Grid::RefreshSurfaceBrightness but the new source is added to any sources that were already there. <br  />
  <br /></td></tr>
<tr class="separator:a277e7811838b96b41b578c83879b7afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99ea033ac2888518f350e5dcc2fdc357" id="r_a99ea033ac2888518f350e5dcc2fdc357"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99ea033ac2888518f350e5dcc2fdc357">mark_closest_point_source_images</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> y_source, PosType r_source_max, PosType luminosity, bool verbose=false)</td></tr>
<tr class="memdesc:a99ea033ac2888518f350e5dcc2fdc357"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all the images for a circular source of radius r_source, then finds the points within each image that are closest to the center and then markes each surface brightness. Only one pixel per image gets flux.  <br /></td></tr>
<tr class="separator:a99ea033ac2888518f350e5dcc2fdc357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5116dfe57f5584c4d0559970b6fe2c63" id="r_a5116dfe57f5584c4d0559970b6fe2c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5116dfe57f5584c4d0559970b6fe2c63">find_point_source_images</a> (<a class="el" href="struct_point__2d.html">Point_2d</a> y_source, PosType r_source, PosType z_source, std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;images, bool verbose=false)</td></tr>
<tr class="memdesc:a5116dfe57f5584c4d0559970b6fe2c63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function finds all the images for a circular source of radius r_source, then finds the points within each image that are closest to the center of the source. Only one pixel per image gets flux. Points are not marked.  <br /></td></tr>
<tr class="separator:a5116dfe57f5584c4d0559970b6fe2c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db542a5491a1b59f3c36278b830407" id="r_a25db542a5491a1b59f3c36278b830407"><td class="memItemLeft" align="right" valign="top"><a id="a25db542a5491a1b59f3c36278b830407" name="a25db542a5491a1b59f3c36278b830407"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>ClearSurfaceBrightnesses</b> ()</td></tr>
<tr class="memdesc:a25db542a5491a1b59f3c36278b830407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the surface brightness and in_image flag in every point on image and source planes to zero (false) <br /></td></tr>
<tr class="separator:a25db542a5491a1b59f3c36278b830407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc141a71ff2f072060af41ab458c98a1" id="r_adc141a71ff2f072060af41ab458c98a1"><td class="memItemLeft" align="right" valign="top"><a id="adc141a71ff2f072060af41ab458c98a1" name="adc141a71ff2f072060af41ab458c98a1"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>refine_on_surfacebrightness</b> (<a class="el" href="class_lens.html">Lens</a> &amp;lens, <a class="el" href="class_source.html">Source</a> &amp;source)</td></tr>
<tr class="separator:adc141a71ff2f072060af41ab458c98a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b84bc9acf6cbeff3a6da1f3dca202e1" id="r_a4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b84bc9acf6cbeff3a6da1f3dca202e1">getNumberOfPoints</a> () const</td></tr>
<tr class="memdesc:a4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of points on image plane.  <br /></td></tr>
<tr class="separator:a4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fc09f6be7248237f1edea5830bab43" id="r_a27fc09f6be7248237f1edea5830bab43"><td class="memItemLeft" align="right" valign="top"><a id="a27fc09f6be7248237f1edea5830bab43" name="a27fc09f6be7248237f1edea5830bab43"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>EinsteinArea</b> () const</td></tr>
<tr class="memdesc:a27fc09f6be7248237f1edea5830bab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">area of region with negative magnification <br /></td></tr>
<tr class="separator:a27fc09f6be7248237f1edea5830bab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a0b60a7c609ab3b9883cc5facb28b" id="r_a338a0b60a7c609ab3b9883cc5facb28b"><td class="memItemLeft" align="right" valign="top"><a id="a338a0b60a7c609ab3b9883cc5facb28b" name="a338a0b60a7c609ab3b9883cc5facb28b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getInitNgrid</b> ()</td></tr>
<tr class="memdesc:a338a0b60a7c609ab3b9883cc5facb28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial number of grid points in each direction <br /></td></tr>
<tr class="separator:a338a0b60a7c609ab3b9883cc5facb28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c6c31b94541725e8f6ebb68e28366" id="r_aff8c6c31b94541725e8f6ebb68e28366"><td class="memItemLeft" align="right" valign="top"><a id="aff8c6c31b94541725e8f6ebb68e28366" name="aff8c6c31b94541725e8f6ebb68e28366"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>getNgrid_block</b> ()</td></tr>
<tr class="memdesc:aff8c6c31b94541725e8f6ebb68e28366"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of cells in each dimension into which each cell is divided when a refinement is made <br /></td></tr>
<tr class="separator:aff8c6c31b94541725e8f6ebb68e28366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb414f884497255df53b5ba7ceb0f24" id="r_aafb414f884497255df53b5ba7ceb0f24"><td class="memItemLeft" align="right" valign="top"><a id="aafb414f884497255df53b5ba7ceb0f24" name="aafb414f884497255df53b5ba7ceb0f24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>getInitRange</b> ()</td></tr>
<tr class="memdesc:aafb414f884497255df53b5ba7ceb0f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial range of gridded region <br /></td></tr>
<tr class="separator:aafb414f884497255df53b5ba7ceb0f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31fd4cdeff36cbf37c878699197b126" id="r_ac31fd4cdeff36cbf37c878699197b126"><td class="memItemLeft" align="right" valign="top"><a id="ac31fd4cdeff36cbf37c878699197b126" name="ac31fd4cdeff36cbf37c878699197b126"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInitCenter</b> ()</td></tr>
<tr class="separator:ac31fd4cdeff36cbf37c878699197b126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2864fc3791c44eed90c2e980777884" id="r_aef2864fc3791c44eed90c2e980777884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef2864fc3791c44eed90c2e980777884">RefineLeaf</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:aef2864fc3791c44eed90c2e980777884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental function used to divide a leaf in the tree into nine subcells.  <br /></td></tr>
<tr class="separator:aef2864fc3791c44eed90c2e980777884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7eed9868d59171a38dac0423cc25e7" id="r_a8d7eed9868d59171a38dac0423cc25e7"><td class="memItemLeft" align="right" valign="top"><a id="a8d7eed9868d59171a38dac0423cc25e7" name="a8d7eed9868d59171a38dac0423cc25e7"></a>
<a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>RefineLeaves</b> (<a class="el" href="class_lens.html">LensHndl</a> lens, std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;points)</td></tr>
<tr class="memdesc:a8d7eed9868d59171a38dac0423cc25e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="#aef2864fc3791c44eed90c2e980777884" title="Fundamental function used to divide a leaf in the tree into nine subcells.">RefineLeaf()</a> but multiple points can be passed. The rays are shot all together so that more parallelization can be achieved in the rayshooting. <br /></td></tr>
<tr class="separator:a8d7eed9868d59171a38dac0423cc25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942b5f9d22c55c2b1cc9619991f1412" id="r_a3942b5f9d22c55c2b1cc9619991f1412"><td class="memItemLeft" align="right" valign="top"><a id="a3942b5f9d22c55c2b1cc9619991f1412" name="a3942b5f9d22c55c2b1cc9619991f1412"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearAllMarks</b> ()</td></tr>
<tr class="memdesc:a3942b5f9d22c55c2b1cc9619991f1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rest all in_image markers to False. <br /></td></tr>
<tr class="separator:a3942b5f9d22c55c2b1cc9619991f1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a564ca633d349b420b157b6fe71a042b5" id="r_a564ca633d349b420b157b6fe71a042b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a564ca633d349b420b157b6fe71a042b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a564ca633d349b420b157b6fe71a042b5">writeFits</a> (const double center[], size_t Npixels, double resolution, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:a564ca633d349b420b157b6fe71a042b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <br /></td></tr>
<tr class="separator:a564ca633d349b420b157b6fe71a042b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dc795bf0466c365e06eae77ba7073f" id="r_a20dc795bf0466c365e06eae77ba7073f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20dc795bf0466c365e06eae77ba7073f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a20dc795bf0466c365e06eae77ba7073f">writeFits</a> (const double center[], size_t Nx, size_t Ny, double resolution, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:a20dc795bf0466c365e06eae77ba7073f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <br /></td></tr>
<tr class="separator:a20dc795bf0466c365e06eae77ba7073f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454205ce6790192d7e90d04ca9bdc20b" id="r_a454205ce6790192d7e90d04ca9bdc20b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a454205ce6790192d7e90d04ca9bdc20b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a454205ce6790192d7e90d04ca9bdc20b">writeFits</a> (double strech, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:a454205ce6790192d7e90d04ca9bdc20b"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a fits image of whole grid region  <br /></td></tr>
<tr class="separator:a454205ce6790192d7e90d04ca9bdc20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef25408943531718b008996d5eddb9cb" id="r_aef25408943531718b008996d5eddb9cb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aef25408943531718b008996d5eddb9cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aef25408943531718b008996d5eddb9cb">writePixelFits</a> (size_t Nx, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:aef25408943531718b008996d5eddb9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution.  <br /></td></tr>
<tr class="separator:aef25408943531718b008996d5eddb9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6db6d5bdc63482cae8b00b7bdd8f9f7" id="r_af6db6d5bdc63482cae8b00b7bdd8f9f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af6db6d5bdc63482cae8b00b7bdd8f9f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af6db6d5bdc63482cae8b00b7bdd8f9f7">writeFitsVector</a> (const double center[], size_t Npixels, double resolution, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:af6db6d5bdc63482cae8b00b7bdd8f9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits file for making plots of vector fields.  <br /></td></tr>
<tr class="separator:af6db6d5bdc63482cae8b00b7bdd8f9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337d6e50ad7e7f02120df13cd4807094" id="r_a337d6e50ad7e7f02120df13cd4807094"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a337d6e50ad7e7f02120df13cd4807094"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a337d6e50ad7e7f02120df13cd4807094">writePixelMap</a> (const double center[], size_t Npixels, double resolution, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:a337d6e50ad7e7f02120df13cd4807094"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the lensing quantities of a fixed grid.  <br /></td></tr>
<tr class="separator:a337d6e50ad7e7f02120df13cd4807094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff4c6aba9bdaf76da4cae273aa79fd5" id="r_abff4c6aba9bdaf76da4cae273aa79fd5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abff4c6aba9bdaf76da4cae273aa79fd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abff4c6aba9bdaf76da4cae273aa79fd5">writePixelMap</a> (const double center[], size_t Nx, size_t Ny, double resolution, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:abff4c6aba9bdaf76da4cae273aa79fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the lensing quantities of a fixed grid.  <br /></td></tr>
<tr class="separator:abff4c6aba9bdaf76da4cae273aa79fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb6203dc60ec0db35c8420a3fe99f46" id="r_a9eb6203dc60ec0db35c8420a3fe99f46"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9eb6203dc60ec0db35c8420a3fe99f46"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9eb6203dc60ec0db35c8420a3fe99f46">writePixelMap</a> (<a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:a9eb6203dc60ec0db35c8420a3fe99f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">With the initial boundaries and resolution, ie no refinement.  <br /></td></tr>
<tr class="separator:a9eb6203dc60ec0db35c8420a3fe99f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b5fc463ba0a735c5549dc4db2592b41" id="r_a4b5fc463ba0a735c5549dc4db2592b41"><td class="memTemplParams" colspan="2"><a id="a4b5fc463ba0a735c5549dc4db2592b41" name="a4b5fc463ba0a735c5549dc4db2592b41"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4b5fc463ba0a735c5549dc4db2592b41"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MapSurfaceBrightness</b> (<a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; &amp;map)</td></tr>
<tr class="memdesc:a4b5fc463ba0a735c5549dc4db2592b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">make image of surface brightness <br /></td></tr>
<tr class="separator:a4b5fc463ba0a735c5549dc4db2592b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb84a869cb1312884c991e3814f87f0d" id="r_acb84a869cb1312884c991e3814f87f0d"><td class="memTemplParams" colspan="2"><a id="acb84a869cb1312884c991e3814f87f0d" name="acb84a869cb1312884c991e3814f87f0d"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acb84a869cb1312884c991e3814f87f0d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MapSurfaceBrightness</b> (double resolution)</td></tr>
<tr class="memdesc:acb84a869cb1312884c991e3814f87f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a map of the whole gridded area with given resolution <br /></td></tr>
<tr class="separator:acb84a869cb1312884c991e3814f87f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a42e04085607e44ba84a08dc57573b" id="r_af8a42e04085607e44ba84a08dc57573b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8a42e04085607e44ba84a08dc57573b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af8a42e04085607e44ba84a08dc57573b">writePixelMapUniform</a> (const PosType center[], size_t Nx, size_t Ny, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="memdesc:af8a42e04085607e44ba84a08dc57573b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Pixel map of the without distribution the pixels.  <br /></td></tr>
<tr class="separator:af8a42e04085607e44ba84a08dc57573b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5074797acda5147b164176fa38e568ef" id="r_a5074797acda5147b164176fa38e568ef"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5074797acda5147b164176fa38e568ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5074797acda5147b164176fa38e568ef">writePixelMapUniform</a> (<a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; &amp;map, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar)</td></tr>
<tr class="separator:a5074797acda5147b164176fa38e568ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b2d1ed7a7fc6c6798049885a2e0f8c" id="r_a39b2d1ed7a7fc6c6798049885a2e0f8c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a39b2d1ed7a7fc6c6798049885a2e0f8c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a39b2d1ed7a7fc6c6798049885a2e0f8c">writeFitsUniform</a> (const PosType center[], size_t Nx, size_t Ny, <a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a> lensvar, std::string filename)</td></tr>
<tr class="memdesc:a39b2d1ed7a7fc6c6798049885a2e0f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a fits map of the without distribution the pixels.  <br /></td></tr>
<tr class="separator:a39b2d1ed7a7fc6c6798049885a2e0f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4f4aff30be66ff79365f4ea810cc5e" id="r_abc4f4aff30be66ff79365f4ea810cc5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc4f4aff30be66ff79365f4ea810cc5e">find_images</a> (PosType *y_source, PosType r_source, int &amp;Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long &amp;Nimagepoints)</td></tr>
<tr class="memdesc:abc4f4aff30be66ff79365f4ea810cc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images for a given source position and size. It seporates images of different pairities.  <br /></td></tr>
<tr class="separator:abc4f4aff30be66ff79365f4ea810cc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fbb68b8796b638083812ca5f46d030" id="r_a08fbb68b8796b638083812ca5f46d030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08fbb68b8796b638083812ca5f46d030">map_images</a> (<a class="el" href="class_lens.html">Lens</a> *lens, <a class="el" href="class_source.html">Source</a> *source, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, PosType xmax, PosType xmin, PosType initial_size, ExitCriterion criterion, bool FindCenter, bool divide_images)</td></tr>
<tr class="memdesc:a08fbb68b8796b638083812ca5f46d030"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find images and refine them based on their surface brightness distribution.  <br /></td></tr>
<tr class="separator:a08fbb68b8796b638083812ca5f46d030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292378167185b8eb18245060b21a13c6" id="r_a292378167185b8eb18245060b21a13c6"><td class="memItemLeft" align="right" valign="top"><a id="a292378167185b8eb18245060b21a13c6" name="a292378167185b8eb18245060b21a13c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Grid</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a292378167185b8eb18245060b21a13c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4507e0ed7ada07245f8252d462a4a5fb" id="r_a4507e0ed7ada07245f8252d462a4a5fb"><td class="memItemLeft" align="right" valign="top"><a id="a4507e0ed7ada07245f8252d462a4a5fb" name="a4507e0ed7ada07245f8252d462a4a5fb"></a>
<a class="el" href="struct_grid.html">Grid</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;grid)=delete</td></tr>
<tr class="separator:a4507e0ed7ada07245f8252d462a4a5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0bd8ddfe96ce77d598ef8cdf10ab69" id="r_a8f0bd8ddfe96ce77d598ef8cdf10ab69"><td class="memItemLeft" align="right" valign="top"><a id="a8f0bd8ddfe96ce77d598ef8cdf10ab69" name="a8f0bd8ddfe96ce77d598ef8cdf10ab69"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Grid</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;grid)=delete</td></tr>
<tr class="separator:a8f0bd8ddfe96ce77d598ef8cdf10ab69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca74e50a99d1976487f430f581c84084" id="r_aca74e50a99d1976487f430f581c84084"><td class="memItemLeft" align="right" valign="top"><a id="aca74e50a99d1976487f430f581c84084" name="aca74e50a99d1976487f430f581c84084"></a>
<a class="el" href="struct_grid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;&amp;grid)</td></tr>
<tr class="separator:aca74e50a99d1976487f430f581c84084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f0f81e2db4dda9a34678e6bc1c6445" id="r_ac2f0f81e2db4dda9a34678e6bc1c6445"><td class="memItemLeft" align="right" valign="top"><a id="ac2f0f81e2db4dda9a34678e6bc1c6445" name="ac2f0f81e2db4dda9a34678e6bc1c6445"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>magnification</b> (double sblimit=-1.0e12) const</td></tr>
<tr class="memdesc:ac2f0f81e2db4dda9a34678e6bc1c6445"><td class="mdescLeft">&#160;</td><td class="mdescRight">flux weighted local magnification that does not take multiple imaging into effect <br /></td></tr>
<tr class="separator:ac2f0f81e2db4dda9a34678e6bc1c6445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa331fd4aedeb883a3c39088d5479ce88" id="r_aa331fd4aedeb883a3c39088d5479ce88"><td class="memItemLeft" align="right" valign="top"><a id="aa331fd4aedeb883a3c39088d5479ce88" name="aa331fd4aedeb883a3c39088d5479ce88"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>UnlensedFlux</b> (double sblimit=-1.0e12) const</td></tr>
<tr class="separator:aa331fd4aedeb883a3c39088d5479ce88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116a7c25be81428653ae2cf8ae63876c" id="r_a116a7c25be81428653ae2cf8ae63876c"><td class="memItemLeft" align="right" valign="top"><a id="a116a7c25be81428653ae2cf8ae63876c" name="a116a7c25be81428653ae2cf8ae63876c"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>LensedFlux</b> (double sblimit=-1.0e12) const</td></tr>
<tr class="separator:a116a7c25be81428653ae2cf8ae63876c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfddf45465203922ce4ac592da07bb0" id="r_aedfddf45465203922ce4ac592da07bb0"><td class="memItemLeft" align="right" valign="top"><a id="aedfddf45465203922ce4ac592da07bb0" name="aedfddf45465203922ce4ac592da07bb0"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>centroid</b> () const</td></tr>
<tr class="memdesc:aedfddf45465203922ce4ac592da07bb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">centroid of flux <br /></td></tr>
<tr class="separator:aedfddf45465203922ce4ac592da07bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae68f5779296176fee76a92c9f6076a73" id="r_ae68f5779296176fee76a92c9f6076a73"><td class="memItemLeft" align="right" valign="top"><a id="ae68f5779296176fee76a92c9f6076a73" name="ae68f5779296176fee76a92c9f6076a73"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>i_tree</b></td></tr>
<tr class="memdesc:ae68f5779296176fee76a92c9f6076a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on image plane <br /></td></tr>
<tr class="separator:ae68f5779296176fee76a92c9f6076a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda62e6b854e898781e85abd5a8e751" id="r_abeda62e6b854e898781e85abd5a8e751"><td class="memItemLeft" align="right" valign="top"><a id="abeda62e6b854e898781e85abd5a8e751" name="abeda62e6b854e898781e85abd5a8e751"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><b>s_tree</b></td></tr>
<tr class="memdesc:abeda62e6b854e898781e85abd5a8e751"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on source plane <br /></td></tr>
<tr class="separator:abeda62e6b854e898781e85abd5a8e751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure to contain both source and image trees. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a830c6822b5e6a6b022d11923dfebcefc" name="a830c6822b5e6a6b022d11923dfebcefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830c6822b5e6a6b022d11923dfebcefc">&#9670;&#160;</a></span>Grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a></td>          <td class="paramname"><span class="paramname"><em>lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>N1d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>range</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing square grid. </p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid  </td></tr>
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension.  </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid (usually in radian units)  </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892ed0bb5f45b92505d8d82cfe408c9e" name="a892ed0bb5f45b92505d8d82cfe408c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892ed0bb5f45b92505d8d82cfe408c9e">&#9670;&#160;</a></span>Grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a></td>          <td class="paramname"><span class="paramname"><em>lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>rangeX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>rangeY</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing rectangular grid. </p>
<p>Cells of grid will always be square with initial resolution rangeX/(Nx-1). The Y range may not be exactly rangeY, but will be the nearest value that is a whole number of cells.</p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid  </td></tr>
    <tr><td class="paramname">Nx</td><td>Initial number of grid points in X dimension.  </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid.  </td></tr>
    <tr><td class="paramname">rangeX</td><td>Full width of grid in x direction in whatever units will be used.  </td></tr>
    <tr><td class="paramname">rangeY</td><td>Full width of grid in y direction in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a277e7811838b96b41b578c83879b7afa" name="a277e7811838b96b41b578c83879b7afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277e7811838b96b41b578c83879b7afa">&#9670;&#160;</a></span>AddSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Grid::AddSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recalculate surface brightness just like Grid::RefreshSurfaceBrightness but the new source is added to any sources that were already there. <br  />
 </p>
<p>returns the total flux from new source </p>

</div>
</div>
<a id="abc4f4aff30be66ff79365f4ea810cc5e" name="abc4f4aff30be66ff79365f4ea810cc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc4f4aff30be66ff79365f4ea810cc5e">&#9670;&#160;</a></span>find_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::find_images </td>
          <td>(</td>
          <td class="paramtype">PosType *</td>          <td class="paramname"><span class="paramname"><em>y_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>r_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>Nimages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>imageinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;</td>          <td class="paramname"><span class="paramname"><em>Nimagepoints</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images for a given source position and size. It seporates images of different pairities. </p>
<p>No grid refinement is done. If the images is not initially found no nearest neighbor points are returned.</p>
<p>image points are put into imageinfo[].imagekist imageinfo[].points and imageinfo[].Npoints are not changed</p>
<p>side-effects : Will make in_image = true for all image points if splitparities == 0</p>
<p>&lt;<code></code> &gt; </p>

</div>
</div>
<a id="a5116dfe57f5584c4d0559970b6fe2c63" name="a5116dfe57f5584c4d0559970b6fe2c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5116dfe57f5584c4d0559970b6fe2c63">&#9670;&#160;</a></span>find_point_source_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::find_point_source_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>y_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>r_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>z_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_r_a_y.html">RAY</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>images</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds all the images for a circular source of radius r_source, then finds the points within each image that are closest to the center of the source. Only one pixel per image gets flux. Points are not marked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>angular position of source,  </td></tr>
    <tr><td class="paramname">r_source</td><td>points outside this radius on the source plane will not be considered as in the image  </td></tr>
    <tr><td class="paramname">z_source</td><td>redhsift of source  </td></tr>
    <tr><td class="paramname">images</td><td>returned image rays </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b84bc9acf6cbeff3a6da1f3dca202e1" name="a4b84bc9acf6cbeff3a6da1f3dca202e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b84bc9acf6cbeff3a6da1f3dca202e1">&#9670;&#160;</a></span>getNumberOfPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long Grid::getNumberOfPoints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of points on image plane. </p>
<p>Finding </p>

</div>
</div>
<a id="a08fbb68b8796b638083812ca5f46d030" name="a08fbb68b8796b638083812ca5f46d030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fbb68b8796b638083812ca5f46d030">&#9670;&#160;</a></span>map_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::map_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">Lens</a> *</td>          <td class="paramname"><span class="paramname"><em>lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>Nimages</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>imageinfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>xmax</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>xmin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>initial_size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExitCriterion</td>          <td class="paramname"><span class="paramname"><em>criterion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>FindCenter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>divide_images</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find images and refine them based on their surface brightness distribution. </p>
<p>Finding </p>
<p>Uses <a class="el" href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist()</a> to initially find and refine images and then uses a surface brightness based criterion to refine the most important parts of the lens.</p>
<p>map_images is intended for mapping images of sources more complicated than simple circles.</p>
<p>No <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> refinement is done. </p>

</div>
</div>
<a id="a99ea033ac2888518f350e5dcc2fdc357" name="a99ea033ac2888518f350e5dcc2fdc357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99ea033ac2888518f350e5dcc2fdc357">&#9670;&#160;</a></span>mark_closest_point_source_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double Grid::mark_closest_point_source_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point__2d.html">Point_2d</a></td>          <td class="paramname"><span class="paramname"><em>y_source</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>r_source_max</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType</td>          <td class="paramname"><span class="paramname"><em>luminosity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>verbose</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function finds all the images for a circular source of radius r_source, then finds the points within each image that are closest to the center and then markes each surface brightness. Only one pixel per image gets flux. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>angular position of source,  </td></tr>
    <tr><td class="paramname">r_source_max</td><td>points outside this radius on the source plane will not be considered as in the image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef2864fc3791c44eed90c2e980777884" name="aef2864fc3791c44eed90c2e980777884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef2864fc3791c44eed90c2e980777884">&#9670;&#160;</a></span>RefineLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point.html">Point</a> * Grid::RefineLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a></td>          <td class="paramname"><span class="paramname"><em>lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *</td>          <td class="paramname"><span class="paramname"><em>point</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fundamental function used to divide a leaf in the tree into nine subcells. </p>
<p><a class="el" href="class_source.html" title="Base class for all sources.">Source</a> and image points are created, linked, shot and added to the trees. The leaf pointers of the points including the input are assigned.</p>
<p>If some of the of the points are outside the original grid they will not be added in which case THERE WILL BE LESS THEN Ngrid*Ngrid-1 points added. The true number will be result-&gt;head or, if no points are added, result = NULL.</p>
<p>Returns a pointer to the list of image points that have been added. This array can then be used for calculating the surface brightness or marking them as in the image.</p>
<p>i_tree current is left in one of the new subcells. </p>

</div>
</div>
<a id="a0974cb2286d5bc2ff4220fe57ab59875" name="a0974cb2286d5bc2ff4220fe57ab59875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0974cb2286d5bc2ff4220fe57ab59875">&#9670;&#160;</a></span>RefreshSurfaceBrightnesses()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType Grid::RefreshSurfaceBrightnesses </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *</td>          <td class="paramname"><span class="paramname"><em>source</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reshoot the rays with the same image postions. </p>
<p>Finding </p>
<p>The source positions and source tree are updated to the current lens model. The advantage over Grid::ReInitializeGrid() is that the image plane refinements are preserved.</p>
<p>void Grid::ReShoot(LensHndl lens){</p>
<p>PosType range,center[2];</p>
<p>range = i_tree-&gt;getTop()-&gt;boundary_p2[0] - i_tree-&gt;getTop()-&gt;boundary_p1[0]; center[0] = (i_tree-&gt;getTop()-&gt;boundary_p2[0] + i_tree-&gt;getTop()-&gt;boundary_p1[0])/2; center[1] = (i_tree-&gt;getTop()-&gt;boundary_p2[1] + i_tree-&gt;getTop()-&gt;boundary_p1[1])/2;</p>
<p><a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> newgrid(lens,Ngrid_init,center,rangeX,rangeY); </p><pre class="fragment">         Grid(LensHndl lens ,unsigned long Nx ,const PosType center[2] ,PosType rangeX ,PosType rangeY);
</pre><p> <a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> *i_points,*s_points;</p>
<p>unsigned long i;</p>
<p>clear source tree delete s_tree; s_points = NewPointArray(i_tree-&gt;pointlist.size()); s_points = point_factory(i_tree-&gt;pointlist.size());</p>
<p>build new initial grid PointList::iterator i_tree_pointlist_it; i_tree_pointlist_it.current = i_tree-&gt;pointlist.Top(); size_t k; for(i=0,k=0;i&lt;i_tree-&gt;pointlist.size();++i){ i_points = *i_tree_pointlist_it; if(i_points-&gt;head &gt; 0){</p>
<p>link source and image points for(size_t j=0;j&lt;i_points-&gt;head;++j,++k){ i_points[j].image = &amp;s_points[k]; s_points[k].image = &amp;i_points[j]; s_points[k].id = i_points[j].id; s_points[k].gridsize = i_points[j].gridsize; };</p>
<p>{ reshoot the rays std::lock_guard&lt;std::mutex&gt; hold(grid_mutex); lens-&gt;rayshooterInternal(i_points-&gt;head,i_points); } }</p>
<p>&ndash;i_tree_pointlist_it; }</p>
<p>s_tree = new <a class="el" href="struct_tree_struct.html" title="Tree: Exported struct.">TreeStruct</a>(s_points,s_points-&gt;head,1,(i_tree-&gt;getTop()-&gt;boundary_p2[0] - i_tree-&gt;getTop()-&gt;boundary_p1[0])/10 ); return; }</p>
<p>Recalculate surface brightness at every point without changing the positions of the grid or any lens properties.</p>
<p>Whatever is in the image is replaced with the one input source. Recalculate the surface brightness at all points on the grid. This is useful when changing the source model while preserving changes in the grid. Both i_tree and s_tree are both changed although only s_tree shows up here.</p>
<p>returns total flux </p>

</div>
</div>
<a id="a564ca633d349b420b157b6fe71a042b5" name="a564ca633d349b420b157b6fe71a042b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a564ca633d349b420b157b6fe71a042b5">&#9670;&#160;</a></span>writeFits() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Npixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a20dc795bf0466c365e06eae77ba7073f" name="a20dc795bf0466c365e06eae77ba7073f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dc795bf0466c365e06eae77ba7073f">&#9670;&#160;</a></span>writeFits() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension  </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in y dimension  </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a454205ce6790192d7e90d04ca9bdc20b" name="a454205ce6790192d7e90d04ca9bdc20b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454205ce6790192d7e90d04ca9bdc20b">&#9670;&#160;</a></span>writeFits() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>strech</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a fits image of whole grid region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strech</td><td>resolution relative to the initial resolution  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39b2d1ed7a7fc6c6798049885a2e0f8c" name="a39b2d1ed7a7fc6c6798049885a2e0f8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b2d1ed7a7fc6c6798049885a2e0f8c">&#9670;&#160;</a></span>writeFitsUniform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a fits map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="#a337d6e50ad7e7f02120df13cd4807094" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="#a564ca633d349b420b157b6fe71a042b5" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6db6d5bdc63482cae8b00b7bdd8f9f7" name="af6db6d5bdc63482cae8b00b7bdd8f9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6db6d5bdc63482cae8b00b7bdd8f9f7">&#9670;&#160;</a></span>writeFitsVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsVector </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Npixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits file for making plots of vector fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef25408943531718b008996d5eddb9cb" name="aef25408943531718b008996d5eddb9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef25408943531718b008996d5eddb9cb">&#9670;&#160;</a></span>writePixelFits()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixelFits </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed  </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a337d6e50ad7e7f02120df13cd4807094" name="a337d6e50ad7e7f02120df13cd4807094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337d6e50ad7e7f02120df13cd4807094">&#9670;&#160;</a></span>writePixelMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Npixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abff4c6aba9bdaf76da4cae273aa79fd5" name="abff4c6aba9bdaf76da4cae273aa79fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abff4c6aba9bdaf76da4cae273aa79fd5">&#9670;&#160;</a></span>writePixelMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9eb6203dc60ec0db35c8420a3fe99f46" name="a9eb6203dc60ec0db35c8420a3fe99f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eb6203dc60ec0db35c8420a3fe99f46">&#9670;&#160;</a></span>writePixelMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With the initial boundaries and resolution, ie no refinement. </p>
<p>Outputs a <a class="el" href="class_pixel_map.html" title="Image structure that can be manipulated and exported to/from fits files.">PixelMap</a> of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8a42e04085607e44ba84a08dc57573b" name="af8a42e04085607e44ba84a08dc57573b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a42e04085607e44ba84a08dc57573b">&#9670;&#160;</a></span>writePixelMapUniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType</td>          <td class="paramname"><span class="paramname"><em>center</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Nx</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>Ny</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Pixel map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="#a337d6e50ad7e7f02120df13cd4807094" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="#a564ca633d349b420b157b6fe71a042b5" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image  </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension  </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5074797acda5147b164176fa38e568ef" name="a5074797acda5147b164176fa38e568ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5074797acda5147b164176fa38e568ef">&#9670;&#160;</a></span>writePixelMapUniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a>&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>map</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="standard_8h.html#a73d5f5042d9b38366d0b3781d199f9e7">LensingVariable</a></td>          <td class="paramname"><span class="paramname"><em>lensvar</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dd646880c0c5f33af5869aab6b7c0f8" name="a0dd646880c0c5f33af5869aab6b7c0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd646880c0c5f33af5869aab6b7c0f8">&#9670;&#160;</a></span>zoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::zoom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a></td>          <td class="paramname"><span class="paramname"><em>lens</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>center</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_branch.html">Branch</a> *</td>          <td class="paramname"><span class="paramname"><em>top</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if point is in a region of uniform magnification using the kappa and gamma calculated from the rayshooter. </p>
<p>An estimate of the magnification matrix is returned if it returns true. Otherwise the magnification matrix is unspecified.</p>
<p>Magnification matrix elements are considered equal if their difference is smaller than maglimit which is set in the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> constructor.</p>
<p>quickly refines the grid down to a specific scale at a given point</p>
<p>top is an optional argument that allows for the zooming to start part way down the tree. Default is to start at the root. If the point is not within top or the root nothing is done. The point will not necessarily be in the center of the smallest branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of point where grid is refined  </td></tr>
    <tr><td class="paramname">scale</td><td>the smallest grid size to which the grid is refined  </td></tr>
    <tr><td class="paramname">top</td><td>where on the tree to start, if NULL it will start at the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a></li>
<li>SLsimLib/TreeCode_link/<b>grid_maintenance.cpp</b></li>
<li>SLsimLib/TreeCode_link/<b>image_finder.cpp</b></li>
<li>SLsimLib/TreeCode_link/<b>map_images.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 8 2024 19:31:03 for GLAMERDOC++ by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
