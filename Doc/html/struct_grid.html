<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>GLAMERDOC++: Grid Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Modules</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="struct_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grid Struct Reference<div class="ingroups"><a class="el" href="group___high_level.html">High Level Routines</a> &raquo; <a class="el" href="group___image_finding.html">Image Finding</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Structure to contain both source and image trees. It is not yet used, but may be useful.  
 <a href="struct_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Grid:</div>
<div class="dyncontent">
<div class="center"><img src="struct_grid__coll__graph.png" border="0" usemap="#_grid_coll__map" alt="Collaboration graph"/></div>
<map name="_grid_coll__map" id="_grid_coll__map">
<area shape="rect" id="node2" href="struct_tree_struct.html" title="Tree: Exported struct. " alt="" coords="384,497,467,525"/><area shape="rect" id="node17" href="struct_branch.html" title="The box representing a branch of a binary tree structure. Used specifically in TreeStruct for organiz..." alt="" coords="415,149,477,177"/><area shape="rect" id="node8" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities. " alt="" coords="383,269,435,297"/><area shape="rect" id="node27" href="struct_point_list.html" title="link list for points, uses the linking pointers within the Point type unlike Kist ..." alt="" coords="506,403,579,431"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a830c6822b5e6a6b022d11923dfebcefc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a830c6822b5e6a6b022d11923dfebcefc">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:a830c6822b5e6a6b022d11923dfebcefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing square grid.  <a href="#a830c6822b5e6a6b022d11923dfebcefc">More...</a><br /></td></tr>
<tr class="separator:a830c6822b5e6a6b022d11923dfebcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a892ed0bb5f45b92505d8d82cfe408c9e">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long Nx, const PosType center[2], PosType rangeX, PosType rangeY)</td></tr>
<tr class="memdesc:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing rectangular grid.  <a href="#a892ed0bb5f45b92505d8d82cfe408c9e">More...</a><br /></td></tr>
<tr class="separator:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661d0a7f998caaaf8627d7a67072116"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3661d0a7f998caaaf8627d7a67072116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a3661d0a7f998caaaf8627d7a67072116">~Grid</a> ()</td></tr>
<tr class="memdesc:a3661d0a7f998caaaf8627d7a67072116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful. ">Grid</a>. Frees all memory. <br /></td></tr>
<tr class="separator:a3661d0a7f998caaaf8627d7a67072116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24da72593941193758c4a98ee860b19"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaa24da72593941193758c4a98ee860b19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaa24da72593941193758c4a98ee860b19">ReInitializeGrid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:gaa24da72593941193758c4a98ee860b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the grid so that it is back to the original coarse grid, but if the lens has changed the source positions will be updated. <br /></td></tr>
<tr class="separator:gaa24da72593941193758c4a98ee860b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0893daf7e7db43564182f7847e8ee73e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga0893daf7e7db43564182f7847e8ee73e">ReShoot</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:ga0893daf7e7db43564182f7847e8ee73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshoot the rays with the same image postions.  <a href="group___image_finding.html#ga0893daf7e7db43564182f7847e8ee73e">More...</a><br /></td></tr>
<tr class="separator:ga0893daf7e7db43564182f7847e8ee73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a0dd646880c0c5f33af5869aab6b7c0f8">zoom</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, double *center, double scale, <a class="el" href="struct_branch.html">Branch</a> *top=NULL)</td></tr>
<tr class="memdesc:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">quickly refines the grid down to a specific scale at a given point  <a href="#a0dd646880c0c5f33af5869aab6b7c0f8">More...</a><br /></td></tr>
<tr class="separator:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11e8ae40a50d5f47f75920509466767"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gae11e8ae40a50d5f47f75920509466767">PruneTrees</a> (double resolution, bool useSB, double fluxlimit)</td></tr>
<tr class="memdesc:gae11e8ae40a50d5f47f75920509466767"><td class="mdescLeft">&#160;</td><td class="mdescRight">THIS DOES NOT WORK YET!!!  <a href="group___image_finding.html#gae11e8ae40a50d5f47f75920509466767">More...</a><br /></td></tr>
<tr class="separator:gae11e8ae40a50d5f47f75920509466767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gac8142d1e6206e19c8f83d21aee7fd03c">PrunePointsOutside</a> (double resolution, double *y, double r_in, double r_out)</td></tr>
<tr class="memdesc:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune off points that are below a resolution and in an annulus on the source plane.  <a href="group___image_finding_l2.html#gac8142d1e6206e19c8f83d21aee7fd03c">More...</a><br /></td></tr>
<tr class="separator:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaae2b3f9fe8cc6a464852e3441f22d8a9">RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness at every point without changing the positions of the grid or any lens properties.  <a href="group___image_finding.html#gaae2b3f9fe8cc6a464852e3441f22d8a9">More...</a><br /></td></tr>
<tr class="separator:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db542a5491a1b59f3c36278b830407"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25db542a5491a1b59f3c36278b830407"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a25db542a5491a1b59f3c36278b830407">ClearSurfaceBrightnesses</a> ()</td></tr>
<tr class="memdesc:a25db542a5491a1b59f3c36278b830407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the surface brightness and in_image flag in every point on image and source planes to zero (false) <br /></td></tr>
<tr class="separator:a25db542a5491a1b59f3c36278b830407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1edb65f70c0efc3a6cb58f556e30f165"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga1edb65f70c0efc3a6cb58f556e30f165"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga1edb65f70c0efc3a6cb58f556e30f165">getNumberOfPoints</a> () const </td></tr>
<tr class="memdesc:ga1edb65f70c0efc3a6cb58f556e30f165"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of points on image plane. <br /></td></tr>
<tr class="separator:ga1edb65f70c0efc3a6cb58f556e30f165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a0b60a7c609ab3b9883cc5facb28b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a338a0b60a7c609ab3b9883cc5facb28b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a338a0b60a7c609ab3b9883cc5facb28b">getInitNgrid</a> ()</td></tr>
<tr class="memdesc:a338a0b60a7c609ab3b9883cc5facb28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial number of grid points in each direction <br /></td></tr>
<tr class="separator:a338a0b60a7c609ab3b9883cc5facb28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c6c31b94541725e8f6ebb68e28366"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aff8c6c31b94541725e8f6ebb68e28366"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aff8c6c31b94541725e8f6ebb68e28366">getNgrid_block</a> ()</td></tr>
<tr class="memdesc:aff8c6c31b94541725e8f6ebb68e28366"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of cells in each dimension into which each cell is divided when a refinement is made <br /></td></tr>
<tr class="separator:aff8c6c31b94541725e8f6ebb68e28366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb414f884497255df53b5ba7ceb0f24"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aafb414f884497255df53b5ba7ceb0f24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aafb414f884497255df53b5ba7ceb0f24">getInitRange</a> ()</td></tr>
<tr class="memdesc:aafb414f884497255df53b5ba7ceb0f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial range of gridded region <br /></td></tr>
<tr class="separator:aafb414f884497255df53b5ba7ceb0f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31fd4cdeff36cbf37c878699197b126"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac31fd4cdeff36cbf37c878699197b126"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInitCenter</b> ()</td></tr>
<tr class="separator:ac31fd4cdeff36cbf37c878699197b126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2864fc3791c44eed90c2e980777884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884">RefineLeaf</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:gaef2864fc3791c44eed90c2e980777884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental function used to divide a leaf in the tree into nine subcells.  <a href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884">More...</a><br /></td></tr>
<tr class="separator:gaef2864fc3791c44eed90c2e980777884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7eed9868d59171a38dac0423cc25e7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d7eed9868d59171a38dac0423cc25e7"></a>
<a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a8d7eed9868d59171a38dac0423cc25e7">RefineLeaves</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;points)</td></tr>
<tr class="memdesc:a8d7eed9868d59171a38dac0423cc25e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884" title="Fundamental function used to divide a leaf in the tree into nine subcells. ">RefineLeaf()</a> but multiple points can be passed. The rays are shot all together so that more parallelization can be achieved in the rayshooting. <br /></td></tr>
<tr class="separator:a8d7eed9868d59171a38dac0423cc25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942b5f9d22c55c2b1cc9619991f1412"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3942b5f9d22c55c2b1cc9619991f1412"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a3942b5f9d22c55c2b1cc9619991f1412">ClearAllMarks</a> ()</td></tr>
<tr class="memdesc:a3942b5f9d22c55c2b1cc9619991f1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rest all in_image markers to False. <br /></td></tr>
<tr class="separator:a3942b5f9d22c55c2b1cc9619991f1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af459ba1188dd0c228ccba15ca5728e61"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af459ba1188dd0c228ccba15ca5728e61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test_mag_matrix</b> ()</td></tr>
<tr class="separator:af459ba1188dd0c228ccba15ca5728e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8815d0d3b3bec110d580340ff40621bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf">writeFits</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a8815d0d3b3bec110d580340ff40621bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <a href="#a8815d0d3b3bec110d580340ff40621bf">More...</a><br /></td></tr>
<tr class="separator:a8815d0d3b3bec110d580340ff40621bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c929444392293507dda639537748556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a1c929444392293507dda639537748556">writeFits</a> (const double center[], size_t Nx, size_t Ny, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a1c929444392293507dda639537748556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <a href="#a1c929444392293507dda639537748556">More...</a><br /></td></tr>
<tr class="separator:a1c929444392293507dda639537748556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e168760dc1117fa003f1da1ff3a1632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a1e168760dc1117fa003f1da1ff3a1632">writeFits</a> (double strech, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a1e168760dc1117fa003f1da1ff3a1632"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a fits image of whole grid region  <a href="#a1e168760dc1117fa003f1da1ff3a1632">More...</a><br /></td></tr>
<tr class="separator:a1e168760dc1117fa003f1da1ff3a1632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31126925edcb6d42579ac9c482453d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ae31126925edcb6d42579ac9c482453d6">writePixeFits</a> (size_t Nx, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:ae31126925edcb6d42579ac9c482453d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution.  <a href="#ae31126925edcb6d42579ac9c482453d6">More...</a><br /></td></tr>
<tr class="separator:ae31126925edcb6d42579ac9c482453d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6">writeFitsVector</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits file for making plots of vector fields.  <a href="#a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6">More...</a><br /></td></tr>
<tr class="separator:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91a7428c0994afbdd4b4a69877dc19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19">writePixelMap</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar)</td></tr>
<tr class="memdesc:a4d91a7428c0994afbdd4b4a69877dc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a <a class="el" href="class_pixel_map.html">PixelMap</a> of the lensing quantities of a fixed grid.  <a href="#a4d91a7428c0994afbdd4b4a69877dc19">More...</a><br /></td></tr>
<tr class="separator:a4d91a7428c0994afbdd4b4a69877dc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aea541cdaa9a981cde49b045022035"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#af6aea541cdaa9a981cde49b045022035">writePixelMap</a> (const double center[], size_t Nx, size_t Ny, double resolution, LensingVariable lensvar)</td></tr>
<tr class="memdesc:af6aea541cdaa9a981cde49b045022035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a <a class="el" href="class_pixel_map.html">PixelMap</a> of the lensing quantities of a fixed grid.  <a href="#af6aea541cdaa9a981cde49b045022035">More...</a><br /></td></tr>
<tr class="separator:af6aea541cdaa9a981cde49b045022035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a6ca7e1b7dd57ce1b051b84e4c542477d">writePixelMapUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar)</td></tr>
<tr class="memdesc:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Pixel map of the without distribution the pixels.  <a href="#a6ca7e1b7dd57ce1b051b84e4c542477d">More...</a><br /></td></tr>
<tr class="separator:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063530b0b7c7e5ffe1b85432fcad1498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a063530b0b7c7e5ffe1b85432fcad1498">writePixelMapUniform</a> (<a class="el" href="class_pixel_map.html">PixelMap</a> &amp;map, LensingVariable lensvar)</td></tr>
<tr class="separator:a063530b0b7c7e5ffe1b85432fcad1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd246a0f9e9c1f606d425989e742ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aa8dd246a0f9e9c1f606d425989e742ac">writeFitsUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:aa8dd246a0f9e9c1f606d425989e742ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a fits map of the without distribution the pixels.  <a href="#aa8dd246a0f9e9c1f606d425989e742ac">More...</a><br /></td></tr>
<tr class="separator:aa8dd246a0f9e9c1f606d425989e742ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae68f5779296176fee76a92c9f6076a73"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae68f5779296176fee76a92c9f6076a73"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ae68f5779296176fee76a92c9f6076a73">i_tree</a></td></tr>
<tr class="memdesc:ae68f5779296176fee76a92c9f6076a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on image plane <br /></td></tr>
<tr class="separator:ae68f5779296176fee76a92c9f6076a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda62e6b854e898781e85abd5a8e751"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abeda62e6b854e898781e85abd5a8e751"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#abeda62e6b854e898781e85abd5a8e751">s_tree</a></td></tr>
<tr class="memdesc:abeda62e6b854e898781e85abd5a8e751"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on source plane <br /></td></tr>
<tr class="separator:abeda62e6b854e898781e85abd5a8e751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acd0ac782365bf5a2c48ebfe54e45d8db"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd0ac782365bf5a2c48ebfe54e45d8db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xygridpoints</b> (<a class="el" href="struct_point.html">Point</a> *points, double range, const double *center, long Ngrid, short remove_center)</td></tr>
<tr class="separator:acd0ac782365bf5a2c48ebfe54e45d8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c2462e60d79df7aad962557c4bf524"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ab4c2462e60d79df7aad962557c4bf524">find_mag_matrix</a> (double *a, <a class="el" href="struct_point.html">Point</a> *p0, <a class="el" href="struct_point.html">Point</a> *p1, <a class="el" href="struct_point.html">Point</a> *p2)</td></tr>
<tr class="memdesc:ab4c2462e60d79df7aad962557c4bf524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the magnification given three points.  <a href="#ab4c2462e60d79df7aad962557c4bf524">More...</a><br /></td></tr>
<tr class="separator:ab4c2462e60d79df7aad962557c4bf524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe4d0ab56bb70514f15bf7ad7e0d241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aebe4d0ab56bb70514f15bf7ad7e0d241">uniform_mag_from_deflect</a> (double *a, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:aebe4d0ab56bb70514f15bf7ad7e0d241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if point is in a region of uniform magnification using only the deflections of the point and its neighbors.  <a href="#aebe4d0ab56bb70514f15bf7ad7e0d241">More...</a><br /></td></tr>
<tr class="separator:aebe4d0ab56bb70514f15bf7ad7e0d241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b9c0634c56c7c03cb81fa5c0eac8f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ac5b9c0634c56c7c03cb81fa5c0eac8f2">uniform_mag_from_shooter</a> (double *a, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:ac5b9c0634c56c7c03cb81fa5c0eac8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if point is in a region of uniform magnification using the kappa and gamma calculated from the rayshooter.  <a href="#ac5b9c0634c56c7c03cb81fa5c0eac8f2">More...</a><br /></td></tr>
<tr class="separator:ac5b9c0634c56c7c03cb81fa5c0eac8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c13e152fbcd5db636eaaa222d42e87a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6c13e152fbcd5db636eaaa222d42e87a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>writePixelMapUniform_</b> (const <a class="el" href="struct_point_list.html">PointList</a> &amp;list, <a class="el" href="class_pixel_map.html">PixelMap</a> *map, LensingVariable val)</td></tr>
<tr class="separator:a6c13e152fbcd5db636eaaa222d42e87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a27427e79ae9c3bf1fa9b18e659ebda41"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27427e79ae9c3bf1fa9b18e659ebda41"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a27427e79ae9c3bf1fa9b18e659ebda41">Ngrid_init</a></td></tr>
<tr class="memdesc:a27427e79ae9c3bf1fa9b18e659ebda41"><td class="mdescLeft">&#160;</td><td class="mdescRight">one dimensional size of initial grid <br /></td></tr>
<tr class="separator:a27427e79ae9c3bf1fa9b18e659ebda41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af16a33106713d179b927bc260727c5a8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af16a33106713d179b927bc260727c5a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>Ngrid_init2</b></td></tr>
<tr class="separator:af16a33106713d179b927bc260727c5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153d8e89965c1047ea0a2f3f138013d3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a153d8e89965c1047ea0a2f3f138013d3"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a153d8e89965c1047ea0a2f3f138013d3">Ngrid_block</a></td></tr>
<tr class="memdesc:a153d8e89965c1047ea0a2f3f138013d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">one dimensional number of cells a cell will be divided into on each refinement step <br /></td></tr>
<tr class="separator:a153d8e89965c1047ea0a2f3f138013d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c41e5d339f2e5294379d2c97f6746a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a36c41e5d339f2e5294379d2c97f6746a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>initialized</b></td></tr>
<tr class="separator:a36c41e5d339f2e5294379d2c97f6746a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcd4c9b6f74953ba2094a9fbbeffbf31"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcd4c9b6f74953ba2094a9fbbeffbf31"></a>
Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>trashkist</b></td></tr>
<tr class="separator:afcd4c9b6f74953ba2094a9fbbeffbf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa0fcbcf2ffb05e874da4008c7812e6"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeaa0fcbcf2ffb05e874da4008c7812e6"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>maglimit</b></td></tr>
<tr class="separator:aeaa0fcbcf2ffb05e874da4008c7812e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bf10027faf169a24ae0dbad213c0f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a20bf10027faf169a24ae0dbad213c0f0"></a>
Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><b>neighbors</b></td></tr>
<tr class="separator:a20bf10027faf169a24ae0dbad213c0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77291fa5f511f2a93596436a5c14f60e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a77291fa5f511f2a93596436a5c14f60e"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>pointID</b></td></tr>
<tr class="separator:a77291fa5f511f2a93596436a5c14f60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85410867a73b0065e1592be71bcaf171"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a85410867a73b0065e1592be71bcaf171"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><b>axisratio</b></td></tr>
<tr class="separator:a85410867a73b0065e1592be71bcaf171"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:ad7e9b73f8a944b413add4e724ffdd273"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7e9b73f8a944b413add4e724ffdd273"></a>
static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>grid_mutex</b></td></tr>
<tr class="separator:ad7e9b73f8a944b413add4e724ffdd273"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure to contain both source and image trees. It is not yet used, but may be useful. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a830c6822b5e6a6b022d11923dfebcefc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing square grid. </p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid (usually in radian units) </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a892ed0bb5f45b92505d8d82cfe408c9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing rectangular grid. </p>
<p>Cells of grid will always be square with initial resolution rangeX/(Nx-1). The Y range may not be exactly rangeY, but will be the nearest value that is a whole number of cells.</p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">Nx</td><td>Initial number of grid points in X dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">rangeX</td><td>Full width of grid in x direction in whatever units will be used. </td></tr>
    <tr><td class="paramname">rangeY</td><td>Full width of grid in y direction in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab4c2462e60d79df7aad962557c4bf524"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Grid::find_mag_matrix </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the magnification given three points. </p>
<p>The points must have attached source/image points and they must not be colinear. Returns false if they are colinear</p>
<p>a[0] = a11, a[1] = a22, a[2] = a12, a[3] = a21 </p>

</div>
</div>
<a class="anchor" id="aebe4d0ab56bb70514f15bf7ad7e0d241"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Grid::uniform_mag_from_deflect </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if point is in a region of uniform magnification using only the deflections of the point and its neighbors. </p>
<p>An estimate of the magnification matrix is returned if it returns true. Otherwise the magnification matrix is unspecified.</p>
<p>Magnification matrix elements are considered equal if their difference is smaller than maglimit which is set in the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful. ">Grid</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Returned magnification matrix, not specified if returning false </td></tr>
    <tr><td class="paramname">point</td><td>point to be tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5b9c0634c56c7c03cb81fa5c0eac8f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Grid::uniform_mag_from_shooter </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if point is in a region of uniform magnification using the kappa and gamma calculated from the rayshooter. </p>
<p>An estimate of the magnification matrix is returned if it returns true. Otherwise the magnification matrix is unspecified.</p>
<p>Magnification matrix elements are considered equal if their difference is smaller than maglimit which is set in the <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful. ">Grid</a> constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Returned magnification matrix, not specified if returning false </td></tr>
    <tr><td class="paramname">point</td><td>point to be tested </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8815d0d3b3bec110d580340ff40621bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1c929444392293507dda639537748556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in y dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e168760dc1117fa003f1da1ff3a1632"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>strech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a fits image of whole grid region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strech</td><td>resolution relative to the initial resolution </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa8dd246a0f9e9c1f606d425989e742ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a fits map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid. ">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice. ">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsVector </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits file for making plots of vector fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae31126925edcb6d42579ac9c482453d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixeFits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d91a7428c0994afbdd4b4a69877dc19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a <a class="el" href="class_pixel_map.html">PixelMap</a> of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af6aea541cdaa9a981cde49b045022035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a <a class="el" href="class_pixel_map.html">PixelMap</a> of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6ca7e1b7dd57ce1b051b84e4c542477d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Pixel map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid. ">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice. ">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a063530b0b7c7e5ffe1b85432fcad1498"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_pixel_map.html">PixelMap</a> &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0dd646880c0c5f33af5869aab6b7c0f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::zoom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_branch.html">Branch</a> *&#160;</td>
          <td class="paramname"><em>top</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quickly refines the grid down to a specific scale at a given point </p>
<p>top is an optional argument that allows for the zooming to start part way down the tree. Default is to start at the root. If the point is not within top or the root nothing is done. The point will not necessarily be in the center of the smallest branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of point where grid is refined </td></tr>
    <tr><td class="paramname">scale</td><td>the smallest grid size to which the grid is refined </td></tr>
    <tr><td class="paramname">top</td><td>where on the tree to start, if NULL it will start at the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a></li>
<li>SLsimLib/TreeCode_link/grid_maintenance.cpp</li>
<li>SLsimLib/TreeCode_link/image_finder.cpp</li>
<li>SLsimLib/TreeCode_link/tree_maintenance.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 5 2017 15:47:22 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
