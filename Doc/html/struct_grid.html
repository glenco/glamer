<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: Grid Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_grid-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Grid Struct Reference<div class="ingroups"><a class="el" href="group___high_level.html">High Level Routines</a> &raquo; <a class="el" href="group___image_finding.html">Image Finding</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Structure to contain both source and image trees. It is not yet used, but may be useful.  
 <a href="struct_grid.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Grid:</div>
<div class="dyncontent">
<div class="center"><img src="struct_grid__coll__graph.png" border="0" usemap="#_grid_coll__map" alt="Collaboration graph"/></div>
<map name="_grid_coll__map" id="_grid_coll__map">
<area shape="rect"  href="struct_tree_struct.html" title="Tree: Exported struct. " alt="" coords="5,99,88,127"/>
<area shape="rect"  href="struct_point_list.html" title="link list for points, uses the linking pointers within the Point type unlike Kist ..." alt="" coords="10,6,83,34"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a830c6822b5e6a6b022d11923dfebcefc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a830c6822b5e6a6b022d11923dfebcefc">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long N1d, const double center[2], double range)</td></tr>
<tr class="memdesc:a830c6822b5e6a6b022d11923dfebcefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing square grid.  <a href="#a830c6822b5e6a6b022d11923dfebcefc">More...</a><br /></td></tr>
<tr class="separator:a830c6822b5e6a6b022d11923dfebcefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a892ed0bb5f45b92505d8d82cfe408c9e">Grid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, unsigned long Nx, const PosType center[2], PosType rangeX, PosType rangeY)</td></tr>
<tr class="memdesc:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for initializing rectangular grid.  <a href="#a892ed0bb5f45b92505d8d82cfe408c9e">More...</a><br /></td></tr>
<tr class="separator:a892ed0bb5f45b92505d8d82cfe408c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3661d0a7f998caaaf8627d7a67072116"><td class="memItemLeft" align="right" valign="top"><a id="a3661d0a7f998caaaf8627d7a67072116"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a3661d0a7f998caaaf8627d7a67072116">~Grid</a> ()</td></tr>
<tr class="memdesc:a3661d0a7f998caaaf8627d7a67072116"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor for a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a>. Frees all memory. <br /></td></tr>
<tr class="separator:a3661d0a7f998caaaf8627d7a67072116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa24da72593941193758c4a98ee860b19"><td class="memItemLeft" align="right" valign="top">
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaa24da72593941193758c4a98ee860b19">ReInitializeGrid</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:gaa24da72593941193758c4a98ee860b19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reinitializes the grid so that it is back to the original coarse grid, but if the lens has changed the source positions will be updated. <br /></td></tr>
<tr class="separator:gaa24da72593941193758c4a98ee860b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0893daf7e7db43564182f7847e8ee73e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga0893daf7e7db43564182f7847e8ee73e">ReShoot</a> (<a class="el" href="class_lens.html">LensHndl</a> lens)</td></tr>
<tr class="memdesc:ga0893daf7e7db43564182f7847e8ee73e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reshoot the rays with the same image postions.  <a href="group___image_finding.html#ga0893daf7e7db43564182f7847e8ee73e">More...</a><br /></td></tr>
<tr class="separator:ga0893daf7e7db43564182f7847e8ee73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a0dd646880c0c5f33af5869aab6b7c0f8">zoom</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, double *center, double scale, <a class="el" href="struct_branch.html">Branch</a> *top=NULL)</td></tr>
<tr class="memdesc:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">quickly refines the grid down to a specific scale at a given point  <a href="#a0dd646880c0c5f33af5869aab6b7c0f8">More...</a><br /></td></tr>
<tr class="separator:a0dd646880c0c5f33af5869aab6b7c0f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae11e8ae40a50d5f47f75920509466767"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gae11e8ae40a50d5f47f75920509466767">PruneTrees</a> (double resolution, bool useSB, double fluxlimit)</td></tr>
<tr class="memdesc:gae11e8ae40a50d5f47f75920509466767"><td class="mdescLeft">&#160;</td><td class="mdescRight">THIS DOES NOT WORK YET!!!  <a href="group___image_finding.html#gae11e8ae40a50d5f47f75920509466767">More...</a><br /></td></tr>
<tr class="separator:gae11e8ae40a50d5f47f75920509466767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gac8142d1e6206e19c8f83d21aee7fd03c">PrunePointsOutside</a> (double resolution, double *y, double r_in, double r_out)</td></tr>
<tr class="memdesc:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune off points that are below a resolution and in an annulus on the source plane.  <a href="group___image_finding_l2.html#gac8142d1e6206e19c8f83d21aee7fd03c">More...</a><br /></td></tr>
<tr class="separator:gac8142d1e6206e19c8f83d21aee7fd03c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#gaae2b3f9fe8cc6a464852e3441f22d8a9">RefreshSurfaceBrightnesses</a> (<a class="el" href="class_source.html">SourceHndl</a> source)</td></tr>
<tr class="memdesc:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculate surface brightness at every point without changing the positions of the grid or any lens properties.  <a href="group___image_finding.html#gaae2b3f9fe8cc6a464852e3441f22d8a9">More...</a><br /></td></tr>
<tr class="separator:gaae2b3f9fe8cc6a464852e3441f22d8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25db542a5491a1b59f3c36278b830407"><td class="memItemLeft" align="right" valign="top"><a id="a25db542a5491a1b59f3c36278b830407"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a25db542a5491a1b59f3c36278b830407">ClearSurfaceBrightnesses</a> ()</td></tr>
<tr class="memdesc:a25db542a5491a1b59f3c36278b830407"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the surface brightness and in_image flag in every point on image and source planes to zero (false) <br /></td></tr>
<tr class="separator:a25db542a5491a1b59f3c36278b830407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memItemLeft" align="right" valign="top">
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding.html#ga4b84bc9acf6cbeff3a6da1f3dca202e1">getNumberOfPoints</a> () const</td></tr>
<tr class="memdesc:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of points on image plane. <br /></td></tr>
<tr class="separator:ga4b84bc9acf6cbeff3a6da1f3dca202e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fc09f6be7248237f1edea5830bab43"><td class="memItemLeft" align="right" valign="top"><a id="a27fc09f6be7248237f1edea5830bab43"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a27fc09f6be7248237f1edea5830bab43">EinsteinArea</a> () const</td></tr>
<tr class="memdesc:a27fc09f6be7248237f1edea5830bab43"><td class="mdescLeft">&#160;</td><td class="mdescRight">area of region with negative magnification <br /></td></tr>
<tr class="separator:a27fc09f6be7248237f1edea5830bab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a338a0b60a7c609ab3b9883cc5facb28b"><td class="memItemLeft" align="right" valign="top"><a id="a338a0b60a7c609ab3b9883cc5facb28b"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a338a0b60a7c609ab3b9883cc5facb28b">getInitNgrid</a> ()</td></tr>
<tr class="memdesc:a338a0b60a7c609ab3b9883cc5facb28b"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial number of grid points in each direction <br /></td></tr>
<tr class="separator:a338a0b60a7c609ab3b9883cc5facb28b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8c6c31b94541725e8f6ebb68e28366"><td class="memItemLeft" align="right" valign="top"><a id="aff8c6c31b94541725e8f6ebb68e28366"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aff8c6c31b94541725e8f6ebb68e28366">getNgrid_block</a> ()</td></tr>
<tr class="memdesc:aff8c6c31b94541725e8f6ebb68e28366"><td class="mdescLeft">&#160;</td><td class="mdescRight">return number of cells in each dimension into which each cell is divided when a refinement is made <br /></td></tr>
<tr class="separator:aff8c6c31b94541725e8f6ebb68e28366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafb414f884497255df53b5ba7ceb0f24"><td class="memItemLeft" align="right" valign="top"><a id="aafb414f884497255df53b5ba7ceb0f24"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aafb414f884497255df53b5ba7ceb0f24">getInitRange</a> ()</td></tr>
<tr class="memdesc:aafb414f884497255df53b5ba7ceb0f24"><td class="mdescLeft">&#160;</td><td class="mdescRight">return initial range of gridded region <br /></td></tr>
<tr class="separator:aafb414f884497255df53b5ba7ceb0f24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31fd4cdeff36cbf37c878699197b126"><td class="memItemLeft" align="right" valign="top"><a id="ac31fd4cdeff36cbf37c878699197b126"></a>
<a class="el" href="struct_point__2d.html">Point_2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getInitCenter</b> ()</td></tr>
<tr class="separator:ac31fd4cdeff36cbf37c878699197b126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef2864fc3791c44eed90c2e980777884"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884">RefineLeaf</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:gaef2864fc3791c44eed90c2e980777884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fundamental function used to divide a leaf in the tree into nine subcells.  <a href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884">More...</a><br /></td></tr>
<tr class="separator:gaef2864fc3791c44eed90c2e980777884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7eed9868d59171a38dac0423cc25e7"><td class="memItemLeft" align="right" valign="top"><a id="a8d7eed9868d59171a38dac0423cc25e7"></a>
<a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a8d7eed9868d59171a38dac0423cc25e7">RefineLeaves</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;points)</td></tr>
<tr class="memdesc:a8d7eed9868d59171a38dac0423cc25e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="group___image_finding_l2.html#gaef2864fc3791c44eed90c2e980777884" title="Fundamental function used to divide a leaf in the tree into nine subcells.">RefineLeaf()</a> but multiple points can be passed. The rays are shot all together so that more parallelization can be achieved in the rayshooting. <br /></td></tr>
<tr class="separator:a8d7eed9868d59171a38dac0423cc25e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3942b5f9d22c55c2b1cc9619991f1412"><td class="memItemLeft" align="right" valign="top"><a id="a3942b5f9d22c55c2b1cc9619991f1412"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a3942b5f9d22c55c2b1cc9619991f1412">ClearAllMarks</a> ()</td></tr>
<tr class="memdesc:a3942b5f9d22c55c2b1cc9619991f1412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rest all in_image markers to False. <br /></td></tr>
<tr class="separator:a3942b5f9d22c55c2b1cc9619991f1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af459ba1188dd0c228ccba15ca5728e61"><td class="memItemLeft" align="right" valign="top"><a id="af459ba1188dd0c228ccba15ca5728e61"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>test_mag_matrix</b> ()</td></tr>
<tr class="separator:af459ba1188dd0c228ccba15ca5728e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8815d0d3b3bec110d580340ff40621bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf">writeFits</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a8815d0d3b3bec110d580340ff40621bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <a href="#a8815d0d3b3bec110d580340ff40621bf">More...</a><br /></td></tr>
<tr class="separator:a8815d0d3b3bec110d580340ff40621bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c929444392293507dda639537748556"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a1c929444392293507dda639537748556">writeFits</a> (const double center[], size_t Nx, size_t Ny, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a1c929444392293507dda639537748556"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits image of a lensing variable of choice.  <a href="#a1c929444392293507dda639537748556">More...</a><br /></td></tr>
<tr class="separator:a1c929444392293507dda639537748556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e168760dc1117fa003f1da1ff3a1632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a1e168760dc1117fa003f1da1ff3a1632">writeFits</a> (double strech, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a1e168760dc1117fa003f1da1ff3a1632"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a fits image of whole grid region  <a href="#a1e168760dc1117fa003f1da1ff3a1632">More...</a><br /></td></tr>
<tr class="separator:a1e168760dc1117fa003f1da1ff3a1632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31126925edcb6d42579ac9c482453d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ae31126925edcb6d42579ac9c482453d6">writePixeFits</a> (size_t Nx, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:ae31126925edcb6d42579ac9c482453d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution.  <a href="#ae31126925edcb6d42579ac9c482453d6">More...</a><br /></td></tr>
<tr class="separator:ae31126925edcb6d42579ac9c482453d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6">writeFitsVector</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a fits file for making plots of vector fields.  <a href="#a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6">More...</a><br /></td></tr>
<tr class="separator:a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d91a7428c0994afbdd4b4a69877dc19"><td class="memItemLeft" align="right" valign="top">PixelMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19">writePixelMap</a> (const double center[], size_t Npixels, double resolution, LensingVariable lensvar)</td></tr>
<tr class="memdesc:a4d91a7428c0994afbdd4b4a69877dc19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a PixelMap of the lensing quantities of a fixed grid.  <a href="#a4d91a7428c0994afbdd4b4a69877dc19">More...</a><br /></td></tr>
<tr class="separator:a4d91a7428c0994afbdd4b4a69877dc19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6aea541cdaa9a981cde49b045022035"><td class="memItemLeft" align="right" valign="top">PixelMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#af6aea541cdaa9a981cde49b045022035">writePixelMap</a> (const double center[], size_t Nx, size_t Ny, double resolution, LensingVariable lensvar)</td></tr>
<tr class="memdesc:af6aea541cdaa9a981cde49b045022035"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs a PixelMap of the lensing quantities of a fixed grid.  <a href="#af6aea541cdaa9a981cde49b045022035">More...</a><br /></td></tr>
<tr class="separator:af6aea541cdaa9a981cde49b045022035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709e743b55dee970df1d199029c6f723"><td class="memItemLeft" align="right" valign="top">PixelMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a709e743b55dee970df1d199029c6f723">writePixelMap</a> (LensingVariable lensvar)</td></tr>
<tr class="memdesc:a709e743b55dee970df1d199029c6f723"><td class="mdescLeft">&#160;</td><td class="mdescRight">With the initial boundaries and resolution, ie no refinement.  <a href="#a709e743b55dee970df1d199029c6f723">More...</a><br /></td></tr>
<tr class="separator:a709e743b55dee970df1d199029c6f723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797067dc0d3104916e78b36f6d4d0dd6"><td class="memItemLeft" align="right" valign="top"><a id="a797067dc0d3104916e78b36f6d4d0dd6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a797067dc0d3104916e78b36f6d4d0dd6">MapSurfaceBrightness</a> (PixelMap &amp;map)</td></tr>
<tr class="memdesc:a797067dc0d3104916e78b36f6d4d0dd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">make image of surface brightness <br /></td></tr>
<tr class="separator:a797067dc0d3104916e78b36f6d4d0dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98811bdf4d3b3baded53966291654e0"><td class="memItemLeft" align="right" valign="top"><a id="ad98811bdf4d3b3baded53966291654e0"></a>
PixelMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ad98811bdf4d3b3baded53966291654e0">MapSurfaceBrightness</a> (double resolution)</td></tr>
<tr class="memdesc:ad98811bdf4d3b3baded53966291654e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">map a map of the whole gridded area with given resolution <br /></td></tr>
<tr class="separator:ad98811bdf4d3b3baded53966291654e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="memItemLeft" align="right" valign="top">PixelMap&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a6ca7e1b7dd57ce1b051b84e4c542477d">writePixelMapUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar)</td></tr>
<tr class="memdesc:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a Pixel map of the without distribution the pixels.  <a href="#a6ca7e1b7dd57ce1b051b84e4c542477d">More...</a><br /></td></tr>
<tr class="separator:a6ca7e1b7dd57ce1b051b84e4c542477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a063530b0b7c7e5ffe1b85432fcad1498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#a063530b0b7c7e5ffe1b85432fcad1498">writePixelMapUniform</a> (PixelMap &amp;map, LensingVariable lensvar)</td></tr>
<tr class="separator:a063530b0b7c7e5ffe1b85432fcad1498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8dd246a0f9e9c1f606d425989e742ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#aa8dd246a0f9e9c1f606d425989e742ac">writeFitsUniform</a> (const PosType center[], size_t Nx, size_t Ny, LensingVariable lensvar, std::string filename)</td></tr>
<tr class="memdesc:aa8dd246a0f9e9c1f606d425989e742ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output a fits map of the without distribution the pixels.  <a href="#aa8dd246a0f9e9c1f606d425989e742ac">More...</a><br /></td></tr>
<tr class="separator:aa8dd246a0f9e9c1f606d425989e742ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292378167185b8eb18245060b21a13c6"><td class="memItemLeft" align="right" valign="top"><a id="a292378167185b8eb18245060b21a13c6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Grid</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a292378167185b8eb18245060b21a13c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225f3c122c472daa49a8686005325c86"><td class="memItemLeft" align="right" valign="top"><a id="a225f3c122c472daa49a8686005325c86"></a>
<a class="el" href="struct_grid.html">Grid</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="struct_grid.html">Grid</a> &amp;&amp;grid)</td></tr>
<tr class="separator:a225f3c122c472daa49a8686005325c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31b9263380798f393f967f2d087a7da"><td class="memItemLeft" align="right" valign="top"><a id="ae31b9263380798f393f967f2d087a7da"></a>
PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ae31b9263380798f393f967f2d087a7da">magnification</a> () const</td></tr>
<tr class="memdesc:ae31b9263380798f393f967f2d087a7da"><td class="mdescLeft">&#160;</td><td class="mdescRight">flux weighted magnification <br /></td></tr>
<tr class="separator:ae31b9263380798f393f967f2d087a7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae68f5779296176fee76a92c9f6076a73"><td class="memItemLeft" align="right" valign="top"><a id="ae68f5779296176fee76a92c9f6076a73"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#ae68f5779296176fee76a92c9f6076a73">i_tree</a></td></tr>
<tr class="memdesc:ae68f5779296176fee76a92c9f6076a73"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on image plane <br /></td></tr>
<tr class="separator:ae68f5779296176fee76a92c9f6076a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeda62e6b854e898781e85abd5a8e751"><td class="memItemLeft" align="right" valign="top"><a id="abeda62e6b854e898781e85abd5a8e751"></a>
<a class="el" href="struct_tree_struct.html">TreeHndl</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_grid.html#abeda62e6b854e898781e85abd5a8e751">s_tree</a></td></tr>
<tr class="memdesc:abeda62e6b854e898781e85abd5a8e751"><td class="mdescLeft">&#160;</td><td class="mdescRight">tree on source plane <br /></td></tr>
<tr class="separator:abeda62e6b854e898781e85abd5a8e751"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structure to contain both source and image trees. It is not yet used, but may be useful. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a830c6822b5e6a6b022d11923dfebcefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830c6822b5e6a6b022d11923dfebcefc">&#9670;&nbsp;</a></span>Grid() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>N1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing square grid. </p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">N1d</td><td>Initial number of grid points in each dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid (usually in radian units) </td></tr>
    <tr><td class="paramname">range</td><td>Full width of grid in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a892ed0bb5f45b92505d8d82cfe408c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892ed0bb5f45b92505d8d82cfe408c9e">&#9670;&nbsp;</a></span>Grid() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Grid::Grid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rangeY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for initializing rectangular grid. </p>
<p>Cells of grid will always be square with initial resolution rangeX/(Nx-1). The Y range may not be exactly rangeY, but will be the nearest value that is a whole number of cells.</p>
<p>Note: Deflection solver must be specified before creating a <a class="el" href="struct_grid.html" title="Structure to contain both source and image trees. It is not yet used, but may be useful.">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>lens model for initializing grid </td></tr>
    <tr><td class="paramname">Nx</td><td>Initial number of grid points in X dimension. </td></tr>
    <tr><td class="paramname">center</td><td>Center of grid. </td></tr>
    <tr><td class="paramname">rangeX</td><td>Full width of grid in x direction in whatever units will be used. </td></tr>
    <tr><td class="paramname">rangeY</td><td>Full width of grid in y direction in whatever units will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8815d0d3b3bec110d580340ff40621bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8815d0d3b3bec110d580340ff40621bf">&#9670;&nbsp;</a></span>writeFits() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c929444392293507dda639537748556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c929444392293507dda639537748556">&#9670;&nbsp;</a></span>writeFits() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits image of a lensing variable of choice. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in y dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1e168760dc1117fa003f1da1ff3a1632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e168760dc1117fa003f1da1ff3a1632">&#9670;&nbsp;</a></span>writeFits() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFits </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>strech</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make a fits image of whole grid region </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strech</td><td>resolution relative to the initial resolution </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8dd246a0f9e9c1f606d425989e742ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8dd246a0f9e9c1f606d425989e742ac">&#9670;&nbsp;</a></span>writeFitsUniform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Output a fits map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7d66b6c8bbbf4e0c4cc4cb014fc4e6">&#9670;&nbsp;</a></span>writeFitsVector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writeFitsVector </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a fits file for making plots of vector fields. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae31126925edcb6d42579ac9c482453d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31126925edcb6d42579ac9c482453d6">&#9670;&nbsp;</a></span>writePixeFits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixeFits </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a fits map that is automatically centered on the grid and has approximately the same range as the grid. Nx can be used to change the resolution. Nx = grid.getInitNgrid() will give the initial grid resolution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nx</td><td>number of pixels in image in x dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
    <tr><td class="paramname">filename</td><td>file name for image &ndash; .kappa.fits, .gamma1.fits, etc will be appended </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d91a7428c0994afbdd4b4a69877dc19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d91a7428c0994afbdd4b4a69877dc19">&#9670;&nbsp;</a></span>writePixelMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PixelMap Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Npixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a PixelMap of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Npixels</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6aea541cdaa9a981cde49b045022035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6aea541cdaa9a981cde49b045022035">&#9670;&nbsp;</a></span>writePixelMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PixelMap Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs a PixelMap of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">resolution</td><td>resolution of image in radians </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a709e743b55dee970df1d199029c6f723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709e743b55dee970df1d199029c6f723">&#9670;&nbsp;</a></span>writePixelMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PixelMap Grid::writePixelMap </td>
          <td>(</td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>With the initial boundaries and resolution, ie no refinement. </p>
<p>Outputs a PixelMap of the lensing quantities of a fixed grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ca7e1b7dd57ce1b051b84e4c542477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca7e1b7dd57ce1b051b84e4c542477d">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PixelMap Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">const PosType&#160;</td>
          <td class="paramname"><em>center</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Nx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>Ny</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a Pixel map of the without distribution the pixels. </p>
<p>This will be faster than <a class="el" href="struct_grid.html#a4d91a7428c0994afbdd4b4a69877dc19" title="Outputs a PixelMap of the lensing quantities of a fixed grid.">Grid::writePixelMap()</a> and <a class="el" href="struct_grid.html#a8815d0d3b3bec110d580340ff40621bf" title="Outputs a fits image of a lensing variable of choice.">Grid::writeFits()</a>. But it puts each grid pixel in one pixelmap pixel and if there are two grid pixels in one pixelmap pixel it uses one at random. This is meant for uniform maps to make equal sized PixelMaps. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of image </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">Ny</td><td>number of pixels in image in on dimension </td></tr>
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a063530b0b7c7e5ffe1b85432fcad1498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a063530b0b7c7e5ffe1b85432fcad1498">&#9670;&nbsp;</a></span>writePixelMapUniform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::writePixelMapUniform </td>
          <td>(</td>
          <td class="paramtype">PixelMap &amp;&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>lensvar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lensvar</td><td>which quantity is to be displayed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0dd646880c0c5f33af5869aab6b7c0f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd646880c0c5f33af5869aab6b7c0f8">&#9670;&nbsp;</a></span>zoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Grid::zoom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_branch.html">Branch</a> *&#160;</td>
          <td class="paramname"><em>top</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>quickly refines the grid down to a specific scale at a given point </p>
<p>top is an optional argument that allows for the zooming to start part way down the tree. Default is to start at the root. If the point is not within top or the root nothing is done. The point will not necessarily be in the center of the smallest branch. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of point where grid is refined </td></tr>
    <tr><td class="paramname">scale</td><td>the smallest grid size to which the grid is refined </td></tr>
    <tr><td class="paramname">top</td><td>where on the tree to start, if NULL it will start at the root </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="grid__maintenance_8h_source.html">grid_maintenance.h</a></li>
<li>SLsimLib/TreeCode_link/grid_maintenance.cpp</li>
<li>SLsimLib/TreeCode_link/image_finder.cpp</li>
<li>SLsimLib/TreeCode_link/tree_maintenance.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Jun 26 2019 08:44:30 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
