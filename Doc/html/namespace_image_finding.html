<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: ImageFinding Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ImageFinding Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="namespace_image_finding.html" title="The ImageFinding namespace is for functions related to finding and mapping images.">ImageFinding</a> namespace is for functions related to finding and mapping images.  
<a href="namespace_image_finding.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a84da40a884b9a6fd16038de225b51dc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7">find_images_kist</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, PosType *y_source, PosType r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, PosType initial_size, bool splitimages, short edge_refinement, bool verbose=false)</td></tr>
<tr class="memdesc:a84da40a884b9a6fd16038de225b51dc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images given a source position and size.  <a href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7">More...</a><br /></td></tr>
<tr class="separator:a84da40a884b9a6fd16038de225b51dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df229d3fd4cccd2a4ae17fa7edfa258"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a4df229d3fd4cccd2a4ae17fa7edfa258">find_images_microlens</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, double *y_source, double r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, double initial_size, double mu_min, bool splitimages, short edge_refinement, bool verbose)</td></tr>
<tr class="memdesc:a4df229d3fd4cccd2a4ae17fa7edfa258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images given a source position and size.  <a href="namespace_image_finding.html#a4df229d3fd4cccd2a4ae17fa7edfa258">More...</a><br /></td></tr>
<tr class="separator:a4df229d3fd4cccd2a4ae17fa7edfa258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87006a0aa4fab4fda4f60f6689f0ec3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#ae87006a0aa4fab4fda4f60f6689f0ec3">find_images_microlens_exper</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, PosType *y_source, PosType r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, PosType initial_size, PosType mu_min, bool splitimages, short edge_refinement, bool verbose)</td></tr>
<tr class="memdesc:ae87006a0aa4fab4fda4f60f6689f0ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">experimental version of find_image_microlens()  <a href="namespace_image_finding.html#ae87006a0aa4fab4fda4f60f6689f0ec3">More...</a><br /></td></tr>
<tr class="separator:ae87006a0aa4fab4fda4f60f6689f0ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d61941f50776c7133ead2f5ea87117"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#aa1d61941f50776c7133ead2f5ea87117">image_finder_kist</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, PosType *y_source, PosType r_source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, unsigned long *Nimagepoints, short splitparities, short true_images)</td></tr>
<tr class="memdesc:aa1d61941f50776c7133ead2f5ea87117"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds images for a given source position and size. Not meant for high level user.  <a href="namespace_image_finding.html#aa1d61941f50776c7133ead2f5ea87117">More...</a><br /></td></tr>
<tr class="separator:aa1d61941f50776c7133ead2f5ea87117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf360f46ff1014096ff17d160d3d3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#aeddf360f46ff1014096ff17d160d3d3d">find_crit</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, std::vector&lt; CriticalCurve &gt; &amp;crtcurve, int *Ncrits, double resolution, double invmag_min=0.0, bool verbose=false, bool test=false)</td></tr>
<tr class="memdesc:aeddf360f46ff1014096ff17d160d3d3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds critical curves and caustics.  <a href="namespace_image_finding.html#aeddf360f46ff1014096ff17d160d3d3d">More...</a><br /></td></tr>
<tr class="separator:aeddf360f46ff1014096ff17d160d3d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac423dd72b206974de345741c56783d61"><td class="memItemLeft" align="right" valign="top">CritType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#ac423dd72b206974de345741c56783d61">find_pseudo</a> (<a class="el" href="struct_image_info.html">ImageInfo</a> &amp;pseudocurve, <a class="el" href="struct_image_info.html">ImageInfo</a> &amp;negimage, PosType pseudolimit, <a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, PosType resolution, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;paritypoints, bool TEST=false)</td></tr>
<tr class="separator:ac423dd72b206974de345741c56783d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada031993e8ed6cfead17ecc83951a197"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#ada031993e8ed6cfead17ecc83951a197">find_contour</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, std::vector&lt; CriticalCurve &gt; &amp;contour, int *Ncrits, PosType resolution, bool *orderingsuccess, bool ordercurve, bool dividecurves, double contour_value, LensingVariable contour_type, bool verbose=false)</td></tr>
<tr class="memdesc:ada031993e8ed6cfead17ecc83951a197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds iso kappa contours.  <a href="namespace_image_finding.html#ada031993e8ed6cfead17ecc83951a197">More...</a><br /></td></tr>
<tr class="separator:ada031993e8ed6cfead17ecc83951a197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5f16f9082f1c14ba6f22625366975e"><td class="memItemLeft" align="right" valign="top"><a id="a2a5f16f9082f1c14ba6f22625366975e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printCriticalCurves</b> (std::string filename, const std::vector&lt; ImageFinding::CriticalCurve &gt; &amp;critcurves)</td></tr>
<tr class="separator:a2a5f16f9082f1c14ba6f22625366975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3186a3ec810f8f68f57f7b6bfdf762d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#aa3186a3ec810f8f68f57f7b6bfdf762d">mapCriticalCurves</a> (const std::vector&lt; ImageFinding::CriticalCurve &gt; &amp;critcurves, int Nx)</td></tr>
<tr class="separator:aa3186a3ec810f8f68f57f7b6bfdf762d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d48e2de32898ac9b73c252e0ad2607"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_pixel_map.html">PixelMap</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a98d48e2de32898ac9b73c252e0ad2607">mapCausticCurves</a> (const std::vector&lt; ImageFinding::CriticalCurve &gt; &amp;critcurves, int Nx)</td></tr>
<tr class="separator:a98d48e2de32898ac9b73c252e0ad2607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abeafd5d8401246c3a4ed2dc79989c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a2abeafd5d8401246c3a4ed2dc79989c3">map_images</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double xmax, double xmin, double initial_size, ExitCriterion criterion, bool FindCenter, bool divide_images)</td></tr>
<tr class="memdesc:a2abeafd5d8401246c3a4ed2dc79989c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find images and refine them based on their surface brightness distribution.  <a href="namespace_image_finding.html#a2abeafd5d8401246c3a4ed2dc79989c3">More...</a><br /></td></tr>
<tr class="separator:a2abeafd5d8401246c3a4ed2dc79989c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7596607b563fc41789b2db5a2277a2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#aa7596607b563fc41789b2db5a2277a2c">map_images_fixedgrid</a> (<a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double xmax, bool divide_images, bool find_borders)</td></tr>
<tr class="memdesc:aa7596607b563fc41789b2db5a2277a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the images without any additional grid refinement or ray shooting.  <a href="namespace_image_finding.html#aa7596607b563fc41789b2db5a2277a2c">More...</a><br /></td></tr>
<tr class="separator:aa7596607b563fc41789b2db5a2277a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bbca22cc631872b33de04441c20b99"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a70bbca22cc631872b33de04441c20b99">map_imagesISOP</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="class_source.html">Source</a> *source, <a class="el" href="struct_grid.html">GridHndl</a> grid, int *Nimages, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, double rmax, double res_min, double initial_size, ExitCriterion criterion, bool divide_images, bool int_on=true, bool verbos=false)</td></tr>
<tr class="memdesc:a70bbca22cc631872b33de04441c20b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find images and refine them based on their surface brightness distribution.  <a href="namespace_image_finding.html#a70bbca22cc631872b33de04441c20b99">More...</a><br /></td></tr>
<tr class="separator:a70bbca22cc631872b33de04441c20b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b9df4dfdcc34aee973719535ec8778"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_image_finding.html#a35b9df4dfdcc34aee973719535ec8778">find_peaks</a> (<a class="el" href="class_lens.html">LensHndl</a> lens, <a class="el" href="struct_grid.html">GridHndl</a> grid, PosType rEinsteinMin, PosType kappa_max, std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;imageinfo, int *Nimages)</td></tr>
<tr class="memdesc:a35b9df4dfdcc34aee973719535ec8778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Refines the grid based on the convergence so that high density regions have high resolution.  <a href="namespace_image_finding.html#a35b9df4dfdcc34aee973719535ec8778">More...</a><br /></td></tr>
<tr class="separator:a35b9df4dfdcc34aee973719535ec8778"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="namespace_image_finding.html" title="The ImageFinding namespace is for functions related to finding and mapping images.">ImageFinding</a> namespace is for functions related to finding and mapping images. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ada031993e8ed6cfead17ecc83951a197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada031993e8ed6cfead17ecc83951a197">&#9670;&nbsp;</a></span>find_contour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_contour </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>crtcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Ncrits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>orderingsuccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ordercurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dividecurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>contour_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LensingVariable&#160;</td>
          <td class="paramname"><em>contour_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds iso kappa contours. </p>
<p>Finding </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>The lens model. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid. It must be initialized. </td></tr>
    <tr><td class="paramname">crtcurve</td><td>Structure to hold critical curve. Must be pre-allocated with maxNcrit elements. Stored in critcurve[i].imagekist. </td></tr>
    <tr><td class="paramname">Ncrits</td><td>The number of critical curves found. </td></tr>
    <tr><td class="paramname">resolution</td><td>The target resolution that the critical curve is mapped on the image plane. </td></tr>
    <tr><td class="paramname">orderingsuccess</td><td>true if ordering was successful. </td></tr>
    <tr><td class="paramname">ordercurve</td><td>Order the curve so that it can be drawn or used to find the winding number. </td></tr>
    <tr><td class="paramname">dividecurves</td><td>Divide the critical curves into seporate curves by whether they are attached </td></tr>
    <tr><td class="paramname">contour_value</td><td>value at which the contour is wanted </td></tr>
    <tr><td class="paramname">contour_type</td><td>KAPPA, INVMAG or DELAYT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeddf360f46ff1014096ff17d160d3d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddf360f46ff1014096ff17d160d3d3d">&#9670;&nbsp;</a></span>find_crit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_crit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>crtcurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Ncrits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>invmag_min</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TEST</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds critical curves and caustics. </p>
<p>Finding</p>
<p>The critical curve is found by refining the edges of regions of negative magnification. If there are no regions of negative magnification in the original grid the grid is refined around the point of highest kappa. If there are other points of high kappa that are not of interest one should be careful that the region of interest is not missed. For this reason critical curves that are smaller than the grid resolution (could be un-uniform) are not guaranteed to be found.</p>
<p>After the borders of the negative regions are found the code looks for radial and pseudo caustics within the island. It usually finds at least one, but if there are more than one per island some might be missed.</p>
<p>All the critical curve / caustic pairs are classified as radial, tangential or pseudo. small enough radial critical curve could be miss classified as a pseudo caustic. </p>
<p>Structure to hold critical curve. Must be pre-</p>
<p>make some figures</p>
<p>make some figures</p>
<p>make some figures</p>
<p>make some figures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>The lens model. </td></tr>
    <tr><td class="paramname">grid</td><td>The grid. It must be initialized. </td></tr>
    <tr><td class="paramname">crtcurve</td><td>Structure to hold critical curve. </td></tr>
    <tr><td class="paramname">Ncrits</td><td>The number of critical curves found. </td></tr>
    <tr><td class="paramname">resolution</td><td>The target resolution that the critical curve is mapped on the image plane. </td></tr>
    <tr><td class="paramname">invmag_min</td><td>finds regions with 1/magnification &lt; invmag_min, set to zero for caustics </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a84da40a884b9a6fd16038de225b51dc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84da40a884b9a6fd16038de225b51dc7">&#9670;&nbsp;</a></span>find_images_kist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_images_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>edge_refinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images given a source position and size. </p>
<p>Finding</p>
<p>find_images_kist returns finite refined images in images[0...*Nimages-1].imagekist It starts with a large source and reduces down to the right size refining at each step. It should not miss any image larger than ~ munin*r_source linear size, but seems to do much better than that. It does nothing with the surface brightnesses.</p>
<p>The routine can follow three different strategies for refining each image controlled by edge_refinement.</p>
<p>edge_refinement</p><ul>
<li>0 does not do edge refinement, Every pixel in every image is refined until the criterion is met. The image(s) are found again after each refinement which can make it slower.</li>
<li>1 uses refine_edge(). After an initial refinement of all the pixels in the image(s) the code switches to refining only the edges of the images. The images are found after each refinement.</li>
<li>2 uses refine_edge2() Same as 1, but the images are not found after each refinement. This can make the</li>
<li>any other number does no additional refinement after telescoping routine run much faster, but has the disadvantage that the number of images will not change during the final stage of refinement. This is the setting generally recommended. </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>contains the lens/es and source/sources position of source center </td></tr>
    <tr><td class="paramname">r_source</td><td>radius of source </td></tr>
    <tr><td class="paramname">grid</td><td>grid provided to routine </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">Nimagepoints</td><td>number of points in final images </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. </td></tr>
    <tr><td class="paramname">splitimages</td><td>true each image is refined to target accuracy, otherwise all images are treated as one </td></tr>
    <tr><td class="paramname">edge_refinement</td><td>see comment </td></tr>
    <tr><td class="paramname">verbose</td><td>verbose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4df229d3fd4cccd2a4ae17fa7edfa258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df229d3fd4cccd2a4ae17fa7edfa258">&#9670;&nbsp;</a></span>find_images_microlens()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_images_microlens </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>edge_refinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images given a source position and size. </p>
<p>Finding</p>
<p><a class="el" href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist</a> returns finite refined images in images[0...*Nimages-1].imagekist It starts with a large source and reduces down to the right size refining at each step. It should not miss any image larger than ~ munin*r_source linear size, but seems to do much better than that. It does nothing with the surface brightnesses.</p>
<p>The routine can follow three different strategies for refining each image controlled by edge_refinement.</p>
<p>edge_refinement</p><ul>
<li>0 does not do edge refinement, Every pixel in every image is refined until the criterion is met. The image(s) are found again after each refinement which can make it slower.</li>
<li>1 uses refine_edge(). After an initial refinement of all the pixels in the image(s) the code switches to refining only the edges of the images. The images are found after each refinement.</li>
<li>2 uses refine_edge2() Same as 1, but the images are not found after each refinement. This can make the routine run much faster, but has the disadvantage that the number of images will not change during the final stage of refinement. This is the setting generally recommended.</li>
</ul>
<p>When finding a finite sized source these quantities are generally not required and slow down the routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>contains the lens/es and source/sources position of source center </td></tr>
    <tr><td class="paramname">r_source</td><td>radius of source </td></tr>
    <tr><td class="paramname">grid</td><td>grid provided to routine </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">Nimagepoints</td><td>number of points in final images </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. </td></tr>
    <tr><td class="paramname">splitimages</td><td>true each image is refined to target accuracy, otherwise all images are treated as one </td></tr>
    <tr><td class="paramname">edge_refinement</td><td>see comment </td></tr>
    <tr><td class="paramname">verbose</td><td>verbose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae87006a0aa4fab4fda4f60f6689f0ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87006a0aa4fab4fda4f60f6689f0ec3">&#9670;&nbsp;</a></span>find_images_microlens_exper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::find_images_microlens_exper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>mu_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>edge_refinement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>experimental version of find_image_microlens() </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y_source</td><td>contains the lens/es and source/sources position of source center </td></tr>
    <tr><td class="paramname">r_source</td><td>radius of source </td></tr>
    <tr><td class="paramname">grid</td><td>grid provided to routine </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">Nimagepoints</td><td>number of points in final images </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. </td></tr>
    <tr><td class="paramname">splitimages</td><td>TRUE each image is refined to target accuracy, otherwise all images are treated as one </td></tr>
    <tr><td class="paramname">edge_refinement</td><td>see comment </td></tr>
    <tr><td class="paramname">verbose</td><td>verbose </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a35b9df4dfdcc34aee973719535ec8778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b9df4dfdcc34aee973719535ec8778">&#9670;&nbsp;</a></span>find_peaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short ImageFinding::find_peaks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rEinsteinMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>kappa_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Refines the grid based on the convergence so that high density regions have high resolution. </p>
<p>Finding</p>
<p>No source is used in this process. The code acts as if all the mass is in SIS halos iteratively increasing the resolution and kappa threshhold until the desired resolution is found. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td><a class="el" href="class_lens.html" title="A class to represents a lens with multiple planes.">Lens</a> model </td></tr>
    <tr><td class="paramname">grid</td><td><a class="el" href="struct_grid.html" title="Structure to contain both source and image trees.">Grid</a> to be refined. It must be initialized. </td></tr>
    <tr><td class="paramname">rEinsteinMin</td><td>the Einstein radius of the smallest lens that should be resolved, sets resolution target </td></tr>
    <tr><td class="paramname">kappa_max</td><td>highest kappa to be refined to, 1 or 2 is probably good enough </td></tr>
    <tr><td class="paramname">imageinfo</td><td>the image </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of peaks </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac423dd72b206974de345741c56783d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac423dd72b206974de345741c56783d61">&#9670;&nbsp;</a></span>find_pseudo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CritType ImageFinding::find_pseudo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>pseudocurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_image_info.html">ImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>negimage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>pseudolimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>resolution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paritypoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>TEST</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>remove all but the points below tmp_pseudolimit</p>

</div>
</div>
<a id="aa1d61941f50776c7133ead2f5ea87117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d61941f50776c7133ead2f5ea87117">&#9670;&nbsp;</a></span>image_finder_kist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::image_finder_kist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType *&#160;</td>
          <td class="paramname"><em>y_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>r_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Nimagepoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>splitparities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>true_images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds images for a given source position and size. Not meant for high level user. </p>
<p>image points are put into imageinfo[].imagekist imageinfo[].points and imageinfo[].Npoints are not changed</p>
<p>splitparities= 0 don't split attached negative and positive parity images = 1 do split parities NOTE: this is now obsolete = -1 doesn't slit into images at all , also does not find borders or change in_image markers true_images = 1 gives just the points that are in the image = 0 if there are not enough points in images this will include close points to be refined</p>
<p>side-effects : Will make in_image = true for all image points if splitparities == 0</p>
<p>&lt;<code></code> &gt; </p>

</div>
</div>
<a id="a2abeafd5d8401246c3a4ed2dc79989c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2abeafd5d8401246c3a4ed2dc79989c3">&#9670;&nbsp;</a></span>map_images()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_images </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExitCriterion&#160;</td>
          <td class="paramname"><em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>FindCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find images and refine them based on their surface brightness distribution. </p>
<p>Finding Uses <a class="el" href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist()</a> to initially find and refine images and then uses a surface brightness based criterion to refine the most important parts of the lens.</p>
<p>map_images is intended for mapping images of sources more complicated than simple circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>model </td></tr>
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">xmax</td><td>Maximum size of source on image plane. The entire source must be within this distance from source-&gt;getTheta()[] </td></tr>
    <tr><td class="paramname">xmin</td><td>The smallest scale of the source measured on the lens plane. The more accurate these 2 parameters are the less likely it is that an image will be missed. </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. If &lt; 0 no telescoping is used and only the already existing points are used to to initiate the image finding. </td></tr>
    <tr><td class="paramname">criterion</td><td>see data type </td></tr>
    <tr><td class="paramname">FindCenter</td><td>if the center of the source is not known this can be set to true and it will attempt to find the center, find the size of the source and determine if there is more than one source The entire source must be within xmax of source-&gt;getTheta() because this is the only region that will be scanned. </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images and apply the exit criterion to them separately. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7596607b563fc41789b2db5a2277a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7596607b563fc41789b2db5a2277a2c">&#9670;&nbsp;</a></span>map_images_fixedgrid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_images_fixedgrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>find_borders</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the images without any additional grid refinement or ray shooting. </p>
<p>Finding The images and surface brighnesses are found. This will be much faster than <a class="el" href="namespace_image_finding.html#a2abeafd5d8401246c3a4ed2dc79989c3" title="Find images and refine them based on their surface brightness distribution.">map_images()</a>, but will miss images that are not resolved on the current grid.</p>
<p>The surface brightnesses on all of the grid are refreshed. The images centroids and gridranges are maintained. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">xmax</td><td>Maximum size of source on image plane. The entire source must be within this distance from source-&gt;getTheta()[]. Decreasing it will make the code run faster. Making xmax much bigger than the grid boundaries will check all points for surface brightness. </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images. </td></tr>
    <tr><td class="paramname">find_borders</td><td>if true will find the inner and outer borders of each image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70bbca22cc631872b33de04441c20b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70bbca22cc631872b33de04441c20b99">&#9670;&nbsp;</a></span>map_imagesISOP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ImageFinding::map_imagesISOP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_lens.html">LensHndl</a>&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_source.html">Source</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_grid.html">GridHndl</a>&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nimages</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_image_info.html">ImageInfo</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>imageinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>res_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initial_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ExitCriterion&#160;</td>
          <td class="paramname"><em>criterion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>divide_images</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>int_on</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find images and refine them based on their surface brightness distribution. </p>
<p>Finding Uses <a class="el" href="namespace_image_finding.html#a84da40a884b9a6fd16038de225b51dc7" title="Finds images given a source position and size.">ImageFinding::find_images_kist()</a> to initially find and refine images and then using IF_routines::IntegrateFluxInCell(). If cells cannot be integrated refiments are madebased on a surface brightness based criterion to refine the most important parts of the lens.</p>
<p>map_images is intended for mapping images of sources more complicated than simple circles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>model </td></tr>
    <tr><td class="paramname">grid</td><td>Tree of grid points </td></tr>
    <tr><td class="paramname">Nimages</td><td>number of images found </td></tr>
    <tr><td class="paramname">imageinfo</td><td>information on each image </td></tr>
    <tr><td class="paramname">rmax</td><td>Maximum size of source on souce plane. The entire source must be within this distance from source-&gt;getTheta()[] </td></tr>
    <tr><td class="paramname">res_min</td><td>requred resolution of image, typically the pixel size of the final image </td></tr>
    <tr><td class="paramname">initial_size</td><td>Initial size of source for telescoping, 0 to start from the initial grid size. If &lt; 0 no telescoping is used and only the already existing points are used to to initiate the image finding. </td></tr>
    <tr><td class="paramname">criterion</td><td>see data type </td></tr>
    <tr><td class="paramname">divide_images</td><td>if true will divide images and apply the exit criterion to them separately. </td></tr>
    <tr><td class="paramname">int_on</td><td>if true the flux in each cell is integrated, if false the surface brightness at the center point of the cell is used </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98d48e2de32898ac9b73c252e0ad2607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d48e2de32898ac9b73c252e0ad2607">&#9670;&nbsp;</a></span>mapCausticCurves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> ImageFinding::mapCausticCurves </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ImageFinding::CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>critcurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\breaf Makes an image of the caustic curves. The map will encompose all curves found. The pixel values are the caustic type + 1 ( 2=radial,3=tangential,4=pseudo ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">critcurves</td><td>list of critical curves </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels to each size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3186a3ec810f8f68f57f7b6bfdf762d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3186a3ec810f8f68f57f7b6bfdf762d">&#9670;&nbsp;</a></span>mapCriticalCurves()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_pixel_map.html">PixelMap</a> ImageFinding::mapCriticalCurves </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ImageFinding::CriticalCurve &gt; &amp;&#160;</td>
          <td class="paramname"><em>critcurves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\breaf Makes an image of the critical curves. The map will encompose all curves found. The pixel values are the caustic type + 1 ( 2=radial,3=tangential,4=pseudo ) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">critcurves</td><td>list of critical curves </td></tr>
    <tr><td class="paramname">Nx</td><td>number of pixels to each size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Dec 17 2021 18:30:27 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
