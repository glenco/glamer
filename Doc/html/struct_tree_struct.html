<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLAMERDOC++: TreeStruct Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLAMERDOC++
   </div>
   <div id="projectbrief">Gravitational Lensing Code Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="struct_tree_struct-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TreeStruct Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Tree: Exported struct.  
 <a href="struct_tree_struct.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_tree_8h_source.html">Tree.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for TreeStruct:</div>
<div class="dyncontent">
<div class="center"><img src="struct_tree_struct__coll__graph.png" border="0" usemap="#_tree_struct_coll__map" alt="Collaboration graph"/></div>
<map name="_tree_struct_coll__map" id="_tree_struct_coll__map">
<area shape="rect" title="Tree: Exported struct." alt="" coords="5,95,88,121"/>
<area shape="rect" href="struct_point_list.html" title="link list for points, uses the linking pointers within the Point type unlike Kist" alt="" coords="10,5,83,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_tree_struct_1_1iterator.html">iterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A iterator class fore <a class="el" href="struct_tree_struct.html" title="Tree: Exported struct.">TreeStruct</a> that allows for movement through the tree without changing anything in the tree itself.  <a href="class_tree_struct_1_1iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a20fc537aab17f735ce8c6bac7d95af87"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a20fc537aab17f735ce8c6bac7d95af87">TreeStruct</a> (<a class="el" href="struct_point.html">Point</a> *xp, unsigned long Npoints, short my_median_cut=1, PosType buffer=0.0)</td></tr>
<tr class="memdesc:a20fc537aab17f735ce8c6bac7d95af87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a complete tree from a list of points.  <a href="struct_tree_struct.html#a20fc537aab17f735ce8c6bac7d95af87">More...</a><br /></td></tr>
<tr class="separator:a20fc537aab17f735ce8c6bac7d95af87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a578ff026e90846de685d2bee12c2d27b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a578ff026e90846de685d2bee12c2d27b">TreeStruct</a> (<a class="el" href="struct_point.html">Point</a> *xp, unsigned long npoints, PosType boundary_p1[2], PosType boundary_p2[2], PosType center[2], int Nbucket)</td></tr>
<tr class="memdesc:a578ff026e90846de685d2bee12c2d27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new tree and the linked list of points in it. Does not build the tree structure. The other constructor should be used to build the whole tree.  <a href="struct_tree_struct.html#a578ff026e90846de685d2bee12c2d27b">More...</a><br /></td></tr>
<tr class="separator:a578ff026e90846de685d2bee12c2d27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2b2eb45f2bc3b172177929f97dee01"><td class="memItemLeft" align="right" valign="top"><a id="a8d2b2eb45f2bc3b172177929f97dee01"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a8d2b2eb45f2bc3b172177929f97dee01">~TreeStruct</a> ()</td></tr>
<tr class="memdesc:a8d2b2eb45f2bc3b172177929f97dee01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free tree and the linked list of points in it. <br /></td></tr>
<tr class="separator:a8d2b2eb45f2bc3b172177929f97dee01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b6885009f3adc0e9e5200d9de091aa"><td class="memItemLeft" align="right" valign="top"><a id="a49b6885009f3adc0e9e5200d9de091aa"></a>
<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const</td></tr>
<tr class="separator:a49b6885009f3adc0e9e5200d9de091aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6925efe0946917391afd5858d4b068e"><td class="memItemLeft" align="right" valign="top"><a id="ad6925efe0946917391afd5858d4b068e"></a>
<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const</td></tr>
<tr class="separator:ad6925efe0946917391afd5858d4b068e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e30cc9c4338d888800cd6f45cd69547"><td class="memItemLeft" align="right" valign="top"><a id="a5e30cc9c4338d888800cd6f45cd69547"></a>
<a class="el" href="struct_branch.html">Branch</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547">getTop</a> ()</td></tr>
<tr class="memdesc:a5e30cc9c4338d888800cd6f45cd69547"><td class="mdescLeft">&#160;</td><td class="mdescRight">root branch <br /></td></tr>
<tr class="separator:a5e30cc9c4338d888800cd6f45cd69547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e33786248bdc48fde6a165b6bfae22f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a8e33786248bdc48fde6a165b6bfae22f">FindAllBoxNeighborsKist</a> (<a class="el" href="struct_point.html">Point</a> *point, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighbors) const</td></tr>
<tr class="memdesc:a8e33786248bdc48fde6a165b6bfae22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the leaves that are neighboring a point.  <a href="struct_tree_struct.html#a8e33786248bdc48fde6a165b6bfae22f">More...</a><br /></td></tr>
<tr class="separator:a8e33786248bdc48fde6a165b6bfae22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777de57567ba5beb60b68caedb39edab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a777de57567ba5beb60b68caedb39edab">FindAllBoxNeighborsKist</a> (<a class="el" href="struct_point.html">Point</a> *point, std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;neighbors) const</td></tr>
<tr class="memdesc:a777de57567ba5beb60b68caedb39edab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all the leaves that are neighboring a point.  <a href="struct_tree_struct.html#a777de57567ba5beb60b68caedb39edab">More...</a><br /></td></tr>
<tr class="separator:a777de57567ba5beb60b68caedb39edab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68145b23b953f705f127410bb125fc79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a68145b23b953f705f127410bb125fc79">PointsWithinEllipKist</a> (const PosType *center, float rmax, float rmin, float posangle, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist) const</td></tr>
<tr class="memdesc:a68145b23b953f705f127410bb125fc79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds points within an ellipse.  <a href="struct_tree_struct.html#a68145b23b953f705f127410bb125fc79">More...</a><br /></td></tr>
<tr class="separator:a68145b23b953f705f127410bb125fc79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e87679f878529623577aae8af1288b"><td class="memItemLeft" align="right" valign="top">PosType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a43e87679f878529623577aae8af1288b">PointsWithinKist</a> (const PosType *center, PosType rmax, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist, short markpoints) const</td></tr>
<tr class="memdesc:a43e87679f878529623577aae8af1288b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all points in tree that lie within rmax of the point ray[].  <a href="struct_tree_struct.html#a43e87679f878529623577aae8af1288b">More...</a><br /></td></tr>
<tr class="separator:a43e87679f878529623577aae8af1288b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a2c24eb61beee51be40c0624b459dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a36a2c24eb61beee51be40c0624b459dd">PointsWithinKist_iter</a> (const PosType *center, float rmin, float rmax, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist) const</td></tr>
<tr class="memdesc:a36a2c24eb61beee51be40c0624b459dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all points within a circle. Much simpler, iterative algorithm.  <a href="struct_tree_struct.html#a36a2c24eb61beee51be40c0624b459dd">More...</a><br /></td></tr>
<tr class="separator:a36a2c24eb61beee51be40c0624b459dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a40088ed454c0fb84073653e317a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#ad5a40088ed454c0fb84073653e317a4f">NearestNeighborKist</a> (const PosType *center, int Nneighbors, Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *neighborkist) const</td></tr>
<tr class="memdesc:ad5a40088ed454c0fb84073653e317a4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds nearest neighbor points to ray.  <a href="struct_tree_struct.html#ad5a40088ed454c0fb84073653e317a4f">More...</a><br /></td></tr>
<tr class="separator:ad5a40088ed454c0fb84073653e317a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a567260adb1b9753c70b336ff38791341"><td class="memItemLeft" align="right" valign="top"><a id="a567260adb1b9753c70b336ff38791341"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a567260adb1b9753c70b336ff38791341">AtEdge</a> (<a class="el" href="struct_point.html">Point</a> *point)</td></tr>
<tr class="memdesc:a567260adb1b9753c70b336ff38791341"><td class="mdescLeft">&#160;</td><td class="mdescRight">true is point is on the edge of the field <br /></td></tr>
<tr class="separator:a567260adb1b9753c70b336ff38791341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec8b0dc4a3a18fda4f3feef690923ca"><td class="memItemLeft" align="right" valign="top"><a id="acec8b0dc4a3a18fda4f3feef690923ca"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Test</b> ()</td></tr>
<tr class="separator:acec8b0dc4a3a18fda4f3feef690923ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258c95f4de87c75e74ce9d4e59e888e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a5258c95f4de87c75e74ce9d4e59e888e">RemoveLeafFromTree</a> (<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;current, unsigned long *Npoints)</td></tr>
<tr class="memdesc:a5258c95f4de87c75e74ce9d4e59e888e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prune off points that are below a resolution and in an annulus on the source plane.  <a href="struct_tree_struct.html#a5258c95f4de87c75e74ce9d4e59e888e">More...</a><br /></td></tr>
<tr class="separator:a5258c95f4de87c75e74ce9d4e59e888e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76668d1516ab7ddb2b7cdefa470d3419"><td class="memItemLeft" align="right" valign="top"><a id="a76668d1516ab7ddb2b7cdefa470d3419"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a76668d1516ab7ddb2b7cdefa470d3419">FillTree</a> (<a class="el" href="struct_point.html">Point</a> *xp, unsigned long Npoints)</td></tr>
<tr class="memdesc:a76668d1516ab7ddb2b7cdefa470d3419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill a tree with points. The previous tree structure will be destroyed. Used for refilling. <br /></td></tr>
<tr class="separator:a76668d1516ab7ddb2b7cdefa470d3419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57c8f27fb818e4c45e75cfda1cee0ec"><td class="memItemLeft" align="right" valign="top"><a id="aa57c8f27fb818e4c45e75cfda1cee0ec"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#aa57c8f27fb818e4c45e75cfda1cee0ec">AddPointsToTree</a> (<a class="el" href="struct_point.html">Point</a> *xpoint, unsigned long Nadd)</td></tr>
<tr class="memdesc:aa57c8f27fb818e4c45e75cfda1cee0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expands tree by adding points. <br /></td></tr>
<tr class="separator:aa57c8f27fb818e4c45e75cfda1cee0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22011842bc8af6c0770f23e4cf192a87"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a22011842bc8af6c0770f23e4cf192a87">emptyTree</a> ()</td></tr>
<tr class="memdesc:a22011842bc8af6c0770f23e4cf192a87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn a subtree with current as its top.  <a href="struct_tree_struct.html#a22011842bc8af6c0770f23e4cf192a87">More...</a><br /></td></tr>
<tr class="separator:a22011842bc8af6c0770f23e4cf192a87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07ffc0660e4f26705e9ebe38bd53957"><td class="memItemLeft" align="right" valign="top"><a id="aa07ffc0660e4f26705e9ebe38bd53957"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> ()</td></tr>
<tr class="separator:aa07ffc0660e4f26705e9ebe38bd53957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc7d7d8b0b849f94f90c3aaa6dd37f0f"><td class="memItemLeft" align="right" valign="top"><a id="afc7d7d8b0b849f94f90c3aaa6dd37f0f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><b>getNbranches</b> ()</td></tr>
<tr class="separator:afc7d7d8b0b849f94f90c3aaa6dd37f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1681e1caa459748eab374612e92cc2e9"><td class="memItemLeft" align="right" valign="top"><a id="a1681e1caa459748eab374612e92cc2e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>printTree</b> (<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;current)</td></tr>
<tr class="separator:a1681e1caa459748eab374612e92cc2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc821cf873426c96b9f43fa0427ce0a0"><td class="memItemLeft" align="right" valign="top"><a id="acc821cf873426c96b9f43fa0427ce0a0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>checkTree</b> ()</td></tr>
<tr class="separator:acc821cf873426c96b9f43fa0427ce0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230c70e5a72e2ae2d30ff3cc159a3e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_point.html">Point</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a230c70e5a72e2ae2d30ff3cc159a3e87">FindBoxPoint</a> (const PosType *ray) const</td></tr>
<tr class="separator:a230c70e5a72e2ae2d30ff3cc159a3e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a6a26bae725392d290cdfa0220e7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a05a6a26bae725392d290cdfa0220e7f0">_FindLeaf</a> (<a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;current, const PosType *ray, unsigned long Nadd=0) const</td></tr>
<tr class="separator:a05a6a26bae725392d290cdfa0220e7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a18020df556ff80dedecd9425afe72d24"><td class="memItemLeft" align="right" valign="top"><a id="a18020df556ff80dedecd9425afe72d24"></a>
<a class="el" href="struct_point_list.html">PointList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_tree_struct.html#a18020df556ff80dedecd9425afe72d24">pointlist</a></td></tr>
<tr class="memdesc:a18020df556ff80dedecd9425afe72d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">list of points <br /></td></tr>
<tr class="separator:a18020df556ff80dedecd9425afe72d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:adc9ac615fe5048e81da2e7be2cf7975f"><td class="memItemLeft" align="right" valign="top"><a id="adc9ac615fe5048e81da2e7be2cf7975f"></a>
static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>mutex</b></td></tr>
<tr class="separator:adc9ac615fe5048e81da2e7be2cf7975f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Tree: Exported struct. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a20fc537aab17f735ce8c6bac7d95af87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20fc537aab17f735ce8c6bac7d95af87">&#9670;&nbsp;</a></span>TreeStruct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeStruct::TreeStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>xp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>my_median_cut</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>buffer</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a complete tree from a list of points. </p>
<p>median_cut determines how the cells are subdivided if ==0 equal volume cuts, Warning this option causes an error if ==1 pseudo-median point cuts, never cuts through a point, but near the median &lt;<code></code> &gt; </p>

</div>
</div>
<a id="a578ff026e90846de685d2bee12c2d27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a578ff026e90846de685d2bee12c2d27b">&#9670;&nbsp;</a></span>TreeStruct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TreeStruct::TreeStruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>xp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>npoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>boundary_p1</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>boundary_p2</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>center</em>[2], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>my_Nbucket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new tree and the linked list of points in it. Does not build the tree structure. The other constructor should be used to build the whole tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xp</td><td>array of points to be added to the tree </td></tr>
    <tr><td class="paramname">npoints</td><td>number of points </td></tr>
    <tr><td class="paramname">boundary_p1</td><td>bottom left hand corner of root </td></tr>
    <tr><td class="paramname">boundary_p2</td><td>upper right hand corner of root </td></tr>
    <tr><td class="paramname">center</td><td>center of root (this could be the center of mass) </td></tr>
    <tr><td class="paramname">my_Nbucket</td><td>maximum number of points allowed in a leaf </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a05a6a26bae725392d290cdfa0220e7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a6a26bae725392d290cdfa0220e7f0">&#9670;&nbsp;</a></span>_FindLeaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::_FindLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>ray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>Nadd</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the leaf the ray is in and adds Nadd to all of is parent leaves </p>

</div>
</div>
<a id="a22011842bc8af6c0770f23e4cf192a87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22011842bc8af6c0770f23e4cf192a87">&#9670;&nbsp;</a></span>emptyTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TreeStruct::emptyTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Spawn a subtree with current as its top. </p>
<p>The new tree contains all of the tree below the current. Warning:: Adding points to the new tree will not update the parent tree so it can become dangerously out of sync.</p>
<p>Empty tree of all point leaving a tree with an empty root.</p>
<p>The points are not freed, and the list structure is not destroyed.</p>
<p>FillTree can then be used to regenerate tree. </p>

</div>
</div>
<a id="a8e33786248bdc48fde6a165b6bfae22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e33786248bdc48fde6a165b6bfae22f">&#9670;&nbsp;</a></span>FindAllBoxNeighborsKist() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::FindAllBoxNeighborsKist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the leaves that are neighboring a point. </p>
<p>Points outside of grid have no box neighbors Warning: Does not take empty leaves into account. </p>

</div>
</div>
<a id="a777de57567ba5beb60b68caedb39edab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777de57567ba5beb60b68caedb39edab">&#9670;&nbsp;</a></span>FindAllBoxNeighborsKist() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::FindAllBoxNeighborsKist </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_point.html">Point</a> *&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="struct_point.html">Point</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all the leaves that are neighboring a point. </p>
<p>Points outside of grid have no box neighbors Warning: Does not take empty leaves into account. </p>

</div>
</div>
<a id="a230c70e5a72e2ae2d30ff3cc159a3e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230c70e5a72e2ae2d30ff3cc159a3e87">&#9670;&nbsp;</a></span>FindBoxPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point.html">Point</a> * TreeStruct::FindBoxPoint </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>ray</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return a pointer to the point that is in the same box as ray[2] if Nbuck &gt; 1 the head of the point array is returned</p>
<p>Memory </p>

</div>
</div>
<a id="ad5a40088ed454c0fb84073653e317a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a40088ed454c0fb84073653e317a4f">&#9670;&nbsp;</a></span>NearestNeighborKist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point.html">Point</a> * TreeStruct::NearestNeighborKist </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nneighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighborkist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds nearest neighbor points to ray. </p>
<p>This is a kludge that relies on NearestNeighbor which uses a List and translates the list to a kist. Could be rewritten.</p>
<p>Warning: The number of neighbor points in neighborkist will be less than Nneighbors when the number of points in the tree is less than Nneighbors </p>

</div>
</div>
<a id="a68145b23b953f705f127410bb125fc79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68145b23b953f705f127410bb125fc79">&#9670;&nbsp;</a></span>PointsWithinEllipKist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::PointsWithinEllipKist </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>posangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighborkist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds points within an ellipse. </p>
<p>This becomes less efficient when the ellipse is very elongated. Could be improved by incorporating the test of it being in the ellipse into the tree walk.</p>
<p>The </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of ellipse </td></tr>
    <tr><td class="paramname">rmax</td><td>major axis </td></tr>
    <tr><td class="paramname">rmin</td><td>minor axis </td></tr>
    <tr><td class="paramname">posangle</td><td>position angle of major axis, smallest angle between the x-axis and the long axis </td></tr>
    <tr><td class="paramname">neighborkist</td><td>output neighbor kist, will be emptied if it contains anything on entry </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43e87679f878529623577aae8af1288b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e87679f878529623577aae8af1288b">&#9670;&nbsp;</a></span>PointsWithinKist()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PosType TreeStruct::PointsWithinKist </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PosType&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighborkist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>markpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all points in tree that lie within rmax of the point ray[]. </p>
<p>markpoints = 0 does not change in_image variable in any point, gives a list of neighbors = 1 makes in_image=YES for all points and their images in image, gives no list of neighbors = -1 makes in_image=NO for all points in image to reset, gives no list of neighbors</p>
<p>Returns the largest gridsize of the points within the circle. Note that this is the gridsize stored in the point. If finding points on the source plane the i_point-&gt;gridsize must be set to the same as the image point to get the largest gridsize on the image plane. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>center of circle </td></tr>
    <tr><td class="paramname">rmax</td><td>radius of circle </td></tr>
    <tr><td class="paramname">neighborkist</td><td>output neighbor kist, will be emptied if it contains anything on entry </td></tr>
    <tr><td class="paramname">markpoints</td><td>see comment </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36a2c24eb61beee51be40c0624b459dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a2c24eb61beee51be40c0624b459dd">&#9670;&nbsp;</a></span>PointsWithinKist_iter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TreeStruct::PointsWithinKist_iter </td>
          <td>(</td>
          <td class="paramtype">const PosType *&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kist&lt; <a class="el" href="struct_point.html">Point</a> &gt; *&#160;</td>
          <td class="paramname"><em>neighborkist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all points within a circle. Much simpler, iterative algorithm. </p>

</div>
</div>
<a id="a5258c95f4de87c75e74ce9d4e59e888e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5258c95f4de87c75e74ce9d4e59e888e">&#9670;&nbsp;</a></span>RemoveLeafFromTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_point.html">Point</a> * TreeStruct::RemoveLeafFromTree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_tree_struct_1_1iterator.html">TreeStruct::iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>current</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long *&#160;</td>
          <td class="paramname"><em>Npoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prune off points that are below a resolution and in an annulus on the source plane. </p>
<pre class="fragment">\brief THIS DOES NOT WORK YET!!!

Reduces the size of the tree by removing points and branches that are no longer needed.
</pre><p>unsigned long Grid::PruneTrees( PosType resolution /// Maximum size of a cell to be removed. ,bool useSB /// If true it will not remove any point that has a flux above fluxlimit. ,PosType fluxlimit /// flux limit threshold ){</p>
<p>long i,Ntmp,count = 0; PosType res,initres; bool go;</p>
<p>assert(trashkist);</p>
<p>if(i_tree == NULL) return 0; if(s_tree == NULL) return 0;</p>
<p>Ntmp = i_tree-&gt;pointlist.size();</p>
<p>i_tree-&gt;moveTop();</p>
<p><a class="el" href="class_tree_struct_1_1iterator.html" title="A iterator class fore TreeStruct that allows for movement through the tree without changing anything ...">TreeStruct::iterator</a> i_tree_current(i_tree); PointList::iterator i_tree_pointlist_current;</p>
<p>initres = (i_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;boundary_p2[0]-i_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;boundary_p1[0]); if(resolution &gt; initres/3 || resolution &lt;= 0.0) return 0; // do not allow pruning up to the initial grid size</p>
<p>walk tree i=0; go = true; do{ assert((*i_tree_current)-&gt;points-&gt;next || (*i_tree_current)-&gt;points-&gt;prev);</p>
<p>res = ((*i_tree_current)-&gt;boundary_p2[0]-(*i_tree_current)-&gt;boundary_p1[0]); if( (res &lt;= resolution &amp;&amp; i_tree_current.IsSquareBranch() ) &amp;&amp; (*i_tree_current)-&gt;refined){</p>
<p>if(useSB){ go = true; Check if surface brightness of all points in cell are zero. i_tree_pointlist_current = (*i_tree_current)-&gt;points; for(i=0; i &lt; (*i_tree_current)-&gt;npoints;++i,&ndash;i_tree_pointlist_current ){ if((*i_tree_pointlist_current)-&gt;surface_brightness*pow((*i_tree_pointlist_current)-&gt;gridsize,2) &gt; fluxlimit ){ go = false; break; } } }</p>
<p>remove all lower branches and make current a leaf if(go &amp;&amp; (*i_tree_current)-&gt;npoints &gt; 1){</p>
<p>count += FreeBranchesBelow(i_tree_current,i_tree,s_tree,trashkist); } } }while(i_tree_current.TreeWalkStep(true));</p>
<p>rebuild source tree from list. if(count &gt; 0) RebuildTreeFromList(s_tree);</p>
<p>assert(count == (Ntmp - i_tree-&gt;pointlist.size()) );</p>
<p>return count; }</p>
<p>Used to keep the number of grid points limited while telescoping.</p>
<p>The points that are removed have cells that do not overlap the inner circle and centers that are within the outer circle. Thus some points will be outside of the inner circle and some cells that are not removed may intersect with the outer circle.</p>
<p>unsigned long Grid::PrunePointsOutside( PosType resolution /// Maximum size of a cell to be removed. ,PosType *y /// Center on source plane ,PosType r_in /// Inner radius of annulus on the source plane ,PosType r_out /// Outer radius of annulus on the source plane ){</p>
<p>if(i_tree == NULL) return 0; if(s_tree == NULL) return 0; if(r_in &gt; r_out || resolution &lt;= 0) return 0; if(r_out &lt;= 0.0) return 0.0;</p>
<p>PosType res,dr2;</p>
<p>long i,count = 0; <a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> *point; <a class="el" href="struct_branch.html" title="The box representing a branch of a binary tree structure. Used specifically in TreeStruct for organiz...">Branch</a> *branch; Kist&lt;Point&gt; * subkist = new Kist&lt;Point&gt;; bool go = true; unsigned long Ntmp; Unit *unit;</p>
<p>assert(trashkist);</p>
<p>Make a kist of all points in the annulus. PointsWithinKist(s_tree,y,r_out+resolution,subkist,0); s_tree-&gt;PointsWithinKist_iter(y,r_in,r_out+resolution,subkist);</p>
<p>std::printf("number of points after PointsWithin %li\n",subkist-&gt;Nunits());</p>
<p>if(r_in &gt; 0){ take out points that are within inner circle subkist-&gt;MoveToTop(); Ntmp = subkist-&gt;Nunits(); for(i=0;i&lt;Ntmp;++i){ go = true; point = subkist-&gt;getCurrent(); if(point-&gt;gridsize*Ngrid_block &gt; resolution){ if(subkist-&gt;AtTop()) go = false; subkist-&gt;TakeOutCurrent(); }else if( Utilities::cutbox(y,point-&gt;leaf-&gt;boundary_p1,point-&gt;leaf-&gt;boundary_p2,r_in) ){ if(subkist-&gt;AtTop()) go = false; subkist-&gt;TakeOutCurrent(); }</p>
<p>if(go) subkist-&gt;Down(); } } std::printf("number of points after culling %li\n",subkist-&gt;Nunits());</p>
<p>if(subkist-&gt;Nunits() == 0){ delete subkist; return 0; }</p>
<p>move from source plane to image plane subkist-&gt;TranformPlanes(); </p><pre class="fragment"> TreeStruct::iterator i_tree_current(i_tree);
</pre><p>Take out all points that are not at the center of their parent refined cell subkist-&gt;MoveToTop(); Ntmp = subkist-&gt;Nunits(); for(i = 0; i &lt; Ntmp ; ++i){ go = true; point = subkist-&gt;getCurrent(); i_tree_current = point-&gt;leaf; Move up to nearest ancestor that was refined. while(!((*i_tree_current)-&gt;refined) &amp;&amp; i_tree_current.up() );</p>
<p>res = ((*i_tree_current)-&gt;boundary_p2[0]-(*i_tree_current)-&gt;boundary_p1[0]);</p>
<p>if((*i_tree_current)-&gt;npoints != Ngrid_block*Ngrid_block || res &gt; resolution){ Take out the point if it is not in a parent block that has been refined than once or if the parent block is about the resolution limit if(subkist-&gt;AtTop()) go = false; subkist-&gt;TakeOutCurrent(); }else{ assert(inbox(point-&gt;x,(*i_tree_current)-&gt;boundary_p1,(*i_tree_current)-&gt;boundary_p2));</p>
<p>assert(fabs((*i_tree_current)-&gt;center[0] - ((*i_tree_current)-&gt;boundary_p2[0]+(*i_tree_current)-&gt;boundary_p1[0])/2) &lt; point-&gt;gridsize/2); assert(fabs((*i_tree_current)-&gt;center[1] - ((*i_tree_current)-&gt;boundary_p2[1]+(*i_tree_current)-&gt;boundary_p1[1])/2) &lt; point-&gt;gridsize/2 ); assert(point-&gt;gridsize &lt; fabs((*i_tree_current)-&gt;boundary_p2[0]-(*i_tree_current)-&gt;boundary_p1[0]) ); assert(point-&gt;gridsize &lt; fabs((*i_tree_current)-&gt;boundary_p2[1]-(*i_tree_current)-&gt;boundary_p1[1]) );</p>
<p>if( (point-&gt;gridsize)/2 &lt; fabs(point-&gt;x[0] - (*i_tree_current)-&gt;center[0]) || (point-&gt;gridsize)/2 &lt; fabs(point-&gt;x[1] - (*i_tree_current)-&gt;center[1]) ){ // Take out point if it is not at the center of it's parent block if(subkist-&gt;AtTop()) go = false; subkist-&gt;TakeOutCurrent(); } }</p>
<p>if(go) subkist-&gt;Down(); }</p>
<p>assert(subkist-&gt;AtBottom());</p>
<p>subkist-&gt;MoveToTop(); PointList::iterator i_tree_pointlist_current; while(subkist-&gt;Nunits() &gt; 0){ i_tree_current = subkist-&gt;getCurrent()-&gt;leaf; Move up to nearest ancestor that was refined. while(!((*i_tree_current)-&gt;refined) &amp;&amp; i_tree_current.up() );</p>
<p>assert((*i_tree_current)-&gt;npoints == Ngrid_block*Ngrid_block);</p>
<p>make sure that none of the child points are outside the annulus i_tree_pointlist_current = (*i_tree_current)-&gt;points; for(i=0;i &lt; Ngrid_block*Ngrid_block ; ++i,&ndash;i_tree_pointlist_current){ dr2 = pow((*i_tree_pointlist_current)-&gt;image-&gt;x[0] - y[0],2) + pow((*i_tree_pointlist_current)-&gt;image-&gt;x[1] - y[1],2); if(dr2 &gt; r_out*r_out || dr2 &lt; r_in*r_in) break; if(dr2 &lt; r_in*r_in) break; }</p>
<p>if(i == Ngrid_block*Ngrid_block){ branch = *i_tree_current;</p>
<p>count += FreeBranchesBelow(i_tree_current,i_tree,s_tree,trashkist);</p>
<p>assert((*i_tree_current)-&gt;npoints == 1); assert( fabs( 1 - ((*i_tree_current)-&gt;boundary_p2[0] - (*i_tree_current)-&gt;boundary_p1[0])/(*i_tree_current)-&gt;points-&gt;gridsize) &lt; 1.0e-4 ); assert((*i_tree_current)-&gt;refined == false);</p>
<p>}</p>
<p>subkist-&gt;TakeOutCurrent();</p>
<p>}</p>
<p>delete subkist;</p>
<p>return count; } </p><pre class="fragment">\brief Empty trash points.

Frees point arrays whose heads are stored in trashlist.
If check=true it will only free arrays where all the points have NULL leafs.
   check=false all the point arrays are freed..
</pre><p>void CollectTrash(Kist&lt;Point&gt; * trashkist,bool check){ bool go; unsigned long i,j,Ntmp; <a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> *points;</p>
<p>if(trashkist-&gt;Nunits() == 0) return;</p>
<p>Ntmp = trashkist-&gt;Nunits(); for(j=0,trashkist-&gt;MoveToTop();j&lt;Ntmp;++j){</p>
<p>if(!(trashkist-&gt;getCurrent()-&gt;head)){ // point is not the head of an array if(trashkist-&gt;AtTop()) go = false; else go = true; trashkist-&gt;TakeOutCurrent(); }else{</p>
<p>check to see if all points in the block have been removed from the trees if(check){ for(i=0;i&lt;trashkist-&gt;getCurrent()-&gt;head;++i) if(trashkist-&gt;getCurrent()[i].leaf != NULL) break; }else{ i = trashkist-&gt;getCurrent()-&gt;head; }</p>
<p>if(i == trashkist-&gt;getCurrent()-&gt;head){ if(trashkist-&gt;AtTop()) go = false; else go = true; points = trashkist-&gt;TakeOutCurrent(); FreePointArray(points); }else{ go = true; } }</p>
<p>if(go) trashkist-&gt;Down(); }</p>
<p>return; }</p>
<p>Frees all branches of the tree below the current branch in i_tree if that branch is square and i_tree-&gt;current-&gt;refined == true. If either of these are not true nothing happens.</p>
<p>On exit: The i_tree-&gt;current is back to the original current. If it is square it will have no children and contain one point. The source points and branches are also removed.</p>
<p>unsigned long FreeBranchesBelow(TreeStruct::iterator &amp;i_tree_current,TreeHndl i_tree,TreeHndl s_tree,Kist&lt;Point&gt; * trashkist){</p>
<p>if(!i_tree_current.IsSquareBranch()) return 0; if(i_tree_current.atLeaf()) return 0; if((*i_tree_current)-&gt;refined == false) return 0;</p>
<p><a class="el" href="class_tree_struct_1_1iterator.html" title="A iterator class fore TreeStruct that allows for movement through the tree without changing anything ...">TreeStruct::iterator</a> s_tree_current(s_tree); assert( s_tree !=NULL);</p>
<p><a class="el" href="struct_branch.html" title="The box representing a branch of a binary tree structure. Used specifically in TreeStruct for organiz...">Branch</a> *branch,*headbranch; <a class="el" href="struct_point.html" title="A point on the source or image plane that contains a position and the lensing quantities.">Point</a> *point; unsigned long Ntmp,NtoRemove,i,count = 0,count2 = 0,count1; PosType center[2]; PointList::iterator i_tree_pointlist_current; PointList::iterator s_tree_pointlist_current;</p>
<p>_freeBranches_iter(s_tree); // s_tree will no longer be valid on exit. This is to make sure it isn't used later without a rebuild.</p>
<p>headbranch = *i_tree_current; i_tree-&gt;TreeWalkStep(true);</p>
<p>while( (headbranch-&gt;child1 != NULL) || (headbranch-&gt;child2 != NULL) ){</p>
<p>assert(boxinbox(*i_tree_current,headbranch)); if(i_tree_current.atLeaf()){ assert(i_tree-&gt;current-&gt;points-&gt;image-&gt;leaf); s_tree-&gt;current = i_tree-&gt;current-&gt;points-&gt;image-&gt;leaf; // set s_tree to source of current image cell</p>
<p>branch = (*i_tree_current)-&gt;prev; i = branch-&gt;npoints;</p>
<p>if((*i_tree_current) != headbranch) i_tree-&gt;RemoveLeafFromTree(i_tree_current,&amp;Ntmp); </p><pre class="fragment">                test line  **************************
</pre><p> assert(*i_tree_current == branch); assert(i == (*i_tree_current)-&gt;npoints); </p><pre class="fragment">                test line  **************************
</pre><p> assert((*i_tree_current)-&gt;points-&gt;next || (*i_tree_current)-&gt;points-&gt;prev);</p>
<p>in a square leaf cell take out extra points that have come up from below</p>
<p>if(i_tree_current.atLeaf() &amp;&amp; (*i_tree_current)-&gt;refined){ test line ************************** assert((*i_tree_current)-&gt;points-&gt;next || (*i_tree_current)-&gt;points-&gt;prev);</p>
<p>std::printf("  collecting points from removed leaves\n"); assert((*i_tree_current)-&gt;points); i_tree_pointlist_current = (*i_tree_current)-&gt;points; NtoRemove = (*i_tree_current)-&gt;npoints; assert(NtoRemove == 9); center[0] = ((*i_tree_current)-&gt;boundary_p1[0] + (*i_tree_current)-&gt;boundary_p2[0])/2; center[1] = ((*i_tree_current)-&gt;boundary_p1[1] + (*i_tree_current)-&gt;boundary_p2[1])/2;</p>
<p>for(i=0,count1=0,count2=0;i&lt;NtoRemove;++i,&ndash;i_tree_pointlist_current){ find central point and remove others </p><pre class="fragment"> if( (pow(center[0]-(*i_tree_pointlist_current)-&gt;x[0],2)
  + pow(center[1]-(*i_tree_pointlist_current)-&gt;x[1],2) )
  &lt; pow((*i_tree_pointlist_current)-&gt;gridsize/2,2) ){

  ++count1;
</pre><p> keep this central point (*i_tree_pointlist_current)-&gt;gridsize *= 3; (*i_tree_pointlist_current)-&gt;image-&gt;gridsize = (*i_tree_pointlist_current)-&gt;gridsize; (*i_tree_current)-&gt;points = (*i_tree_pointlist_current); </p><pre class="fragment">                test line  **************************
</pre><p> assert((*i_tree_current)-&gt;points-&gt;next || (*i_tree_current)-&gt;points-&gt;prev); assert((*i_tree_pointlist_current)-&gt;leaf == *i_tree_current); }else{</p>
<p>++count; // count of total number of points removed ++count2;</p>
<p>reduce the number of particles in all parent cells</p>
<p>First take points out of source plane This is tricky because they are not ordered into square blocks with 9 points in each.</p>
<p>Take point out of the source plane </p><pre class="fragment">  assert((*i_tree_pointlist_current)-&gt;image);
  point = (*i_tree_pointlist_current)-&gt;image;
  assert(point-&gt;leaf);
  s_tree_current = point-&gt;leaf;
</pre><p> if((*s_tree_current)-&gt;npoints &lt; 2) RemoveLeafFromTree(s_tree,&amp;Ntmp); while(!(s_tree_current.atTop())){ &ndash;((*s_tree_current)-&gt;npoints); if((*s_tree_current)-&gt;npoints &gt; 0 &amp;&amp; (*s_tree_current)-&gt;points == point) (*s_tree_current)-&gt;points = point-&gt;next;</p>
<p>if((*s_tree_current)-&gt;npoints == 0) (*s_tree_current)-&gt;points = NULL;</p>
<p>if((*s_tree_current)-&gt;npoints == 0 &amp;&amp; (*s_tree_current)-&gt;prev-&gt;npoints == 1){ only remove empty leaves if it will make its parent a leaf assert(s_tree_current.atLeaf()); s_tree-&gt;RemoveLeafFromTree(s_tree_current,&amp;Ntmp); s_tree_current.TreeWalkStep(true); // Go to other child. s_tree-&gt;RemoveLeafFromTree(s_tree_current,&amp;Ntmp); }else{ s_tree_current.up(); } } assert(boxinbox(*i_tree_current,headbranch));</p>
<p>Do it for top &ndash;(s_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;npoints); if(s_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;npoints &gt; 0 &amp;&amp; s_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;points == point) s_tree-&gt;<a class="el" href="struct_tree_struct.html#a5e30cc9c4338d888800cd6f45cd69547" title="root branch">getTop()</a>-&gt;points = point-&gt;next;</p>
<p>s_tree_pointlist_current = point; s_tree-&gt;pointlist.TakeOutCurrent(s_tree_pointlist_current); point-&gt;leaf = NULL; // set leaf to NULL to indicate that point is no longer in tree if(point-&gt;head) trashkist-&gt;InsertAfterCurrent(point); // collect heads for later trash collection</p>
<p>assert(boxinbox(*i_tree_current,headbranch));</p>
<p>take points out of image plane branch = *i_tree_current; do{ assert((*i_tree_current)-&gt;npoints); &ndash;((*i_tree_current)-&gt;npoints); if((*i_tree_current)-&gt;points == (*i_tree_pointlist_current)) (*i_tree_current)-&gt;points = NULL;</p>
<p>}while(i_tree_current.up()); i_tree_current = branch; assert(boxinbox(*i_tree_current,headbranch));</p>
<p>if((*i_tree_pointlist_current) == (*i_tree_current)-&gt;points) (*i_tree_current)-&gt;points = (*i_tree_pointlist_current)-&gt;next; point = i_tree-&gt;pointlist.TakeOutCurrent(i_tree_pointlist_current); point-&gt;leaf = NULL; If point is a head of a memory block add it to trashlist for eventual trash collection if(point-&gt;head){ assert(point-&gt;head == 8); trashkist-&gt;InsertAfterCurrent(point); } } assert(boxinbox(*i_tree_current,headbranch));</p>
<p>} // loop through points in leaf</p>
<p>reassign first point in branches above the current branch = *i_tree_current; do{ assert((*i_tree_current)-&gt;npoints); if((*i_tree_current)-&gt;points == NULL) (*i_tree_current)-&gt;points = branch-&gt;points; }while(i_tree_current.up()); i_tree_current = branch;</p>
<p>assert(boxinbox(*i_tree_current,headbranch));</p>
<p>assert(count1 == 1); assert(count2 == 8); assert((*i_tree_current)-&gt;npoints == 1); } // if current was leaf that was refined</p>
<p>} // at tree leaf assert((*i_tree_current)-&gt;points); assert(boxinbox(*i_tree_current,headbranch));</p>
<p>if( !(i_tree_current.atLeaf()) ) i_tree_current.TreeWalkStep(true); } // while entry current is not a leaf</p>
<p>assert(CurrentIsSquareTree(i_tree)); assert((*i_tree_current)-&gt;npoints == 1); assert(i_tree_current.atLeaf()); assert(*i_tree_current == headbranch);</p>
<p>(*i_tree_current)-&gt;refined = false;</p>
<p>Free the memory for the points that have been removed. CollectTrash(trashkist,false);</p>
<p>assert(trashkist-&gt;Nunits() == 0); if(count) std::printf("FreeBranchesBelow() freed %li points and moved up %li points\n",count,count2); return count; } Removes current from a tree if it is a leaf. Will not remove root of tree.</p>
<p>on output: Current is left at the father of the leaf that was removed. All the points in the leaf that was removed are in its father so the father might be a leaf without Nbucket points. The -&gt;leaf pointer of these points are reassigned to the father.</p>
<p>returns: Pointer to first in list of points that were reassigned. *Npoints = number of points reassigned. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>SLsimLib/include/<a class="el" href="_tree_8h_source.html">Tree.h</a></li>
<li>SLsimLib/TreeCode_link/<a class="el" href="_kist_driver_8cpp.html">KistDriver.cpp</a></li>
<li>SLsimLib/TreeCode_link/Tree.cpp</li>
<li>SLsimLib/TreeCode_link/tree_maintenance.cpp</li>
<li>SLsimLib/TreeCode_link/TreeDriver.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri May 12 2023 11:35:11 for GLAMERDOC++ by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
