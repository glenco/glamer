\doxysection{Utilities Namespace Reference}
\hypertarget{namespace_utilities}{}\label{namespace_utilities}\index{Utilities@{Utilities}}



\begin{DoxyItemize}
\item 
\end{DoxyItemize} 


\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespace_utilities_1_1_geometry}{Geometry}}
\begin{DoxyCompactList}\small\item\em Namespace for geometrical functions mostly having to do with spherical coordinates. \end{DoxyCompactList}\item 
namespace \mbox{\hyperlink{namespace_utilities_1_1_i_o}{IO}}
\begin{DoxyCompactList}\small\item\em namespace for input/output utilities \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_utilities_1_1_d2_matrix}{D2\+Matrix}}
\begin{DoxyCompactList}\small\item\em 2 dimensional matrix \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_d3_matrix}{D3\+Matrix}}
\begin{DoxyCompactList}\small\item\em 3 dimensional matrix, fixed size \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_data_frame}{Data\+Frame}}
\begin{DoxyCompactList}\small\item\em class for impoting data from a csv file and allowing label string lookup like a data frame. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_hilbert_curve}{Hilbert\+Curve}}
\begin{DoxyCompactList}\small\item\em Class for calculating the Hilbert curve distance in two dimensions. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_interpolator}{Interpolator}}
\begin{DoxyCompactList}\small\item\em Bilinear interpolation class for interpolating from a 2D uniform grid. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_mixed_vector}{Mixed\+Vector}}
\begin{DoxyCompactList}\small\item\em A container that can hold mixed objects all derived from a base class and retains the ability to access derived class functions/members. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4}{Mixed\+Vector$<$ Base\+T \texorpdfstring{$\ast$}{*} $>$}}
\begin{DoxyCompactList}\small\item\em A \doxylink{class_utilities_1_1_mixed_vector}{Mixed\+Vector} for pointers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Random\+Numbers\+\_\+\+NR}}
\begin{DoxyCompactList}\small\item\em This is a class for generating random numbers. It simplifies and fool proofs initialization and allows for multiple independent series of numbers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_shuffled_index}{Shuffled\+Index}}
\begin{DoxyCompactList}\small\item\em Gives a randomized sequence of numbers from 0 to N-\/1. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_s_u_m_m_e_r}{SUMMER}}
\begin{DoxyCompactList}\small\item\em class for adding large amounts of numbers with less error than the simple sum \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_symmetric_matrix}{Symmetric\+Matrix}}
\begin{DoxyCompactList}\small\item\em Symetric matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespace_utilities_a83d3f6d35f48dd5cf7ff992a6c36ee8a}\label{namespace_utilities_a83d3f6d35f48dd5cf7ff992a6c36ee8a} 
void {\bfseries print\+\_\+date} ()
\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a380f0a954728d751781e61918facba0e}{fill\+\_\+linear}} (std\+::vector$<$ T $>$ \&v, size\+\_\+t n, T min, T max)
\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a}{fill\+\_\+logarithmic}} (std\+::vector$<$ T $>$ \&v, size\+\_\+t n, T min, T max)
\item 
{\footnotesize template$<$class T $>$ }\\long \mbox{\hyperlink{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e}{locate}} (const std\+::vector$<$ T $>$ \&v, const T x)
\item 
{\footnotesize template$<$class T , class F $>$ }\\long \mbox{\hyperlink{namespace_utilities_ab7663a1f094849a77cab564e61fcca49}{locate}} (const std\+::vector$<$ T $>$ \&v, F x, std\+::function$<$ bool(F, const T \&)$>$ less\+\_\+than)
\item 
\Hypertarget{namespace_utilities_a0cfb54fff515cfd5d684572962f50c66}\label{namespace_utilities_a0cfb54fff515cfd5d684572962f50c66} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries locate} (T \texorpdfstring{$\ast$}{*}v, unsigned long n, T x, unsigned long \texorpdfstring{$\ast$}{*}index)
\item 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t \mbox{\hyperlink{namespace_utilities_acc053736fab41bd2807991e8dfcab129}{locate}} (const std\+::vector$<$ T $>$ \&v, const std\+::vector$<$ size\+\_\+t $>$ \&sorted\+\_\+index, T value, size\+\_\+t \&rank)
\begin{DoxyCompactList}\small\item\em Finds the element of a vector given a sorted index of the vector. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_aa80185750e610681c64de174516f9799}\label{namespace_utilities_aa80185750e610681c64de174516f9799} 
{\footnotesize template$<$class T $>$ }\\size\+\_\+t {\bfseries closest} (const std\+::vector$<$ T $>$ \&v, const T x)
\begin{DoxyCompactList}\small\item\em Returns the index of the element of v that is closest to x. v must be sorted. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e}{Interpolate\+Yvec}} (std\+::vector$<$ Pos\+Type $>$ \&x, std\+::vector$<$ Pos\+Type $>$ \&y, Pos\+Type xi)
\item 
\Hypertarget{namespace_utilities_a49c02a235f698cf25dbc7edf34d4bf8f}\label{namespace_utilities_a49c02a235f698cf25dbc7edf34d4bf8f} 
Pos\+Type {\bfseries arctanh} (Pos\+Type x)
\item 
\Hypertarget{namespace_utilities_a473f872514990ed70931ddd9489301a7}\label{namespace_utilities_a473f872514990ed70931ddd9489301a7} 
Pos\+Type {\bfseries fmini} (Pos\+Type a, Pos\+Type b)
\item 
\Hypertarget{namespace_utilities_af99adc537b02f26073243f0d32376def}\label{namespace_utilities_af99adc537b02f26073243f0d32376def} 
Pos\+Type {\bfseries fmaxi} (Pos\+Type a, Pos\+Type b)
\item 
\Hypertarget{namespace_utilities_a1ec52aba262343bc391860a37da4d472}\label{namespace_utilities_a1ec52aba262343bc391860a37da4d472} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries median} (std\+::vector$<$ T $>$ vec)
\begin{DoxyCompactList}\small\item\em find median of vector \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}\label{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries range} (std\+::vector$<$ T $>$ vec, T \&max, T \&min)
\begin{DoxyCompactList}\small\item\em find the maximum and minimum of a vector \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a85e6e176b88221d17c1a0d6c83a6846d}\label{namespace_utilities_a85e6e176b88221d17c1a0d6c83a6846d} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries polintT} (T xa\mbox{[}$\,$\mbox{]}, T ya\mbox{[}$\,$\mbox{]}, int n, T x, T \texorpdfstring{$\ast$}{*}y, T \texorpdfstring{$\ast$}{*}dy)
\begin{DoxyCompactList}\small\item\em interpolation \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a7679e167450f3450c86c345cd8de373d}\label{namespace_utilities_a7679e167450f3450c86c345cd8de373d} 
{\footnotesize template$<$typename Functor\+Type , typename T  = double$>$ }\\T {\bfseries trapz} (Functor\+Type \&func, T a, T b, int n, T \texorpdfstring{$\ast$}{*}s2)
\begin{DoxyCompactList}\small\item\em used in trapizoidal integral \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Functor\+Type , typename T  = double$>$ }\\T \mbox{\hyperlink{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98}{nintegrateF}} (Functor\+Type func, T a, T b, T tols)
\item 
\Hypertarget{namespace_utilities_a82fcbd40d2ef2b1d3091916c96afff26}\label{namespace_utilities_a82fcbd40d2ef2b1d3091916c96afff26} 
long {\bfseries lmin} (long a, long b)
\item 
\Hypertarget{namespace_utilities_a50e91e92e30e6084b2400012f23bd52b}\label{namespace_utilities_a50e91e92e30e6084b2400012f23bd52b} 
long {\bfseries lmax} (long a, long b)
\item 
\Hypertarget{namespace_utilities_a31db9f78433a6de800437aedfd1b2eb5}\label{namespace_utilities_a31db9f78433a6de800437aedfd1b2eb5} 
void {\bfseries rotation} (float \texorpdfstring{$\ast$}{*}xout, float \texorpdfstring{$\ast$}{*}xin, Pos\+Type theta)
\begin{DoxyCompactList}\small\item\em Rotates 2 dimensional point without changing input point. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a8ad140aa2e74c584b82ff6416ff16622}\label{namespace_utilities_a8ad140aa2e74c584b82ff6416ff16622} 
void {\bfseries rotation} (Pos\+Type \texorpdfstring{$\ast$}{*}xout, Pos\+Type const \texorpdfstring{$\ast$}{*}xin, Pos\+Type theta)
\begin{DoxyCompactList}\small\item\em Rotates 2 dimensional point without changing input point. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a0855636bdb71f103a4412555b9711e98}{Random\+From\+Table}} (Pos\+Type \texorpdfstring{$\ast$}{*}table, unsigned long Ntable, long \texorpdfstring{$\ast$}{*}seed)
\begin{DoxyCompactList}\small\item\em Generates a random deviates drawn f\+Einstein\+\_\+rom app\+Einstein\+\_\+roximately the same as the values of table. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_aae5ae9b5d81618c5ab06016357dc6c7d}\label{namespace_utilities_aae5ae9b5d81618c5ab06016357dc6c7d} 
{\footnotesize template$<$typename T , typename P $>$ }\\\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries subtract} (T \&p1, P \&p2)
\item 
\Hypertarget{namespace_utilities_a34ba39540d95cbeaa6a00631c640ca7f}\label{namespace_utilities_a34ba39540d95cbeaa6a00631c640ca7f} 
{\footnotesize template$<$typename P $>$ }\\double {\bfseries crossD} (P \&O, P \&A, P \&B)
\item 
\Hypertarget{namespace_utilities_a02302245829df0b35aca33fc6415cb96}\label{namespace_utilities_a02302245829df0b35aca33fc6415cb96} 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t {\bfseries Remove\+Intersections} (std\+::vector$<$ T $>$ \&curve)
\begin{DoxyCompactList}\small\item\em removes the intersections of the curve \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \mbox{\hyperlink{namespace_utilities_a7f2aed1fb05038e399bf1287d64b56ec}{Tighter\+Hull}} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v)
\item 
\Hypertarget{namespace_utilities_ac6c2b9ec5013e30e7b10d2ba8279e91e}\label{namespace_utilities_ac6c2b9ec5013e30e7b10d2ba8279e91e} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ {\bfseries Tightest\+Hull} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v)
\begin{DoxyCompactList}\small\item\em Finds a concave envolope for an arbitrary closed curve. This is done by gridding and then finding points that are withing a sertain distance of a segment of the curve. The outer bounding curve is found and then the cuve is shrunck to the closest point on a segment. This should be fool proof, but is relatively slow and might clip some points. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_abdf99510eca3c45fe58e3dbb9ca49903}\label{namespace_utilities_abdf99510eca3c45fe58e3dbb9ca49903} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries Random\+In\+Triangle} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x1, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x2, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x3, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em returns random point within a trinagle \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_acf33af36f9a2b838dd1d875d10c94e68}\label{namespace_utilities_acf33af36f9a2b838dd1d875d10c94e68} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries Random\+In\+Convex\+Poly} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em return a point within a convex polygon \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_abec39f1ef6af129844e062e851a691ed}\label{namespace_utilities_abec39f1ef6af129844e062e851a691ed} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ {\bfseries Random\+In\+Convex\+Poly} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, int N, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\item 
\Hypertarget{namespace_utilities_a1f11f01f953cf74005513ad55a31dde4}\label{namespace_utilities_a1f11f01f953cf74005513ad55a31dde4} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries Random\+In\+Poly} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em return a point within a polygon that doesn\textquotesingle{}t need to be convex \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ae6503ec67bb7c13479823174345af21f}\label{namespace_utilities_ae6503ec67bb7c13479823174345af21f} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ {\bfseries Random\+In\+Poly} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, int N, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\item 
\Hypertarget{namespace_utilities_af8f29cb220d5013f55306a8fb6f245a2}\label{namespace_utilities_af8f29cb220d5013f55306a8fb6f245a2} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries Random\+Near\+Poly} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, double R, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em return a point within distance R of a polygon, i.\+e. the center of a cicle that intersects the interior of a polygon \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a1394fabbbd7c898a96579347b9817652}\label{namespace_utilities_a1394fabbbd7c898a96579347b9817652} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ {\bfseries Random\+Near\+Poly} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&pp, int N, double R, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\item 
{\footnotesize template$<$typename P $>$ }\\void \mbox{\hyperlink{namespace_utilities_a3ded74005933c13892203f9ad15cdbb0}{find\+\_\+boundaries}} (std\+::vector$<$ bool $>$ \&bitmap, long nx, std\+::vector$<$ std\+::vector$<$ P $>$ $>$ \&points, std\+::vector$<$ bool $>$ \&hits\+\_\+edge, bool add\+\_\+to\+\_\+vector=false, bool outer\+\_\+only=false)
\begin{DoxyCompactList}\small\item\em finds ordered boundaries to regions where bitmap == true \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_aed791a1510ae7571dde0bd77ff4d1891}\label{namespace_utilities_aed791a1510ae7571dde0bd77ff4d1891} 
void {\bfseries find\+\_\+islands} (std\+::vector$<$ bool $>$ \&bitmap, long nx, std\+::vector$<$ std\+::vector$<$ long $>$ $>$ \&indexes, std\+::vector$<$ bool $>$ \&hits\+\_\+edge, bool add\+\_\+to\+\_\+vector=false)
\begin{DoxyCompactList}\small\item\em find the indexes of areas with bitmap\mbox{[}\mbox{]}=true broken up into diconnected islands \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a69d1b7298e1abe02b0d631ce556621b8}\label{namespace_utilities_a69d1b7298e1abe02b0d631ce556621b8} 
double {\bfseries interior\+\_\+mass} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&alpha, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&x)
\begin{DoxyCompactList}\small\item\em this returns area within the curve x average kappa iwithin the curve \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_afdd97747d61e6407e4c421eef6f04441}\label{namespace_utilities_afdd97747d61e6407e4c421eef6f04441} 
double {\bfseries interior\+\_\+mass} (const std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&rays)
\begin{DoxyCompactList}\small\item\em this returns area within the curve x average kappa iwithin the curve \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ac0dc30c5f6b7875ed50bcae884432756}\label{namespace_utilities_ac0dc30c5f6b7875ed50bcae884432756} 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ {\bfseries convex\+\_\+hull} (const std\+::vector$<$ T $>$ \&PP)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a181252f6287df861af9107445a4cac7f}{convex\+\_\+hull}} (const std\+::vector$<$ T $>$ \&P, std\+::vector$<$ size\+\_\+t $>$ \&hull)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a6d17c2495bead70b18b91c376c28c051}{concave}} (std\+::vector$<$ T $>$ \&init\+\_\+points, std\+::vector$<$ T $>$ \&hull\+\_\+out, double scale)
\begin{DoxyCompactList}\small\item\em Creates the concave hull of a group of 2 dimensional points by the shrink-\/wrap algorithm. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ada0d6ff1e45b34802a2489b00778973a}\label{namespace_utilities_ada0d6ff1e45b34802a2489b00778973a} 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ {\bfseries concave2} (std\+::vector$<$ T $>$ \&init\+\_\+points, double scale)
\item 
\Hypertarget{namespace_utilities_aa741aedb82522c567b5124153cdea583}\label{namespace_utilities_aa741aedb82522c567b5124153cdea583} 
{\footnotesize template$<$typename Ptype $>$ }\\double {\bfseries distance\+\_\+to\+\_\+segment} (const Ptype \&P, const Ptype \&S1, const Ptype \&S2)
\item 
\Hypertarget{namespace_utilities_a581ceebfd95eafc258f7a8d932a2d2e8}\label{namespace_utilities_a581ceebfd95eafc258f7a8d932a2d2e8} 
{\footnotesize template$<$typename Ptype $>$ }\\double {\bfseries distance\+\_\+to\+\_\+segment} (const Ptype \&P, const Ptype \&S1, const Ptype \&S2, Ptype \&closest\+\_\+point)
\item 
\Hypertarget{namespace_utilities_ad7806b8fa0368de7ee40f453c05c4561}\label{namespace_utilities_ad7806b8fa0368de7ee40f453c05c4561} 
{\footnotesize template$<$typename Ptype $>$ }\\bool {\bfseries segments\+\_\+cross} (const Ptype \&a1, const Ptype \&a2, const Ptype \&b1, const Ptype \&b2)
\item 
\Hypertarget{namespace_utilities_afc7611a51add4102b0f2109c5d652a20}\label{namespace_utilities_afc7611a51add4102b0f2109c5d652a20} 
{\footnotesize template$<$typename Ptype $>$ }\\bool {\bfseries in\+Curve} (const Ptype \&x, const std\+::vector$<$ Ptype $>$ \&H)
\item 
\Hypertarget{namespace_utilities_af814c998581b6e9f30a929c7508a1eff}\label{namespace_utilities_af814c998581b6e9f30a929c7508a1eff} 
{\footnotesize template$<$typename Ptype $>$ }\\bool {\bfseries inhull} (Pos\+Type x\mbox{[}$\,$\mbox{]}, const std\+::vector$<$ Ptype $>$ \&H)
\item 
\Hypertarget{namespace_utilities_a1c697ef2e7c68ba5b3d68ffa0f1bb65b}\label{namespace_utilities_a1c697ef2e7c68ba5b3d68ffa0f1bb65b} 
template$<$$>$ bool {\bfseries inhull$<$ Point \texorpdfstring{$\ast$}{*} $>$} (Pos\+Type x\mbox{[}$\,$\mbox{]}, const std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&H)
\item 
\Hypertarget{namespace_utilities_a85c8c08716d4ebdceb0b8c31d543773a}\label{namespace_utilities_a85c8c08716d4ebdceb0b8c31d543773a} 
template$<$$>$ bool {\bfseries inhull$<$ RAY $>$} (Pos\+Type x\mbox{[}$\,$\mbox{]}, const std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&H)
\begin{DoxyCompactList}\small\item\em finds in x is within the curve discribed by the H\mbox{[}\mbox{]}.x points ie image points \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a5f5cdf470897a1c0fa3f63c06ce8a1ce}\label{namespace_utilities_a5f5cdf470897a1c0fa3f63c06ce8a1ce} 
template$<$$>$ bool {\bfseries inhull$<$ Pos\+Type \texorpdfstring{$\ast$}{*} $>$} (Pos\+Type x\mbox{[}$\,$\mbox{]}, const std\+::vector$<$ Pos\+Type \texorpdfstring{$\ast$}{*} $>$ \&H)
\item 
{\footnotesize template$<$typename Ptype $>$ }\\std\+::vector$<$ Ptype $>$ \mbox{\hyperlink{namespace_utilities_abe345295eb171c0665350842426124bd}{concaveK}} (std\+::vector$<$ Ptype $>$ \&points, int \&k, bool check=true)
\item 
\Hypertarget{namespace_utilities_a073b41b6e45e881bc03e94bd2548ebad}\label{namespace_utilities_a073b41b6e45e881bc03e94bd2548ebad} 
{\footnotesize template$<$typename Ptype $>$ }\\void {\bfseries testconcaveK} ()
\item 
\Hypertarget{namespace_utilities_af55b9c3d5f503bd2c5544cdec2d5aa42}\label{namespace_utilities_af55b9c3d5f503bd2c5544cdec2d5aa42} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries line\+\_\+intersection} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&v1, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&v2, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&w1, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&w2)
\begin{DoxyCompactList}\small\item\em return the interesetion point of line defined by v1,v2 and w1,w2 \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_afc0243f1746707bddd91dd1295795f9e}\label{namespace_utilities_afc0243f1746707bddd91dd1295795f9e} 
bool {\bfseries circle\+Intersets\+Curve} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, double r, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v)
\begin{DoxyCompactList}\small\item\em returns true if a circle of radius r around the point x intersects with the curve v. Does not include case where one compleatly encloses the other. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_aed8667e8dfb7a5c44ae73262f63dd2ba}\label{namespace_utilities_aed8667e8dfb7a5c44ae73262f63dd2ba} 
bool {\bfseries circle\+Overlaps\+Curve} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, double r, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v)
\begin{DoxyCompactList}\small\item\em Returns true if there is any overlap between a curve and a circle. This includea cases where one compleatly encloses the other. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \mbox{\hyperlink{namespace_utilities_a6b3b3327085b03c3dcbb1afadd59fcd4}{envelope}} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&w)
\begin{DoxyCompactList}\small\item\em Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \mbox{\hyperlink{namespace_utilities_a8baf3c89ecca31f0771e2d781a856f20}{envelope2}} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&w)
\begin{DoxyCompactList}\small\item\em Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. \end{DoxyCompactList}\item 
std\+::vector$<$ std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ $>$ \mbox{\hyperlink{namespace_utilities_a8de229537fd082d389db103bd918160a}{thicken\+\_\+poly}} (const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&v, double R)
\begin{DoxyCompactList}\small\item\em return the boundaries of the region that is within R of the curve v \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2}{Read\+File\+Names}} (std\+::string dir, const std\+::string filespec, std\+::vector$<$ std\+::string $>$ \&filenames, const std\+::string file\+\_\+non\+\_\+spec="{} "{}, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Reads all the fits files in a directory into a vector of Pixel\+Maps. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_af1ce4c9e1180dd33a9f4c0c416643a9e}\label{namespace_utilities_af1ce4c9e1180dd33a9f4c0c416643a9e} 
Pos\+Type {\bfseries sep\+SQR} (Pos\+Type \texorpdfstring{$\ast$}{*}xx, Pos\+Type \texorpdfstring{$\ast$}{*}yy)
\begin{DoxyCompactList}\small\item\em Separation squared between two positions in 2 dimensions. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a367c5422e8b232b598bfdf69131a7a41}\label{namespace_utilities_a367c5422e8b232b598bfdf69131a7a41} 
void {\bfseries double\+\_\+sort} (unsigned long n, Pos\+Type \texorpdfstring{$\ast$}{*}arr, unsigned long \texorpdfstring{$\ast$}{*}brr)
\item 
void \mbox{\hyperlink{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2}{double\+\_\+sort\+\_\+points}} (unsigned long n, Pos\+Type \texorpdfstring{$\ast$}{*}arr, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}brr)
\begin{DoxyCompactList}\small\item\em Sorts points in a point array. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a069e88bf3ba4576f526f75cd607954d4}\label{namespace_utilities_a069e88bf3ba4576f526f75cd607954d4} 
void {\bfseries quicksort\+Points} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, Pos\+Type \texorpdfstring{$\ast$}{*}arr, unsigned long N)
\begin{DoxyCompactList}\small\item\em Sorts points from smallest to largest according to the value of arr\mbox{[}\mbox{]}. Sorts arr\mbox{[}\mbox{]} and pointarray\mbox{[}\mbox{]} simultaneously. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_afe0f971972428328fbfecb023efa932b}\label{namespace_utilities_afe0f971972428328fbfecb023efa932b} 
void {\bfseries quicksort\+Points} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, double(\texorpdfstring{$\ast$}{*}func)(\mbox{\hyperlink{struct_point}{Point}} \&), unsigned long N)
\item 
\Hypertarget{namespace_utilities_a616805c8dcc25692640ce161f5d4d6be}\label{namespace_utilities_a616805c8dcc25692640ce161f5d4d6be} 
{\footnotesize template$<$typename D $>$ }\\void {\bfseries quicksort} (unsigned long \texorpdfstring{$\ast$}{*}particles, D \texorpdfstring{$\ast$}{*}arr, unsigned long N)
\item 
\Hypertarget{namespace_utilities_aa6be6f6a86b7b31f27b6d38ebcb93d6c}\label{namespace_utilities_aa6be6f6a86b7b31f27b6d38ebcb93d6c} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition} (T pivotvalue, unsigned long \texorpdfstring{$\ast$}{*}pivotindex, unsigned long \texorpdfstring{$\ast$}{*}particles, T \texorpdfstring{$\ast$}{*}arr, unsigned long N)
\item 
\Hypertarget{namespace_utilities_a0087080ad4336acd526aeb64e114176e}\label{namespace_utilities_a0087080ad4336acd526aeb64e114176e} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition\+Points} (T pivotvalue, unsigned long \texorpdfstring{$\ast$}{*}pivotindex, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, T \texorpdfstring{$\ast$}{*}arr, unsigned long N)
\item 
\Hypertarget{namespace_utilities_aed119e61f1d5a87c46cbc2e4e5e574e1}\label{namespace_utilities_aed119e61f1d5a87c46cbc2e4e5e574e1} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition\+Points} (T pivotvalue, unsigned long \texorpdfstring{$\ast$}{*}pivotindex, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, T(\texorpdfstring{$\ast$}{*}func)(\mbox{\hyperlink{struct_point}{Point}} \&p), unsigned long N)
\item 
\Hypertarget{namespace_utilities_a606f4aebc622ae58090979fda604d1fc}\label{namespace_utilities_a606f4aebc622ae58090979fda604d1fc} 
void {\bfseries log\+\_\+polar\+\_\+grid} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}i\+\_\+points, Pos\+Type rmax, Pos\+Type rmin, Pos\+Type \texorpdfstring{$\ast$}{*}center, long Ngrid)
\item 
\Hypertarget{namespace_utilities_a7c5dac005305573c90d3c46db67967a0}\label{namespace_utilities_a7c5dac005305573c90d3c46db67967a0} 
void {\bfseries findarea} (\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}imageinfo)
\item 
void \mbox{\hyperlink{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d}{write\+Curves}} (int m, \mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}critical, int Ncrit, int index)
\item 
\Hypertarget{namespace_utilities_ac66dea830e7b8f4390339d39eca8af68}\label{namespace_utilities_ac66dea830e7b8f4390339d39eca8af68} 
Pos\+Type {\bfseries cross} (const \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}O, const \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}A, const \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}B)
\item 
\Hypertarget{namespace_utilities_ac42b802d503f1acd2f3d92eb903b9228}\label{namespace_utilities_ac42b802d503f1acd2f3d92eb903b9228} 
bool {\bfseries xorder} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p1, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p2)
\item 
\Hypertarget{namespace_utilities_a62ff8c370817f6c178c77b361cca0292}\label{namespace_utilities_a62ff8c370817f6c178c77b361cca0292} 
bool {\bfseries yorder} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p1, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p2)
\item 
\Hypertarget{namespace_utilities_afbe6171a36bf18a88838285e19f90d63}\label{namespace_utilities_afbe6171a36bf18a88838285e19f90d63} 
Pos\+Type {\bfseries crossD} (const double \texorpdfstring{$\ast$}{*}O, const double \texorpdfstring{$\ast$}{*}A, const double \texorpdfstring{$\ast$}{*}B)
\item 
\Hypertarget{namespace_utilities_a6ee147c1f79d2a84f9426c0dd7848ef4}\label{namespace_utilities_a6ee147c1f79d2a84f9426c0dd7848ef4} 
Pos\+Type {\bfseries crossD} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&O, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&A, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&B)
\item 
\Hypertarget{namespace_utilities_a6997f6bfc95f466039c9652c6c50274f}\label{namespace_utilities_a6997f6bfc95f466039c9652c6c50274f} 
std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ {\bfseries convex\+\_\+hull} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&P)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a0699a4c75e3899f853dee3fe6a442a25}\label{namespace_utilities_a0699a4c75e3899f853dee3fe6a442a25} 
std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ {\bfseries convex\+\_\+hull} (std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ \&P)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{namespace_utilities_aca82634714ad53172788a38cef165b07}{concave\+\_\+hull}} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&P, int k, bool test=false)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convcave hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ \mbox{\hyperlink{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4}{concave\+\_\+hull}} (std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ \&P, int k)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convcave hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d}{contour\+\_\+ellipse}} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&P, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} center, unsigned long Npoints, std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&C, double \texorpdfstring{$\ast$}{*}ellipticity, double \texorpdfstring{$\ast$}{*}ellipse\+\_\+area)
\begin{DoxyCompactList}\small\item\em Returns axis ratio, area and points of an ellipse engulfed by some contour (e.\+g. a contour of same convergence calculated with find\+\_\+contour). \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ab6187b4dcc9357787a98f62c63b5b716}\label{namespace_utilities_ab6187b4dcc9357787a98f62c63b5b716} 
void {\bfseries contour\+\_\+ellipse} (std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&P, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} center, unsigned long Npoints, std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&C, double \texorpdfstring{$\ast$}{*}ellipticity, double \texorpdfstring{$\ast$}{*}ellipse\+\_\+area)
\item 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \mbox{\hyperlink{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}{contour\+\_\+center}} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&P, unsigned long Npoints)
\begin{DoxyCompactList}\small\item\em Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a3c1adbf25f771564249b51be04a10b09}\label{namespace_utilities_a3c1adbf25f771564249b51be04a10b09} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries contour\+\_\+center} (std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&P, unsigned long Npoints)
\item 
\Hypertarget{namespace_utilities_aa727547d253bdbd88ac47cae3f7c65c4}\label{namespace_utilities_aa727547d253bdbd88ac47cae3f7c65c4} 
long {\bfseries Index\+From\+Position} (Pos\+Type \texorpdfstring{$\ast$}{*}x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, const Pos\+Type \texorpdfstring{$\ast$}{*}center)
\item 
\Hypertarget{namespace_utilities_afa68bfc533f3ce300625ec2b97073800}\label{namespace_utilities_afa68bfc533f3ce300625ec2b97073800} 
void {\bfseries Position\+From\+Index} (unsigned long i, Pos\+Type \texorpdfstring{$\ast$}{*}x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type const \texorpdfstring{$\ast$}{*}center)
\begin{DoxyCompactList}\small\item\em This should work for square regions. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a97a19e41534673a4234e99cce59b0a23}\label{namespace_utilities_a97a19e41534673a4234e99cce59b0a23} 
long {\bfseries Index\+From\+Position} (Pos\+Type x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type center)
\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104}{Two\+DInterpolator}} (Pos\+Type \texorpdfstring{$\ast$}{*}x,int Npixels,Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}},Pos\+Type \texorpdfstring{$\ast$}{*}center,Pos\+Type \texorpdfstring{$\ast$}{*}map,bool init)
\begin{DoxyCompactList}\small\item\em bilinear interpolation from a map. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_af1cbfc7c5cbcb4525faabc04298eb54d}\label{namespace_utilities_af1cbfc7c5cbcb4525faabc04298eb54d} 
Pos\+Type {\bfseries Two\+DInterpolator} (Pos\+Type \texorpdfstring{$\ast$}{*}map)
\item 
\Hypertarget{namespace_utilities_a712b815d57f9f34d4d2e02209bfc1c2b}\label{namespace_utilities_a712b815d57f9f34d4d2e02209bfc1c2b} 
{\footnotesize template$<$typename T $>$ }\\int {\bfseries cutbox} (const T \texorpdfstring{$\ast$}{*}center, T \texorpdfstring{$\ast$}{*}p1, T \texorpdfstring{$\ast$}{*}p2, float rmax)
\item 
\Hypertarget{namespace_utilities_ac985ac1b171f2d550864536530bbac2f}\label{namespace_utilities_ac985ac1b171f2d550864536530bbac2f} 
{\footnotesize template$<$int lev$>$ }\\void {\bfseries quicksort\+Points\+\_\+multithread} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, Pos\+Type \texorpdfstring{$\ast$}{*}arr, unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2\texorpdfstring{$^\wedge$}{\string^}lev. The last parameter should be left out when calling so that it takes the default value. \end{DoxyCompactList}\item 
{\footnotesize template$<$int lev$>$ }\\void \mbox{\hyperlink{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a}{quicksort\+Points\+\_\+multithread}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}pointarray, double(\texorpdfstring{$\ast$}{*}func)(\mbox{\hyperlink{struct_point}{Point}} \&), unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2\texorpdfstring{$^\wedge$}{\string^}lev. The function {\ttfamily func} takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}\label{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48} 
{\footnotesize template$<$typename T , int lev$>$ }\\void {\bfseries quicksort\+\_\+multithread} (T \texorpdfstring{$\ast$}{*}array, double(\texorpdfstring{$\ast$}{*}func)(T \&), unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2\texorpdfstring{$^\wedge$}{\string^}lev. The function {\ttfamily func} takes a T type and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. std\+::swap() is used to swap elements of the array. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a0f92371d63e47b1c09977312f15a15f0}\label{namespace_utilities_a0f92371d63e47b1c09977312f15a15f0} 
float {\bfseries is\+Left} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p0, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}p1, Pos\+Type \texorpdfstring{$\ast$}{*}x)
\item 
\Hypertarget{namespace_utilities_a281a4ca91cc4e6ba6380b946ed5457af}\label{namespace_utilities_a281a4ca91cc4e6ba6380b946ed5457af} 
float {\bfseries is\+Left} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&p0, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&p1, const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x)
\item 
unsigned long \mbox{\hyperlink{namespace_utilities_abe61342a713adf7115f351e3342a2b79}{prevpower}} (unsigned long k)
\item 
int \mbox{\hyperlink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings}} (Pos\+Type \texorpdfstring{$\ast$}{*}x,\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}points,unsigned long Npoints,Pos\+Type \texorpdfstring{$\ast$}{*}area,short image)
\begin{DoxyCompactList}\small\item\em \doxylink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings()}\+: winding number test for a point in a polygon Returns\+: Number of times a curves winds around the point x. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa}{windings}} (Pos\+Type \texorpdfstring{$\ast$}{*}x, \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}points, unsigned long Npoints, Pos\+Type \texorpdfstring{$\ast$}{*}area, short image=0)
\item 
int \mbox{\hyperlink{namespace_utilities_a09f4dcf28911d550c9bd20eeba202f5f}{windings}} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&point, Pos\+Type \texorpdfstring{$\ast$}{*}area)
\item 
int \mbox{\hyperlink{namespace_utilities_afc8d337b886b466535a29068af0b4994}{windings}} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&point, Pos\+Type \texorpdfstring{$\ast$}{*}area)
\item 
int \mbox{\hyperlink{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa}{windings}} (Pos\+Type \texorpdfstring{$\ast$}{*}x, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}kist, Pos\+Type \texorpdfstring{$\ast$}{*}area, short image=0)
\item 
int \mbox{\hyperlink{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065}{windings2}} (Pos\+Type \texorpdfstring{$\ast$}{*}x,\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}points\+\_\+original,unsigned long Npoints,Pos\+Type \texorpdfstring{$\ast$}{*}area,short image)
\begin{DoxyCompactList}\small\item\em determines whether a point is inside a curve, that has been stretched 1.\+2 times returns the area of the stretched curve \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7}{order\+\_\+curve4}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}curve, long Npoints)
\begin{DoxyCompactList}\small\item\em returns 1 if it is in the curve and 0 if it is out. Borders count as in. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ab9e95a7c17ef4a5d5c4a31fac956140c}\label{namespace_utilities_ab9e95a7c17ef4a5d5c4a31fac956140c} 
unsigned long {\bfseries order\+\_\+curve4} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\begin{DoxyCompactList}\small\item\em Overloads and is dependent on version that takes a point array. Returns number of points that have been ordered. Remaining, unordered points are left at the end of the kist. \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41}{order\+\_\+curve5}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\begin{DoxyCompactList}\small\item\em For odering the curve by the convex hull method. Warning\+: Does not work very well. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a742ad22484d4cfaaefd6317d73a74934}\label{namespace_utilities_a742ad22484d4cfaaefd6317d73a74934} 
void {\bfseries ordered\+\_\+convexhull} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\begin{DoxyCompactList}\small\item\em Replaces curve-\/\texorpdfstring{$>$}{>}imagekist with its convex hull. The number of points will change. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_aa8efda5cf4838d1780ea6e08e155566f}\label{namespace_utilities_aa8efda5cf4838d1780ea6e08e155566f} 
void {\bfseries ordered\+\_\+shrink\+\_\+wrap} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\item 
\Hypertarget{namespace_utilities_ac95a7f052ffe8de55dfdc33d06dc541c}\label{namespace_utilities_ac95a7f052ffe8de55dfdc33d06dc541c} 
void {\bfseries ordered\+\_\+concavehull} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0}{Convex\+Hull\+Area}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}curve)
\begin{DoxyCompactList}\small\item\em Replaces curve with its convex hull. The number of points will change. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a1a6368539a2249ac91796f3ff043e39d}\label{namespace_utilities_a1a6368539a2249ac91796f3ff043e39d} 
{\footnotesize template$<$class T $>$ }\\T {\bfseries to\+\_\+numeric} (const std\+::string \&str)
\begin{DoxyCompactList}\small\item\em convert a string to a numerical value of various types \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a55417d380d1000c91b7a59253cd0b82c}\label{namespace_utilities_a55417d380d1000c91b7a59253cd0b82c} 
template$<$$>$ long {\bfseries to\+\_\+numeric$<$ long $>$} (const std\+::string \&str)
\item 
\Hypertarget{namespace_utilities_a35d114df3356f5498414ff9a481f2173}\label{namespace_utilities_a35d114df3356f5498414ff9a481f2173} 
template$<$$>$ int {\bfseries to\+\_\+numeric$<$ int $>$} (const std\+::string \&str)
\item 
\Hypertarget{namespace_utilities_a0a01d1a182e6b247d4702062aab5a32f}\label{namespace_utilities_a0a01d1a182e6b247d4702062aab5a32f} 
template$<$$>$ float {\bfseries to\+\_\+numeric$<$ float $>$} (const std\+::string \&str)
\item 
\Hypertarget{namespace_utilities_a5b3b8518238ba6cedc16d8012904c70f}\label{namespace_utilities_a5b3b8518238ba6cedc16d8012904c70f} 
template$<$$>$ double {\bfseries to\+\_\+numeric$<$ double $>$} (const std\+::string \&str)
\item 
\Hypertarget{namespace_utilities_a32849c92ee172e983b4223072587ae6d}\label{namespace_utilities_a32849c92ee172e983b4223072587ae6d} 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries Always\+True} (T t)
\item 
\Hypertarget{namespace_utilities_ab47b3f15baa661c5bb9cfd66acea8758}\label{namespace_utilities_ab47b3f15baa661c5bb9cfd66acea8758} 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries Always\+False} (T t)
\item 
\Hypertarget{namespace_utilities_abdf3959325f408179babef5fc09a0a24}\label{namespace_utilities_abdf3959325f408179babef5fc09a0a24} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries vec\+\_\+sum} (const std\+::vector$<$ T $>$ \&v)
\item 
\Hypertarget{namespace_utilities_a5364acb5691c4969be66653956508e6b}\label{namespace_utilities_a5364acb5691c4969be66653956508e6b} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries Matrix} (T \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}matrix, long rows, long cols)
\item 
\Hypertarget{namespace_utilities_acdc7f37bdbbd9f9893af797a98f601aa}\label{namespace_utilities_acdc7f37bdbbd9f9893af797a98f601aa} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries free\+\_\+\+Matrix} (T \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}matrix, long rows, long)
\item 
\Hypertarget{namespace_utilities_aeab156e03bf2f71c3c0de9e267dcb39b}\label{namespace_utilities_aeab156e03bf2f71c3c0de9e267dcb39b} 
Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\bfseries Pos\+Type\+Matrix} (size\+\_\+t rows, size\+\_\+t cols)
\item 
\Hypertarget{namespace_utilities_a9ee12be6dc37bf892ebfbeff4b835084}\label{namespace_utilities_a9ee12be6dc37bf892ebfbeff4b835084} 
void {\bfseries free\+\_\+\+Pos\+Type\+Matrix} (Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}matrix, size\+\_\+t rows, size\+\_\+t cols)
\item 
\Hypertarget{namespace_utilities_aee8540dba0d1bf112290a7389379fefa}\label{namespace_utilities_aee8540dba0d1bf112290a7389379fefa} 
Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} {\bfseries Pos\+Type\+Matrix} (long rows1, long rows2, long cols1, long cols2)
\item 
\Hypertarget{namespace_utilities_aa8f8b847fdd13e67af70275c2df84ef9}\label{namespace_utilities_aa8f8b847fdd13e67af70275c2df84ef9} 
void {\bfseries free\+\_\+\+Pos\+Type\+Matrix} (Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}matrix, long rows1, long rows2, long cols1, long cols2)
\item 
\Hypertarget{namespace_utilities_a355e53765bbce52485685f2cf11632d5}\label{namespace_utilities_a355e53765bbce52485685f2cf11632d5} 
{\footnotesize template$<$class BaseT $>$ }\\std\+::size\+\_\+t {\bfseries lower\+\_\+bound} (std\+::vector$<$ BaseT \texorpdfstring{$\ast$}{*} $>$ \&items, Pos\+Type target)
\item 
\Hypertarget{namespace_utilities_ab5fbd0455bb23cf8290252d8ddef0874}\label{namespace_utilities_ab5fbd0455bb23cf8290252d8ddef0874} 
{\footnotesize template$<$typename Container $>$ }\\void {\bfseries delete\+\_\+container} (Container \&c)
\begin{DoxyCompactList}\small\item\em delete the objects that are pointed to in a container of pointers \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a42da2b93e07ba858edd0d2b9ca7032ec}\label{namespace_utilities_a42da2b93e07ba858edd0d2b9ca7032ec} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries between} (const T \&x, const T \&l, const T \&u)
\item 
{\footnotesize template$<$typename T , typename R $>$ }\\void \mbox{\hyperlink{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c}{shuffle}} (std\+::vector$<$ T $>$ \&vec, R \&ran)
\begin{DoxyCompactList}\small\item\em Shuffles a vector into a random order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a9b44ff17b26b627e429e9984d4908577}{sort\+\_\+indexes}} (const std\+::vector$<$ T $>$ \&v, std\+::vector$<$ size\+\_\+t $>$ \&index)
\begin{DoxyCompactList}\small\item\em Find the indexes that sort a vector in asending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a357b69312972120ce046eff265e6b581}{sort\+\_\+indexes}} (const T \texorpdfstring{$\ast$}{*}v, std\+::vector$<$ size\+\_\+t $>$ \&index, size\+\_\+t N)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe}{sort\+\_\+indexes\+\_\+decending}} (const std\+::vector$<$ T $>$ \&v, std\+::vector$<$ size\+\_\+t $>$ \&index)
\begin{DoxyCompactList}\small\item\em Find the indexes that sort a vector in descending order. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_abd8109e832d4f887939cbaef421a101d}\label{namespace_utilities_abd8109e832d4f887939cbaef421a101d} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries apply\+\_\+permutation} (T \texorpdfstring{$\ast$}{*}vec, const std\+::vector$<$ std\+::size\+\_\+t $>$ \&p)
\item 
\Hypertarget{namespace_utilities_a173a48bc6f7d6968101fca85c6998043}\label{namespace_utilities_a173a48bc6f7d6968101fca85c6998043} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries apply\+\_\+permutation} (std\+::vector$<$ T $>$ \&vec, const std\+::vector$<$ std\+::size\+\_\+t $>$ \&p)
\item 
void \mbox{\hyperlink{namespace_utilities_a586082194e51dc17b62453f79b012310}{powerspectrum2d}} (std\+::valarray$<$ double $>$ const \&aa, std\+::valarray$<$ double $>$ const \&bb, long nx, long ny, double boxlx, double boxly, std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl, double zeropaddingfactor)
\begin{DoxyCompactList}\small\item\em Calculates power spectrum from a 2d map or the cross-\/power spectrum between two 2d maps. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_a1da3b0a449dad814f7c6c804fc323a4d}{powerspectrum2d}} (std\+::valarray$<$ double $>$ \&aa, long nx, long ny, double boxlx, double boxly, std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl)
\item 
void \mbox{\hyperlink{namespace_utilities_adbf9204e09d3023ddd66cf4a3d440181}{powerspectrum2dprebin}} (std\+::valarray$<$ double $>$ \&aa, long nx, long ny, double boxlx, double boxly, const std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl, std\+::vector$<$ double $>$ \&llave)
\item 
void \mbox{\hyperlink{namespace_utilities_aae84841923bdfd928af1928c94464313}{powerspectrum2d}} (std\+::valarray$<$ float $>$ const \&aa, std\+::valarray$<$ float $>$ const \&bb, long nx, long ny, double boxlx, double boxly, std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl, double zeropaddingfactor)
\item 
void \mbox{\hyperlink{namespace_utilities_a8ee3342e8438958ee6d2befb1d239f7c}{powerspectrum2d}} (std\+::valarray$<$ float $>$ \&aa, long nx, long ny, double boxlx, double boxly, std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl)
\item 
void \mbox{\hyperlink{namespace_utilities_a604490c5c8fae106fff74568d9706f93}{powerspectrum2dprebin}} (std\+::valarray$<$ float $>$ \&aa, int nx, int ny, double boxlx, double boxly, const std\+::vector$<$ double $>$ \&ll, std\+::vector$<$ double $>$ \&Pl, std\+::vector$<$ double $>$ \&llave)
\item 
\Hypertarget{namespace_utilities_afa654746e24cd77549f412bed8d3ee26}\label{namespace_utilities_afa654746e24cd77549f412bed8d3ee26} 
int {\bfseries Get\+NThreads} ()
\begin{DoxyCompactList}\small\item\em returns the compiler variable N\+\_\+\+THREADS that is maximum number of threads to be used. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_acede0e6fa297e5d2f12c89724110bc25}\label{namespace_utilities_acede0e6fa297e5d2f12c89724110bc25} 
void {\bfseries splitstring} (std\+::string \&line, std\+::vector$<$ std\+::string $>$ \&vec, const std\+::string \&delimiter)
\begin{DoxyCompactList}\small\item\em split string into vector of seporate strings that were seporated by \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a9bcb1b508d1a083903f7efe1cef059c6}\label{namespace_utilities_a9bcb1b508d1a083903f7efe1cef059c6} 
{\footnotesize template$<$typename T $>$ }\\double {\bfseries Klein\+Sum} (std\+::vector$<$ T $>$ \&input)
\item 
\Hypertarget{namespace_utilities_a9cc851578407384fcfddcecd75d32c0e}\label{namespace_utilities_a9cc851578407384fcfddcecd75d32c0e} 
{\footnotesize template$<$typename T , typename F $>$ }\\double {\bfseries Pair\+Wise\+Sum} (T \texorpdfstring{$\ast$}{*}begin, T \texorpdfstring{$\ast$}{*}end, F value)
\item 
\Hypertarget{namespace_utilities_af24b7bf4d27bbe77e4b9f68e879015d4}\label{namespace_utilities_af24b7bf4d27bbe77e4b9f68e879015d4} 
{\footnotesize template$<$typename T $>$ }\\double {\bfseries Pair\+Wise\+Sum} (T \texorpdfstring{$\ast$}{*}begin, T \texorpdfstring{$\ast$}{*}end)
\begin{DoxyCompactList}\small\item\em Does a parwise sumation of a vector which incresses the precision of the sumation to \texorpdfstring{$\sim$}{\string~}\+O(epsilon log(n) ) \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_abb73b4921a044eff1a54293379118c2f}\label{namespace_utilities_abb73b4921a044eff1a54293379118c2f} 
{\footnotesize template$<$typename T $>$ }\\double {\bfseries Pair\+Wise\+Sum} (std\+::vector$<$ T $>$ \&v)
\begin{DoxyCompactList}\small\item\em Does a parwise sumation of a vector which incresses the precision of the sumation to \texorpdfstring{$\sim$}{\string~}\+O(epsilon log(n) ) \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_afb47bcadb1b1b4c2662f37d26e84cf0e}\label{namespace_utilities_afb47bcadb1b1b4c2662f37d26e84cf0e} 
{\footnotesize template$<$typename T , typename F $>$ }\\double {\bfseries Pair\+Wise\+Sum} (std\+::vector$<$ T $>$ \&v, F value)
\begin{DoxyCompactList}\small\item\em This version allows you to specify a function( value(\+T \texorpdfstring{$\ast$}{*} p) ), that returns the value of a pointer to a T type that is to be summed. This is useful for summing the squares or summing some a particular variable within a list of objects. A lambda function is particularly useful here. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a775bfd83e477acd7cb1ab132c4e7f9ad}\label{namespace_utilities_a775bfd83e477acd7cb1ab132c4e7f9ad} 
{\footnotesize template$<$typename T  = double$>$ }\\double {\bfseries hypergeometric} (T a, T b, T c, T x)
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::valarray$<$ T $>$ \mbox{\hyperlink{namespace_utilities_a3735cfea92026435e078b653adb29782}{Adaptive\+Smooth}} (const std\+::valarray$<$ T $>$ \&map\+\_\+in, size\+\_\+t Nx, size\+\_\+t Ny, T value)
\begin{DoxyCompactList}\small\item\em Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_ae358b58a950d75ef089c7ad73f37a080}\label{namespace_utilities_ae358b58a950d75ef089c7ad73f37a080} 
bool {\bfseries xorderD} (double \texorpdfstring{$\ast$}{*}p1, double \texorpdfstring{$\ast$}{*}p2)
\item 
\Hypertarget{namespace_utilities_a5baa3e10d9b962622365a0916fb0fa01}\label{namespace_utilities_a5baa3e10d9b962622365a0916fb0fa01} 
bool {\bfseries yorderD} (double \texorpdfstring{$\ast$}{*}p1, double \texorpdfstring{$\ast$}{*}p2)
\item 
\Hypertarget{namespace_utilities_af495d1ed407458779abf8694a2e4cda2}\label{namespace_utilities_af495d1ed407458779abf8694a2e4cda2} 
long {\bfseries Index\+From\+Position} (Pos\+Type \texorpdfstring{$\ast$}{*}x, long Nx, long Ny, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, const Pos\+Type \texorpdfstring{$\ast$}{*}center)
\begin{DoxyCompactList}\small\item\em this is the nonsquare version of the function, it will return -\/1 is outside of region \end{DoxyCompactList}\item 
\Hypertarget{namespace_utilities_a043901fd09c24707f46eb23b75548882}\label{namespace_utilities_a043901fd09c24707f46eb23b75548882} 
void {\bfseries Position\+From\+Index} (unsigned long i, Pos\+Type \texorpdfstring{$\ast$}{*}x, long Nx, long Ny, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type const \texorpdfstring{$\ast$}{*}center)
\begin{DoxyCompactList}\small\item\em This should work for square or rectangular regions as long as Npixels and range are the x-\/axis values and the pixels are square. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespace_utilities_aa9581800c9d5adc2444440dac76de955}\label{namespace_utilities_aa9581800c9d5adc2444440dac76de955} 
const double {\bfseries n\+Xbin} =64.
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}

\begin{DoxyItemize}
\item 
\end{DoxyItemize}

The \doxylink{namespace_utilities}{Utilities} namespace contains functions for wide use in many classes that perform generic tasks.

structure to construct, hold and destruct image and source points


\begin{DoxyItemize}
\item \textbackslash{}ing\+Einstein\+\_\+roup Change\+Lens
\item \textbackslash{}ing\+Einstein\+\_\+roup Change\+Lens
\item orders points in a curve, separates disconnected curves curves\mbox{[}0...Maxcurves\mbox{]} must be allocated before
\end{DoxyItemize}

uses neighbors-\/of-\/neighbors to split into curves and then uses sorts by angle and then walks the ist sorting

can break down for crescent curves

The two functions below are inverses of each other for converting between a 1d array index and a square grid of positions Npixels in the number of point is 1 dimension index is between 0 and Npixels\texorpdfstring{$\ast$}{*}\+Npixels-\/1 If x is outside of the region -\/1 is returned. 

\doxysubsection{Function Documentation}
\Hypertarget{namespace_utilities_a3735cfea92026435e078b653adb29782}\index{Utilities@{Utilities}!AdaptiveSmooth@{AdaptiveSmooth}}
\index{AdaptiveSmooth@{AdaptiveSmooth}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{AdaptiveSmooth()}{AdaptiveSmooth()}}
{\footnotesize\ttfamily \label{namespace_utilities_a3735cfea92026435e078b653adb29782} 
template$<$typename T $>$ \\
std\+::valarray$<$ T $>$ Utilities\+::\+Adaptive\+Smooth (\begin{DoxyParamCaption}\item[{const std\+::valarray$<$ T $>$ \&}]{map\+\_\+in}{, }\item[{size\+\_\+t}]{Nx}{, }\item[{size\+\_\+t}]{Ny}{, }\item[{T}]{value}{}\end{DoxyParamCaption})}



Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. 

The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)\texorpdfstring{$\ast$}{*}(number of neighbours) an approximate N nearest neighbour smoothing is done. \Hypertarget{namespace_utilities_a6d17c2495bead70b18b91c376c28c051}\index{Utilities@{Utilities}!concave@{concave}}
\index{concave@{concave}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave()}{concave()}}
{\footnotesize\ttfamily \label{namespace_utilities_a6d17c2495bead70b18b91c376c28c051} 
template$<$typename T $>$ \\
void Utilities\+::concave (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{init\+\_\+points}{, }\item[{std\+::vector$<$ T $>$ \&}]{hull\+\_\+out}{, }\item[{double}]{scale}{}\end{DoxyParamCaption})}



Creates the concave hull of a group of 2 dimensional points by the shrink-\/wrap algorithm. 

The type of the input vector points must have an operator \mbox{[}\mbox{]}. If the input vector is the same as the output vector it will be replaced, and the function will still work.

It is guaranteed that the resulting hull will surround the all the points. Any edge that is greater than scale will be refined until it is either smaller than scale or it cannot be refined further. As a result some edges might be larger than scale and some smaller.

This should be a NlogN algorithm.

The algorithm\+: 1) The convex hull is found. 2) The longest edge is found 3) all the points that are not in the hull are tested to see if they are within the rays extending from the end point perpendicular to the edge. 4) Of the points that are the one that makes the smallest area triangle with the end points is chosen and added 5) go back to 3 if there are edges that are larger than scale and new points exist to be added 6) remove all intersections in the hull \Hypertarget{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4}\index{Utilities@{Utilities}!concave\_hull@{concave\_hull}}
\index{concave\_hull@{concave\_hull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave\_hull()}{concave\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4} 
std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ Utilities\+::concave\+\_\+hull (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double \texorpdfstring{$\ast$}{*} $>$ \&}]{P}{, }\item[{int}]{k}{}\end{DoxyParamCaption})}



Returns a vector of points on the convcave hull in counter-\/clockwise order. 

This uses a K-\/nearest neighbour adapted from Moreira \& Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered.

This is an overloaded version of the other \doxylink{namespace_utilities_aca82634714ad53172788a38cef165b07}{concave\+\_\+hull()} \Hypertarget{namespace_utilities_aca82634714ad53172788a38cef165b07}\index{Utilities@{Utilities}!concave\_hull@{concave\_hull}}
\index{concave\_hull@{concave\_hull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave\_hull()}{concave\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_aca82634714ad53172788a38cef165b07} 
std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ Utilities\+::concave\+\_\+hull (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&}]{P}{, }\item[{int}]{k}{, }\item[{bool}]{test}{ = {\ttfamily false}}\end{DoxyParamCaption})}



Returns a vector of points on the convcave hull in counter-\/clockwise order. 

This uses a K-\/nearest neighbour adapted from Moreira \& Santos (GRAPP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered. \Hypertarget{namespace_utilities_abe345295eb171c0665350842426124bd}\index{Utilities@{Utilities}!concaveK@{concaveK}}
\index{concaveK@{concaveK}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concaveK()}{concaveK()}}
{\footnotesize\ttfamily \label{namespace_utilities_abe345295eb171c0665350842426124bd} 
template$<$typename Ptype $>$ \\
std\+::vector$<$ Ptype $>$ Utilities\+::concaveK (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Ptype $>$ \&}]{points}{, }\item[{int \&}]{k}{, }\item[{bool}]{check}{ = {\ttfamily true}}\end{DoxyParamCaption})}

will be added back later\Hypertarget{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}\index{Utilities@{Utilities}!contour\_center@{contour\_center}}
\index{contour\_center@{contour\_center}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{contour\_center()}{contour\_center()}}
{\footnotesize\ttfamily \label{namespace_utilities_a512d73667d76a5a58e44042a4a73c974} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} Utilities\+::contour\+\_\+center (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{P}{, }\item[{unsigned long}]{Npoints}{}\end{DoxyParamCaption})}



Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. 

The performance of the algorithm is \texorpdfstring{$\sim$}{\string~}\+O(\+N\texorpdfstring{$^\wedge$}{\string^}2). Less naive methods go like O(\+N) at best. Most commonly a combined convex hull plus rotating calipers algorithm is used. Since we have the convex\+\_\+hull already, we only need to implement the latter algorithm. \Hypertarget{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d}\index{Utilities@{Utilities}!contour\_ellipse@{contour\_ellipse}}
\index{contour\_ellipse@{contour\_ellipse}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{contour\_ellipse()}{contour\_ellipse()}}
{\footnotesize\ttfamily \label{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d} 
void Utilities\+::contour\+\_\+ellipse (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{P}{, }\item[{\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}}}]{center}{, }\item[{unsigned long}]{Npoints}{, }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{C}{, }\item[{double \texorpdfstring{$\ast$}{*}}]{ellipticity}{, }\item[{double \texorpdfstring{$\ast$}{*}}]{ellipse\+\_\+area}{}\end{DoxyParamCaption})}



Returns axis ratio, area and points of an ellipse engulfed by some contour (e.\+g. a contour of same convergence calculated with find\+\_\+contour). 

The axis ratio of the ellipse b/a is equal to the ratio of the distances between center and the nearest contour point (i.\+e. b) and between center and the farthest contour point (i.\+e. a). NOTE that the center used to calculate a and b is an input parameter. The definition of the center is crucial to the meaning of above output parameters. The center of the convex\+\_\+hull produces for even slightly distorted hulls significant offsets resulting in overestimated major axis values (a). The function \doxylink{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}{Utilities\+::contour\+\_\+center()} calculates the center as the midpoint between the two points in the contour that are farthest apart from one another, which gives already more reliable results. The output vector describing the ellipse is resized to match the size of the contour vector. \Hypertarget{namespace_utilities_a181252f6287df861af9107445a4cac7f}\index{Utilities@{Utilities}!convex\_hull@{convex\_hull}}
\index{convex\_hull@{convex\_hull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{convex\_hull()}{convex\_hull()}}
{\footnotesize\ttfamily \label{namespace_utilities_a181252f6287df861af9107445a4cac7f} 
template$<$typename T $>$ \\
void Utilities\+::convex\+\_\+hull (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{P}{, }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{hull}{}\end{DoxyParamCaption})}

Returns a vector of points on the convex hull in counter-\/clockwise order. \Hypertarget{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0}\index{Utilities@{Utilities}!ConvexHullArea@{ConvexHullArea}}
\index{ConvexHullArea@{ConvexHullArea}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{ConvexHullArea()}{ConvexHullArea()}}
{\footnotesize\ttfamily \label{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0} 
Pos\+Type Utilities\+::\+Convex\+Hull\+Area (\begin{DoxyParamCaption}\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{curve}{}\end{DoxyParamCaption})}



Replaces curve with its convex hull. The number of points will change. 

gives the area within the convex hull of the curve \Hypertarget{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2}\index{Utilities@{Utilities}!double\_sort\_points@{double\_sort\_points}}
\index{double\_sort\_points@{double\_sort\_points}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{double\_sort\_points()}{double\_sort\_points()}}
{\footnotesize\ttfamily \label{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2} 
void Utilities\+::double\+\_\+sort\+\_\+points (\begin{DoxyParamCaption}\item[{unsigned long}]{n}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{arr}{, }\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{brr}{}\end{DoxyParamCaption})}



Sorts points in a point array. 

arr array uses NR standard indexing i.\+e arr\mbox{[}1...n\mbox{]} but brr\mbox{[}0..n-\/1\mbox{]} if the point array is two-\/way-\/coupled to another point array the image pointers of that array will follow sort if the array is not two-\/way-\/coupled to another the image pointers in the other array will be untouched \Hypertarget{namespace_utilities_a6b3b3327085b03c3dcbb1afadd59fcd4}\index{Utilities@{Utilities}!envelope@{envelope}}
\index{envelope@{envelope}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{envelope()}{envelope()}}
{\footnotesize\ttfamily \label{namespace_utilities_a6b3b3327085b03c3dcbb1afadd59fcd4} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ Utilities\+::envelope (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{v}{, }\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{w}{}\end{DoxyParamCaption})}



Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. 

v and w can be non-\/self intersecting If they do not intersect and one is not inside the other an empty vector is returned.

Unlike {\ttfamily \doxylink{namespace_utilities_a6b3b3327085b03c3dcbb1afadd59fcd4}{Utilities\+::envelope()}}, this algorithm is pretty foolproof. It uses the same concept as {\ttfamily \doxylink{namespace_utilities_ac6c2b9ec5013e30e7b10d2ba8279e91e}{Utilities\+::\+Tightest\+Hull()}}. There may be small segements that are not in either curve, but they should increase the area be a small fraction. \Hypertarget{namespace_utilities_a8baf3c89ecca31f0771e2d781a856f20}\index{Utilities@{Utilities}!envelope2@{envelope2}}
\index{envelope2@{envelope2}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{envelope2()}{envelope2()}}
{\footnotesize\ttfamily \label{namespace_utilities_a8baf3c89ecca31f0771e2d781a856f20} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ Utilities\+::envelope2 (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{v}{, }\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{w}{}\end{DoxyParamCaption})}



Find a curve that is made up of segments from v and w that surrounds them and does not self intersect. 

v and w must be non-\/self intersecting If they do not intersect and one is not inside the other an empty vector is returned \Hypertarget{namespace_utilities_a380f0a954728d751781e61918facba0e}\index{Utilities@{Utilities}!fill\_linear@{fill\_linear}}
\index{fill\_linear@{fill\_linear}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{fill\_linear()}{fill\_linear()}}
{\footnotesize\ttfamily \label{namespace_utilities_a380f0a954728d751781e61918facba0e} 
template$<$class T $>$ \\
void Utilities\+::fill\+\_\+linear (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v}{, }\item[{size\+\_\+t}]{n}{, }\item[{T}]{min}{, }\item[{T}]{max}{}\end{DoxyParamCaption})}

Fills a vector with equidistant points from \mbox{[}min, max\mbox{]}. \Hypertarget{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a}\index{Utilities@{Utilities}!fill\_logarithmic@{fill\_logarithmic}}
\index{fill\_logarithmic@{fill\_logarithmic}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{fill\_logarithmic()}{fill\_logarithmic()}}
{\footnotesize\ttfamily \label{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a} 
template$<$class T $>$ \\
void Utilities\+::fill\+\_\+logarithmic (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v}{, }\item[{size\+\_\+t}]{n}{, }\item[{T}]{min}{, }\item[{T}]{max}{}\end{DoxyParamCaption})}

Fills a vector with logarithmically equidistant points from \mbox{[}min, max\mbox{]}. \Hypertarget{namespace_utilities_a3ded74005933c13892203f9ad15cdbb0}\index{Utilities@{Utilities}!find\_boundaries@{find\_boundaries}}
\index{find\_boundaries@{find\_boundaries}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{find\_boundaries()}{find\_boundaries()}}
{\footnotesize\ttfamily \label{namespace_utilities_a3ded74005933c13892203f9ad15cdbb0} 
template$<$typename P $>$ \\
void Utilities\+::find\+\_\+boundaries (\begin{DoxyParamCaption}\item[{std\+::vector$<$ bool $>$ \&}]{bitmap}{, }\item[{long}]{nx}{, }\item[{std\+::vector$<$ std\+::vector$<$ P $>$ $>$ \&}]{points}{, }\item[{std\+::vector$<$ bool $>$ \&}]{hits\+\_\+edge}{, }\item[{bool}]{add\+\_\+to\+\_\+vector}{ = {\ttfamily false}, }\item[{bool}]{outer\+\_\+only}{ = {\ttfamily false}}\end{DoxyParamCaption})}



finds ordered boundaries to regions where bitmap == true 

This can be used to find critical curves or contours. If the boundary curve touches the edge of the {\ttfamily bitmap} it will be indicated in {\ttfamily hits\+\_\+boundary} as {\ttfamily true}.

Boundaries will never cross or lead off the grid. ~\newline
 On the edges they will leave the edge pixels out even if they should be in. This is a technical compromise.

Output points are in pixel units with (0,0) being point (0,0) 
\begin{DoxyParams}{Parameters}
{\em outer\+\_\+only} & finds only the fist boundary which will be the outer one if there are not seporated islands \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e}\index{Utilities@{Utilities}!InterpolateYvec@{InterpolateYvec}}
\index{InterpolateYvec@{InterpolateYvec}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{InterpolateYvec()}{InterpolateYvec()}}
{\footnotesize\ttfamily \label{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e} 
Pos\+Type Utilities\+::\+Interpolate\+Yvec (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{x}{, }\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{y}{, }\item[{Pos\+Type}]{xi}{}\end{DoxyParamCaption})}

Interpolate (cubic interpolation) the value of a function $ y=y(x) $ given xi \Hypertarget{namespace_utilities_acc053736fab41bd2807991e8dfcab129}\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily \label{namespace_utilities_acc053736fab41bd2807991e8dfcab129} 
template$<$typename T $>$ \\
size\+\_\+t Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v}{, }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{sorted\+\_\+index}{, }\item[{T}]{value}{, }\item[{size\+\_\+t \&}]{rank}{}\end{DoxyParamCaption})}



Finds the element of a vector given a sorted index of the vector. 

The vector v does not need to be sorted, but the index does with Utiltites\+::sort\+\_\+index(), Utilities\+::sort\+\_\+index\+\_\+decending() or in some other way.

returns the index of v that is the largest value that is \texorpdfstring{$<$}{<}= value 
\begin{DoxyParams}{Parameters}
{\em v} & vector to search, does not need to be sorted  \\
\hline
{\em sorted\+\_\+index} & sorted index for v, could be assending or decending  \\
\hline
{\em value} & value to be matched  \\
\hline
{\em rank} & index in sorted\+\_\+index \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e}\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily \label{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e} 
template$<$class T $>$ \\
long Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v}{, }\item[{const T}]{x}{}\end{DoxyParamCaption})}

Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -\/1 or n-\/1. \Hypertarget{namespace_utilities_ab7663a1f094849a77cab564e61fcca49}\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily \label{namespace_utilities_ab7663a1f094849a77cab564e61fcca49} 
template$<$class T , class F $>$ \\
long Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v}{, }\item[{F}]{x}{, }\item[{std\+::function$<$ bool(F, const T \&)$>$}]{less\+\_\+than}{}\end{DoxyParamCaption})}

Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -\/1 or n-\/1. \Hypertarget{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98}\index{Utilities@{Utilities}!nintegrateF@{nintegrateF}}
\index{nintegrateF@{nintegrateF}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{nintegrateF()}{nintegrateF()}}
{\footnotesize\ttfamily \label{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98} 
template$<$typename Functor\+Type , typename T  = double$>$ \\
T Utilities\+::nintegrateF (\begin{DoxyParamCaption}\item[{Functor\+Type}]{func}{, }\item[{T}]{a}{, }\item[{T}]{b}{, }\item[{T}]{tols}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em func} & struct or class to be integrated  \\
\hline
{\em a} & limit of integrations  \\
\hline
{\em b} & limit of integrations  \\
\hline
{\em tols} & target fractional error \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7}\index{Utilities@{Utilities}!order\_curve4@{order\_curve4}}
\index{order\_curve4@{order\_curve4}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{order\_curve4()}{order\_curve4()}}
{\footnotesize\ttfamily \label{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7} 
unsigned long Utilities\+::order\+\_\+curve4 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{curve}{, }\item[{long}]{Npoints}{}\end{DoxyParamCaption})}



returns 1 if it is in the curve and 0 if it is out. Borders count as in. 

Orders points on a closed curve.

returns 1 if it is in the curve and 0 if it is out. Borders count as in. returns 1 if it is in the curve and 0 if it is out. Borders count as in.

The algorithm first finds the "{}center"{} of the curve. It then does a rough ordering according to the angle around this center. It then walks the curve jumping to a neighbor cell each step choosing a neighbor along one of the x or y-\/axis before taking a diagonal step. If it comes to the point where there is no more neighbors (as may occur after going through a self-\/intersection and then returning to it) the algorithm backtracks until it finds a point in the ordered list that is also a neighbor to a point in the not yet ordered list and attaches this to the end of the ordered list and continuous to walk. This algorithm works well at finding a closed loop. It can cut off points from the curve that are either in loops or if four cells intersect and are all on the curve as can happen when there is a lot of structure in the curve that is not resolved at the gridsize used. The points that are cut off are at the end of the array in no guaranteed order.

Returns the number of point that have been ordered -\/ total number minus the cuttout points.

This algorithm could be improve by inserting the remaining points, if any, into the existing curve and recursively calling itself. \Hypertarget{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41}\index{Utilities@{Utilities}!order\_curve5@{order\_curve5}}
\index{order\_curve5@{order\_curve5}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{order\_curve5()}{order\_curve5()}}
{\footnotesize\ttfamily \label{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41} 
unsigned long Utilities\+::order\+\_\+curve5 (\begin{DoxyParamCaption}\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{curve}{}\end{DoxyParamCaption})}



For odering the curve by the convex hull method. Warning\+: Does not work very well. 

The convex hull is found for the points in the kist. Then each additional point is inserted into the curve where it will increase the length of the curve the least. This method leaves loops where they shouldn\textquotesingle{}t be and probably doesn\textquotesingle{}t handle self-\/intersections well. \Hypertarget{namespace_utilities_a1da3b0a449dad814f7c6c804fc323a4d}\index{Utilities@{Utilities}!powerspectrum2d@{powerspectrum2d}}
\index{powerspectrum2d@{powerspectrum2d}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2d()}{powerspectrum2d()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily \label{namespace_utilities_a1da3b0a449dad814f7c6c804fc323a4d} 
void Utilities\+::powerspectrum2d (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ double $>$ \&}]{aa}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a586082194e51dc17b62453f79b012310}\index{Utilities@{Utilities}!powerspectrum2d@{powerspectrum2d}}
\index{powerspectrum2d@{powerspectrum2d}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2d()}{powerspectrum2d()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily \label{namespace_utilities_a586082194e51dc17b62453f79b012310} 
void Utilities\+::powerspectrum2d (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ double $>$ const \&}]{aa}{, }\item[{std\+::valarray$<$ double $>$ const \&}]{bb}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{, }\item[{double}]{zeropaddingfactor}{}\end{DoxyParamCaption})}



Calculates power spectrum from a 2d map or the cross-\/power spectrum between two 2d maps. 

Adapted from Carlo Giocoli\textquotesingle{}s pl() routine. 
\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em bb} & second realspace map, same as aa to get power spectrum  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a8ee3342e8438958ee6d2befb1d239f7c}\index{Utilities@{Utilities}!powerspectrum2d@{powerspectrum2d}}
\index{powerspectrum2d@{powerspectrum2d}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2d()}{powerspectrum2d()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily \label{namespace_utilities_a8ee3342e8438958ee6d2befb1d239f7c} 
void Utilities\+::powerspectrum2d (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ float $>$ \&}]{aa}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_aae84841923bdfd928af1928c94464313}\index{Utilities@{Utilities}!powerspectrum2d@{powerspectrum2d}}
\index{powerspectrum2d@{powerspectrum2d}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2d()}{powerspectrum2d()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily \label{namespace_utilities_aae84841923bdfd928af1928c94464313} 
void Utilities\+::powerspectrum2d (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ float $>$ const \&}]{aa}{, }\item[{std\+::valarray$<$ float $>$ const \&}]{bb}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{, }\item[{double}]{zeropaddingfactor}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em bb} & second realspace map, same as aa to get power spectrum  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_adbf9204e09d3023ddd66cf4a3d440181}\index{Utilities@{Utilities}!powerspectrum2dprebin@{powerspectrum2dprebin}}
\index{powerspectrum2dprebin@{powerspectrum2dprebin}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2dprebin()}{powerspectrum2dprebin()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_adbf9204e09d3023ddd66cf4a3d440181} 
void Utilities\+::powerspectrum2dprebin (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ double $>$ \&}]{aa}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{const std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{, }\item[{std\+::vector$<$ double $>$ \&}]{llave}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum  \\
\hline
{\em llave} & average value of Fourier node in bins \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a604490c5c8fae106fff74568d9706f93}\index{Utilities@{Utilities}!powerspectrum2dprebin@{powerspectrum2dprebin}}
\index{powerspectrum2dprebin@{powerspectrum2dprebin}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{powerspectrum2dprebin()}{powerspectrum2dprebin()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_a604490c5c8fae106fff74568d9706f93} 
void Utilities\+::powerspectrum2dprebin (\begin{DoxyParamCaption}\item[{std\+::valarray$<$ float $>$ \&}]{aa}{, }\item[{int}]{nx}{, }\item[{int}]{ny}{, }\item[{double}]{boxlx}{, }\item[{double}]{boxly}{, }\item[{const std\+::vector$<$ double $>$ \&}]{ll}{, }\item[{std\+::vector$<$ double $>$ \&}]{Pl}{, }\item[{std\+::vector$<$ double $>$ \&}]{llave}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em aa} & first realspace map to be  \\
\hline
{\em nx} & number of pixels in x direction  \\
\hline
{\em ny} & number of pixels in y direction  \\
\hline
{\em boxlx} & range of image in x direction  \\
\hline
{\em boxly} & range of image in y direction  \\
\hline
{\em ll} & output multiplot number of bins  \\
\hline
{\em Pl} & output binned power spectrum  \\
\hline
{\em llave} & average value of Fourier node in bins \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_abe61342a713adf7115f351e3342a2b79}\index{Utilities@{Utilities}!prevpower@{prevpower}}
\index{prevpower@{prevpower}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{prevpower()}{prevpower()}}
{\footnotesize\ttfamily \label{namespace_utilities_abe61342a713adf7115f351e3342a2b79} 
unsigned long Utilities\+::prevpower (\begin{DoxyParamCaption}\item[{unsigned long}]{k}{}\end{DoxyParamCaption})}

This function finds the largest power of 2 that is \texorpdfstring{$<$}{<} k \Hypertarget{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a}\index{Utilities@{Utilities}!quicksortPoints\_multithread@{quicksortPoints\_multithread}}
\index{quicksortPoints\_multithread@{quicksortPoints\_multithread}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{quicksortPoints\_multithread()}{quicksortPoints\_multithread()}}
{\footnotesize\ttfamily \label{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a} 
template$<$int lev$>$ \\
void Utilities\+::quicksort\+Points\+\_\+multithread (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{pointarray}{, }\item[{double(\texorpdfstring{$\ast$}{*}}]{func~}{)(\mbox{\hyperlink{struct_point}{Point}} \&), }\item[{unsigned long}]{N}{, }\item[{int}]{level}{ = {\ttfamily 0}}\end{DoxyParamCaption})}



Multi-\/threaded quicksort. The maximum number of threads used is 2\texorpdfstring{$^\wedge$}{\string^}lev. The function {\ttfamily func} takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. 

This function is different from \doxylink{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}{quicksort\+\_\+multithread()} in that it uses Swap\+Points\+In\+Array() instead of std\+::swap() which is needed to make the image pointers follow the swap. \Hypertarget{namespace_utilities_a0855636bdb71f103a4412555b9711e98}\index{Utilities@{Utilities}!RandomFromTable@{RandomFromTable}}
\index{RandomFromTable@{RandomFromTable}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{RandomFromTable()}{RandomFromTable()}}
{\footnotesize\ttfamily \label{namespace_utilities_a0855636bdb71f103a4412555b9711e98} 
Pos\+Type Utilities\+::\+Random\+From\+Table (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{table}{, }\item[{unsigned long}]{Ntable}{, }\item[{long \texorpdfstring{$\ast$}{*}}]{seed}{}\end{DoxyParamCaption})}



Generates a random deviates drawn f\+Einstein\+\_\+rom app\+Einstein\+\_\+roximately the same as the values of table. 

\textbackslash{}ing\+Einstein\+\_\+roup Utill  \Hypertarget{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2}\index{Utilities@{Utilities}!ReadFileNames@{ReadFileNames}}
\index{ReadFileNames@{ReadFileNames}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{ReadFileNames()}{ReadFileNames()}}
{\footnotesize\ttfamily \label{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2} 
void Utilities\+::\+Read\+File\+Names (\begin{DoxyParamCaption}\item[{std\+::string}]{dir}{, }\item[{const std\+::string}]{filespec}{, }\item[{std\+::vector$<$ std\+::string $>$ \&}]{filenames}{, }\item[{const std\+::string}]{file\+\_\+non\+\_\+spec}{ = {\ttfamily "{}~"{}}, }\item[{bool}]{verbose}{ = {\ttfamily false}}\end{DoxyParamCaption})}



Reads all the fits files in a directory into a vector of Pixel\+Maps. 

The input fits files must have .fits in their names in addition to the string filespec.

void Utilities\+::\+Load\+Fits\+Images( std\+::string dir /// path to directory containing fits files ,const std\+::string\& filespec /// string of charactors in fits file name that are matched ,std\+::vector$<$\+Pixel\+Map$>$ \& images /// output vector of Pixel\+Maps ,int maxN /// maximum number of images that will be read in ,double resolution /// resolution (rad) of fits image if not given in fits file, use default or -\/1 otherwise ,bool verbose /// lists files to stdout )\{

DIR \texorpdfstring{$\ast$}{*}dp = opendir( dir.\+c\+\_\+str() ); struct dirent \texorpdfstring{$\ast$}{*}dirp; struct stat filestat; std\+::string filepath,filename; size\+\_\+t count = 0;

if (dp == NULL) \{ throw std\+::runtime\+\_\+error("{}error opening directory"{}); return; \}

while ((dirp = readdir( dp )) \&\& count \texorpdfstring{$<$}{<} maxN) \{ filepath = dir + "{}/"{} + dirp-\/\texorpdfstring{$>$}{>}d\+\_\+name;

If the file is a directory (or is in some way invalid) we\textquotesingle{}ll skip it if (stat( filepath.\+c\+\_\+str(), \&filestat )) continue; if (S\+\_\+\+ISDIR( filestat.\+st\+\_\+mode )) continue;

filename = dirp-\/\texorpdfstring{$>$}{>}d\+\_\+name; if(filename.\+find("{}.\+fits"{}) != std\+::string\+::npos)\{ if(filename.\+find(filespec) != std\+::string\+::npos)\{ if(verbose) std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} "{}reading "{} \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} filepath \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} std\+::endl; \doxylink{class_pixel_map}{Pixel\+Map} map(filepath,resolution); images.\+push\+\_\+back(std\+::move(map)); images.\+push\+\_\+back(\+Pixel\+Map(filepath,resolution)); ++count; \} \} \}

closedir( dp );

std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} count \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} "{} fits files read."{} \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} std\+::endl; return ; \}

Reads all the fits files in a directory into a vector of Pixel\+Maps.

The input fits files must have .fits in their names in addition to the string filespec.

void Utilities\+::\+Load\+Fits\+Images( std\+::string dir /// path to directory containing fits files ,std\+::vector$<$std\+::string$>$ filespecs /// string of charactors in fits file name that are matched ,std\+::vector$<$std\+::string$>$ file\+\_\+non\+\_\+specs /// string of charactors in fits file name cannot have ,std\+::vector$<$\+Pixel\+Map$>$ \& images /// output vector of Pixel\+Maps ,std\+::vector$<$std\+::string$>$ \& names /// file names ,int maxN /// maximum number of images that will be read in ,double resolution /// resolution (rad) of fits image if not given in fits file, use default or -\/1 otherwise ,bool verbose /// lists files to stdout )\{

DIR \texorpdfstring{$\ast$}{*}dp = opendir( dir.\+c\+\_\+str() ); struct dirent \texorpdfstring{$\ast$}{*}dirp; struct stat filestat; std\+::string filepath,filename; size\+\_\+t count = 0;

if (dp == NULL) \{ throw std\+::runtime\+\_\+error("{}error opening directory"{}); return; \}

while ((dirp = readdir( dp )) \&\& count \texorpdfstring{$<$}{<} maxN) \{ filepath = dir + "{}/"{} + dirp-\/\texorpdfstring{$>$}{>}d\+\_\+name;

If the file is a directory (or is in some way invalid) we\textquotesingle{}ll skip it if (stat( filepath.\+c\+\_\+str(), \&filestat )) continue; if (S\+\_\+\+ISDIR( filestat.\+st\+\_\+mode )) continue;

filename = dirp-\/\texorpdfstring{$>$}{>}d\+\_\+name; if(filename.\+find("{}.\+fits"{}) != std\+::string\+::npos)\{ bool read =true; for(int i=0;i\texorpdfstring{$<$}{<}filespecs.\+size();++i) if(filename.\+find(filespecs\mbox{[}i\mbox{]}) == std\+::string\+::npos) read = false; for(int i=0;i\texorpdfstring{$<$}{<}file\+\_\+non\+\_\+specs.\+size();++i) if(filename.\+find(file\+\_\+non\+\_\+specs\mbox{[}i\mbox{]}) != std\+::string\+::npos) read = false;

if(read)\{ if(verbose) std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} "{}reading "{} \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} filepath \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} std\+::endl; \doxylink{class_pixel_map}{Pixel\+Map} map(filepath,resolution); images.\+push\+\_\+back(std\+::move(map)); images.\+push\+\_\+back(\+Pixel\+Map(filepath,resolution)); names.\+push\+\_\+back(filepath); ++count; \} \} \}

closedir( dp );

std\+::cout \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} count \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} "{} fits files read."{} \texorpdfstring{$<$}{<}\texorpdfstring{$<$}{<} std\+::endl; return ; \} 
\begin{DoxyParams}{Parameters}
{\em dir} & path to directory containing fits files  \\
\hline
{\em filespec} & string of charactors in file name that are matched. It can be an empty string.  \\
\hline
{\em filenames} & output vector of Pixel\+Maps  \\
\hline
{\em file\+\_\+non\+\_\+spec} & string of charactors in file name that file must not have. \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c}\index{Utilities@{Utilities}!shuffle@{shuffle}}
\index{shuffle@{shuffle}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{shuffle()}{shuffle()}}
{\footnotesize\ttfamily \label{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c} 
template$<$typename T , typename R $>$ \\
void Utilities\+::shuffle (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{vec}{, }\item[{R \&}]{ran}{}\end{DoxyParamCaption})}



Shuffles a vector into a random order. 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector to be shuffled  \\
\hline
{\em ran} & a random number generator so that ran() gives a number between 0 and 1 \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a9b44ff17b26b627e429e9984d4908577}\index{Utilities@{Utilities}!sort\_indexes@{sort\_indexes}}
\index{sort\_indexes@{sort\_indexes}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes()}{sort\_indexes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_a9b44ff17b26b627e429e9984d4908577} 
template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v}{, }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index}{}\end{DoxyParamCaption})}



Find the indexes that sort a vector in asending order. 


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed  \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a357b69312972120ce046eff265e6b581}\index{Utilities@{Utilities}!sort\_indexes@{sort\_indexes}}
\index{sort\_indexes@{sort\_indexes}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes()}{sort\_indexes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{namespace_utilities_a357b69312972120ce046eff265e6b581} 
template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes (\begin{DoxyParamCaption}\item[{const T \texorpdfstring{$\ast$}{*}}]{v}{, }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index}{, }\item[{size\+\_\+t}]{N}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed  \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe}\index{Utilities@{Utilities}!sort\_indexes\_decending@{sort\_indexes\_decending}}
\index{sort\_indexes\_decending@{sort\_indexes\_decending}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes\_decending()}{sort\_indexes\_decending()}}
{\footnotesize\ttfamily \label{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe} 
template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes\+\_\+decending (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v}{, }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index}{}\end{DoxyParamCaption})}



Find the indexes that sort a vector in descending order. 


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed  \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a8de229537fd082d389db103bd918160a}\index{Utilities@{Utilities}!thicken\_poly@{thicken\_poly}}
\index{thicken\_poly@{thicken\_poly}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{thicken\_poly()}{thicken\_poly()}}
{\footnotesize\ttfamily \label{namespace_utilities_a8de229537fd082d389db103bd918160a} 
std\+::vector$<$ std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ $>$ Utilities\+::thicken\+\_\+poly (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{v}{, }\item[{double}]{R}{}\end{DoxyParamCaption})}



return the boundaries of the region that is within R of the curve v 

If the radius R is small compared to the dimenstions of the polygon an approximation is make to save time in which parallel segments to each side of the polygon are used.

If the radius R is not small a gridding method is used which is more reliable. \Hypertarget{namespace_utilities_a7f2aed1fb05038e399bf1287d64b56ec}\index{Utilities@{Utilities}!TighterHull@{TighterHull}}
\index{TighterHull@{TighterHull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{TighterHull()}{TighterHull()}}
{\footnotesize\ttfamily \label{namespace_utilities_a7f2aed1fb05038e399bf1287d64b56ec} 
std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ Utilities\+::\+Tighter\+Hull (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{v}{}\end{DoxyParamCaption})}

removes the intersections while removing interior loops The input curve needs to be ordered already. No points in the input curve will be outside the output hull. Will fail if there are overlapping segments on the hull. \Hypertarget{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104}\index{Utilities@{Utilities}!TwoDInterpolator@{TwoDInterpolator}}
\index{TwoDInterpolator@{TwoDInterpolator}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{TwoDInterpolator()}{TwoDInterpolator()}}
{\footnotesize\ttfamily \label{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104} 
Pos\+Type Utilities\+::\+Two\+DInterpolator (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{x}{, }\item[{int}]{Npixels}{, }\item[{Pos\+Type}]{range}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{map}{, }\item[{bool}]{init}{}\end{DoxyParamCaption})}



bilinear interpolation from a map. 

Out of bounds points return 0. map is a i dimensional array representing a 2 dimensional map. Don\textquotesingle{}t use init. After it is used once, later calls can use Two\+DInterpolator(\+Pos\+Type \texorpdfstring{$\ast$}{*}map) for the same point in the same coordinate system to save time in calculating the indexes. bilinear interpolation

bilinear interpolation\Hypertarget{namespace_utilities_a09f4dcf28911d550c9bd20eeba202f5f}\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily \label{namespace_utilities_a09f4dcf28911d550c9bd20eeba202f5f} 
int Utilities\+::windings (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&}]{x}{, }\item[{const std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{point}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em point} & The points on the border. These must be ordered.  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_afc8d337b886b466535a29068af0b4994}\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily \label{namespace_utilities_afc8d337b886b466535a29068af0b4994} 
int Utilities\+::windings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&}]{x}{, }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&}]{point}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em point} & The points on the border. Uses image plane points  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa}\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily \label{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa} 
int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{x}{, }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{kist}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{, }\item[{short}]{image}{ = {\ttfamily 0}}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em kist} & Kist of points on the border. These must be ordered.  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border  \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa}\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily \label{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa} 
int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{x}{, }\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{points}{, }\item[{unsigned long}]{Npoints}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{, }\item[{short}]{image}{ = {\ttfamily 0}}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em points} & The points on the border. These must be ordered.  \\
\hline
{\em Npoints} & number of points in curve  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border  \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_ac42846299720c47decf597f70d448464}\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily \label{namespace_utilities_ac42846299720c47decf597f70d448464} 
int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{x}{, }\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{points}{, }\item[{unsigned long}]{Npoints}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{, }\item[{short}]{image}{}\end{DoxyParamCaption})}



\doxylink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings()}\+: winding number test for a point in a polygon Returns\+: Number of times a curves winds around the point x. 

The number of times the curve loops around a point is calculated.

The area of a self-\/intersecting curve will be the area of the regions encircled in a clockwise direction minus the regions encircled in a counterclockwise direction -\/ an infinity symbol has zero area. 
\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em points} & The points on the border. These must be ordered.  \\
\hline
{\em Npoints} & number of points in curve  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border  \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065}\index{Utilities@{Utilities}!windings2@{windings2}}
\index{windings2@{windings2}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings2()}{windings2()}}
{\footnotesize\ttfamily \label{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065} 
int Utilities\+::windings2 (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{x}{, }\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{points\+\_\+original}{, }\item[{unsigned long}]{Npoints}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{area}{, }\item[{short}]{image}{}\end{DoxyParamCaption})}



determines whether a point is inside a curve, that has been stretched 1.\+2 times returns the area of the stretched curve 


\begin{DoxyParams}{Parameters}
{\em x} & \doxylink{struct_point}{Point} for which the winding number is calculated  \\
\hline
{\em points\+\_\+original} & The points on the border. These must be ordered.  \\
\hline
{\em Npoints} & number of points in curve  \\
\hline
{\em area} & returns absolute the area within the curve with oriented border  \\
\hline
{\em image} & if == 0 the image of the curve is used as the curve \\
\hline
\end{DoxyParams}
\Hypertarget{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d}\index{Utilities@{Utilities}!writeCurves@{writeCurves}}
\index{writeCurves@{writeCurves}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{writeCurves()}{writeCurves()}}
{\footnotesize\ttfamily \label{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d} 
void Utilities\+::write\+Curves (\begin{DoxyParamCaption}\item[{int}]{m}{, }\item[{\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}}]{critical}{, }\item[{int}]{Ncrit}{, }\item[{int}]{ind\+\_\+caustic}{}\end{DoxyParamCaption})}

writes in four files the critical curves and the caustics for all the curves found and also for a specified one (ind\+\_\+causic) 
\begin{DoxyParams}{Parameters}
{\em m} & part of te filename, could be the number/index of the main lens  \\
\hline
{\em critical} & the crit curve  \\
\hline
{\em Ncrit} & the number of crit curves  \\
\hline
{\em ind\+\_\+caustic} & the index of the cuvre of interest \\
\hline
\end{DoxyParams}
