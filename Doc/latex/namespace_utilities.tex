\hypertarget{namespace_utilities}{}\doxysection{Utilities Namespace Reference}
\label{namespace_utilities}\index{Utilities@{Utilities}}



\begin{DoxyItemize}
\item 
\end{DoxyItemize} 


\doxysubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 \mbox{\hyperlink{namespace_utilities_1_1_geometry}{Geometry}}
\begin{DoxyCompactList}\small\item\em Namespace for geometrical functions mostly having to do with spherical coordinates. \end{DoxyCompactList}\item 
 \mbox{\hyperlink{namespace_utilities_1_1_i_o}{IO}}
\begin{DoxyCompactList}\small\item\em namespace for input/output utilities \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_utilities_1_1_d2_matrix}{D2\+Matrix}}
\begin{DoxyCompactList}\small\item\em 2 dimensional matrix \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_d3_matrix}{D3\+Matrix}}
\begin{DoxyCompactList}\small\item\em 3 dimensional matrix, fixed size \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_data_frame}{Data\+Frame}}
\begin{DoxyCompactList}\small\item\em class for impoting data from a csv file and allowing label string lookup like a data frame. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_hilbert_curve}{Hilbert\+Curve}}
\begin{DoxyCompactList}\small\item\em Class for calculating the Hilbert curve distance in two dimensions. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_interpolator}{Interpolator}}
\begin{DoxyCompactList}\small\item\em Bilinear interpolation class for interpolating from a 2D uniform grid. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_mixed_vector}{Mixed\+Vector}}
\begin{DoxyCompactList}\small\item\em A container that can hold mixed objects all derived from a base class and retains the ability to access derived class functions/members. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_mixed_vector_3_01_base_t_01_5_01_4}{Mixed\+Vector$<$ Base\+T $\ast$ $>$}}
\begin{DoxyCompactList}\small\item\em A \mbox{\hyperlink{class_utilities_1_1_mixed_vector}{Mixed\+Vector}} for pointers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Random\+Numbers\+\_\+\+NR}}
\begin{DoxyCompactList}\small\item\em This is a class for generating random numbers. It simplifies and fool proofs initialization and allows for multiple independent series of numbers. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_shuffled_index}{Shuffled\+Index}}
\begin{DoxyCompactList}\small\item\em Gives a randomized sequence of numbers from 0 to N-\/1. \end{DoxyCompactList}\item 
class \mbox{\hyperlink{class_utilities_1_1_symmetric_matrix}{Symmetric\+Matrix}}
\begin{DoxyCompactList}\small\item\em Symetric matrix. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace_utilities_a83d3f6d35f48dd5cf7ff992a6c36ee8a}\label{namespace_utilities_a83d3f6d35f48dd5cf7ff992a6c36ee8a}} 
void {\bfseries print\+\_\+date} ()
\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a380f0a954728d751781e61918facba0e}{fill\+\_\+linear}} (std\+::vector$<$ T $>$ \&v, size\+\_\+t n, T min, T max)
\item 
{\footnotesize template$<$class T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a}{fill\+\_\+logarithmic}} (std\+::vector$<$ T $>$ \&v, size\+\_\+t n, T min, T max)
\item 
{\footnotesize template$<$class T $>$ }\\long \mbox{\hyperlink{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e}{locate}} (const std\+::vector$<$ T $>$ \&v, const T x)
\item 
{\footnotesize template$<$class T , class F $>$ }\\long \mbox{\hyperlink{namespace_utilities_ab7663a1f094849a77cab564e61fcca49}{locate}} (const std\+::vector$<$ T $>$ \&v, F x, std\+::function$<$ bool(F, const T \&)$>$ less\+\_\+than)
\item 
\mbox{\Hypertarget{namespace_utilities_a0cfb54fff515cfd5d684572962f50c66}\label{namespace_utilities_a0cfb54fff515cfd5d684572962f50c66}} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries locate} (T $\ast$v, unsigned long n, T x, unsigned long $\ast$index)
\item 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t \mbox{\hyperlink{namespace_utilities_acc053736fab41bd2807991e8dfcab129}{locate}} (const std\+::vector$<$ T $>$ \&v, const std\+::vector$<$ size\+\_\+t $>$ \&sorted\+\_\+index, T value, size\+\_\+t \&rank)
\begin{DoxyCompactList}\small\item\em Finds the element of a vector given a sorted index of the vector. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_aa80185750e610681c64de174516f9799}\label{namespace_utilities_aa80185750e610681c64de174516f9799}} 
{\footnotesize template$<$class T $>$ }\\size\+\_\+t \mbox{\hyperlink{namespace_utilities_aa80185750e610681c64de174516f9799}{closest}} (const std\+::vector$<$ T $>$ \&v, const T x)
\begin{DoxyCompactList}\small\item\em Returns the index of the element of v that is closest to x. v must be sorted. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e}{Interpolate\+Yvec}} (std\+::vector$<$ Pos\+Type $>$ \&x, std\+::vector$<$ Pos\+Type $>$ \&y, Pos\+Type xi)
\item 
\mbox{\Hypertarget{namespace_utilities_a49c02a235f698cf25dbc7edf34d4bf8f}\label{namespace_utilities_a49c02a235f698cf25dbc7edf34d4bf8f}} 
Pos\+Type {\bfseries arctanh} (Pos\+Type x)
\item 
\mbox{\Hypertarget{namespace_utilities_a473f872514990ed70931ddd9489301a7}\label{namespace_utilities_a473f872514990ed70931ddd9489301a7}} 
Pos\+Type {\bfseries fmini} (Pos\+Type a, Pos\+Type b)
\item 
\mbox{\Hypertarget{namespace_utilities_af99adc537b02f26073243f0d32376def}\label{namespace_utilities_af99adc537b02f26073243f0d32376def}} 
Pos\+Type {\bfseries fmaxi} (Pos\+Type a, Pos\+Type b)
\item 
\mbox{\Hypertarget{namespace_utilities_a1ec52aba262343bc391860a37da4d472}\label{namespace_utilities_a1ec52aba262343bc391860a37da4d472}} 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{namespace_utilities_a1ec52aba262343bc391860a37da4d472}{median}} (std\+::vector$<$ T $>$ vec)
\begin{DoxyCompactList}\small\item\em find median of vector \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}\label{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}} 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}} (std\+::vector$<$ T $>$ vec, T \&max, T \&min)
\begin{DoxyCompactList}\small\item\em find the maximum and minimum of a vector \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a85e6e176b88221d17c1a0d6c83a6846d}\label{namespace_utilities_a85e6e176b88221d17c1a0d6c83a6846d}} 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a85e6e176b88221d17c1a0d6c83a6846d}{polintT}} (T xa\mbox{[}$\,$\mbox{]}, T ya\mbox{[}$\,$\mbox{]}, int n, T x, T $\ast$y, T $\ast$dy)
\begin{DoxyCompactList}\small\item\em interpolation \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a7679e167450f3450c86c345cd8de373d}\label{namespace_utilities_a7679e167450f3450c86c345cd8de373d}} 
{\footnotesize template$<$typename Functor\+Type , typename T  = double$>$ }\\T \mbox{\hyperlink{namespace_utilities_a7679e167450f3450c86c345cd8de373d}{trapz}} (Functor\+Type \&func, T a, T b, int n, T $\ast$s2)
\begin{DoxyCompactList}\small\item\em used in trapizoidal integral \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Functor\+Type , typename T  = double$>$ }\\T \mbox{\hyperlink{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98}{nintegrateF}} (Functor\+Type func, T a, T b, T tols)
\item 
\mbox{\Hypertarget{namespace_utilities_a31db9f78433a6de800437aedfd1b2eb5}\label{namespace_utilities_a31db9f78433a6de800437aedfd1b2eb5}} 
void \mbox{\hyperlink{namespace_utilities_a31db9f78433a6de800437aedfd1b2eb5}{rotation}} (float $\ast$xout, float $\ast$xin, Pos\+Type theta)
\begin{DoxyCompactList}\small\item\em Rotates 2 dimensional point without changing input point. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a8ad140aa2e74c584b82ff6416ff16622}\label{namespace_utilities_a8ad140aa2e74c584b82ff6416ff16622}} 
void \mbox{\hyperlink{namespace_utilities_a8ad140aa2e74c584b82ff6416ff16622}{rotation}} (Pos\+Type $\ast$xout, Pos\+Type const $\ast$xin, Pos\+Type theta)
\begin{DoxyCompactList}\small\item\em Rotates 2 dimensional point without changing input point. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a0855636bdb71f103a4412555b9711e98}{Random\+From\+Table}} (Pos\+Type $\ast$table, unsigned long Ntable, long $\ast$seed)
\begin{DoxyCompactList}\small\item\em Generates a random deviates drawn f\+Einstein\+\_\+rom app\+Einstein\+\_\+roximately the same as the values of table. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_aae5ae9b5d81618c5ab06016357dc6c7d}\label{namespace_utilities_aae5ae9b5d81618c5ab06016357dc6c7d}} 
{\footnotesize template$<$typename T , typename P $>$ }\\\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries subtract} (T \&p1, P \&p2)
\item 
\mbox{\Hypertarget{namespace_utilities_a34ba39540d95cbeaa6a00631c640ca7f}\label{namespace_utilities_a34ba39540d95cbeaa6a00631c640ca7f}} 
{\footnotesize template$<$typename P $>$ }\\double {\bfseries crossD} (P \&O, P \&A, P \&B)
\item 
\mbox{\Hypertarget{namespace_utilities_a02302245829df0b35aca33fc6415cb96}\label{namespace_utilities_a02302245829df0b35aca33fc6415cb96}} 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t \mbox{\hyperlink{namespace_utilities_a02302245829df0b35aca33fc6415cb96}{Remove\+Intersections}} (std\+::vector$<$ T $>$ \&curve)
\begin{DoxyCompactList}\small\item\em removes the intersections of the curve \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_acd4dccd3d5a6b05220a4060b921cf318}\label{namespace_utilities_acd4dccd3d5a6b05220a4060b921cf318}} 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_acd4dccd3d5a6b05220a4060b921cf318}{convex\+\_\+hull}} (std\+::vector$<$ T $>$ \&P, std\+::vector$<$ T $>$ \&hull\+\_\+out)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a3ffe5233ee836b82577a661cd137075d}\label{namespace_utilities_a3ffe5233ee836b82577a661cd137075d}} 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a3ffe5233ee836b82577a661cd137075d}{convex\+\_\+hull}} (std\+::vector$<$ T $>$ \&P, std\+::vector$<$ size\+\_\+t $>$ \&hull\+\_\+index)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a6d17c2495bead70b18b91c376c28c051}{concave}} (std\+::vector$<$ T $>$ \&init\+\_\+points, std\+::vector$<$ T $>$ \&hull\+\_\+out, double scale)
\begin{DoxyCompactList}\small\item\em Creates the concave hull of a group of 2 dimensional points by the shrink-\/wrap algorithm. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a50f51d6512069fdc1b2fa93dbf409c20}\label{namespace_utilities_a50f51d6512069fdc1b2fa93dbf409c20}} 
{\footnotesize template$<$typename T $>$ }\\std\+::vector$<$ T $>$ {\bfseries concave2} (std\+::vector$<$ T $>$ \&init\+\_\+points, double scale)
\item 
void \mbox{\hyperlink{namespace_utilities_a74edb07bfa2d5cee2ef5450f0998ff57}{Load\+Fits\+Images}} (std\+::string dir, const std\+::string \&filespec, std\+::vector$<$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} $>$ \&images, int maxN, double resolution=-\/1, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Reads all the fits files in a directory into a vector of Pixel\+Maps. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_ad3f190fa0f0cac4eb4b7c981d5131e5d}{Load\+Fits\+Images}} (std\+::string dir, std\+::vector$<$ std\+::string $>$ filespecs, std\+::vector$<$ std\+::string $>$ file\+\_\+non\+\_\+specs, std\+::vector$<$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} $>$ \&images, std\+::vector$<$ std\+::string $>$ \&names, int maxN, double resolution=-\/1, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Reads all the fits files in a directory into a vector of Pixel\+Maps. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2}{Read\+File\+Names}} (std\+::string dir, const std\+::string filespec, std\+::vector$<$ std\+::string $>$ \&filenames, const std\+::string file\+\_\+non\+\_\+spec=\char`\"{} \char`\"{}, bool verbose=false)
\item 
\mbox{\Hypertarget{namespace_utilities_ab99eb78332b2d654761336b8ecbde2da}\label{namespace_utilities_ab99eb78332b2d654761336b8ecbde2da}} 
std\+::string {\bfseries to\+\_\+string} (const Band \&band)
\item 
\mbox{\Hypertarget{namespace_utilities_af1ce4c9e1180dd33a9f4c0c416643a9e}\label{namespace_utilities_af1ce4c9e1180dd33a9f4c0c416643a9e}} 
Pos\+Type \mbox{\hyperlink{namespace_utilities_af1ce4c9e1180dd33a9f4c0c416643a9e}{sep\+S\+QR}} (Pos\+Type $\ast$xx, Pos\+Type $\ast$yy)
\begin{DoxyCompactList}\small\item\em Separation squared between two positions in 2 dimensions. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a367c5422e8b232b598bfdf69131a7a41}\label{namespace_utilities_a367c5422e8b232b598bfdf69131a7a41}} 
void {\bfseries double\+\_\+sort} (unsigned long n, Pos\+Type $\ast$arr, unsigned long $\ast$brr)
\item 
void \mbox{\hyperlink{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2}{double\+\_\+sort\+\_\+points}} (unsigned long n, Pos\+Type $\ast$arr, \mbox{\hyperlink{struct_point}{Point}} $\ast$brr)
\begin{DoxyCompactList}\small\item\em Sorts points in a point array. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a069e88bf3ba4576f526f75cd607954d4}\label{namespace_utilities_a069e88bf3ba4576f526f75cd607954d4}} 
void \mbox{\hyperlink{namespace_utilities_a069e88bf3ba4576f526f75cd607954d4}{quicksort\+Points}} (\mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, Pos\+Type $\ast$arr, unsigned long N)
\begin{DoxyCompactList}\small\item\em Sorts points from smallest to largest according to the value of arr\mbox{[}\mbox{]}. Sorts arr\mbox{[}\mbox{]} and pointarray\mbox{[}\mbox{]} simultaneously. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_afe0f971972428328fbfecb023efa932b}\label{namespace_utilities_afe0f971972428328fbfecb023efa932b}} 
void {\bfseries quicksort\+Points} (\mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, double($\ast$func)(\mbox{\hyperlink{struct_point}{Point}} \&), unsigned long N)
\item 
\mbox{\Hypertarget{namespace_utilities_a616805c8dcc25692640ce161f5d4d6be}\label{namespace_utilities_a616805c8dcc25692640ce161f5d4d6be}} 
{\footnotesize template$<$typename D $>$ }\\void {\bfseries quicksort} (unsigned long $\ast$particles, D $\ast$arr, unsigned long N)
\item 
\mbox{\Hypertarget{namespace_utilities_aa6be6f6a86b7b31f27b6d38ebcb93d6c}\label{namespace_utilities_aa6be6f6a86b7b31f27b6d38ebcb93d6c}} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition} (T pivotvalue, unsigned long $\ast$pivotindex, unsigned long $\ast$particles, T $\ast$arr, unsigned long N)
\item 
\mbox{\Hypertarget{namespace_utilities_a0087080ad4336acd526aeb64e114176e}\label{namespace_utilities_a0087080ad4336acd526aeb64e114176e}} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition\+Points} (T pivotvalue, unsigned long $\ast$pivotindex, \mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, T $\ast$arr, unsigned long N)
\item 
\mbox{\Hypertarget{namespace_utilities_aed119e61f1d5a87c46cbc2e4e5e574e1}\label{namespace_utilities_aed119e61f1d5a87c46cbc2e4e5e574e1}} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries quick\+Partition\+Points} (T pivotvalue, unsigned long $\ast$pivotindex, \mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, T($\ast$func)(\mbox{\hyperlink{struct_point}{Point}} \&p), unsigned long N)
\item 
\mbox{\Hypertarget{namespace_utilities_a606f4aebc622ae58090979fda604d1fc}\label{namespace_utilities_a606f4aebc622ae58090979fda604d1fc}} 
void {\bfseries log\+\_\+polar\+\_\+grid} (\mbox{\hyperlink{struct_point}{Point}} $\ast$i\+\_\+points, Pos\+Type rmax, Pos\+Type rmin, Pos\+Type $\ast$center, long Ngrid)
\item 
\mbox{\Hypertarget{namespace_utilities_a7c5dac005305573c90d3c46db67967a0}\label{namespace_utilities_a7c5dac005305573c90d3c46db67967a0}} 
void {\bfseries findarea} (\mbox{\hyperlink{struct_image_info}{Image\+Info}} $\ast$imageinfo)
\item 
void \mbox{\hyperlink{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d}{write\+Curves}} (int m, \mbox{\hyperlink{struct_image_info}{Image\+Info}} $\ast$critical, int Ncrit, int index)
\item 
\mbox{\Hypertarget{namespace_utilities_ac66dea830e7b8f4390339d39eca8af68}\label{namespace_utilities_ac66dea830e7b8f4390339d39eca8af68}} 
Pos\+Type {\bfseries cross} (const \mbox{\hyperlink{struct_point}{Point}} $\ast$O, const \mbox{\hyperlink{struct_point}{Point}} $\ast$A, const \mbox{\hyperlink{struct_point}{Point}} $\ast$B)
\item 
\mbox{\Hypertarget{namespace_utilities_ac42b802d503f1acd2f3d92eb903b9228}\label{namespace_utilities_ac42b802d503f1acd2f3d92eb903b9228}} 
bool {\bfseries xorder} (\mbox{\hyperlink{struct_point}{Point}} $\ast$p1, \mbox{\hyperlink{struct_point}{Point}} $\ast$p2)
\item 
\mbox{\Hypertarget{namespace_utilities_a62ff8c370817f6c178c77b361cca0292}\label{namespace_utilities_a62ff8c370817f6c178c77b361cca0292}} 
bool {\bfseries yorder} (\mbox{\hyperlink{struct_point}{Point}} $\ast$p1, \mbox{\hyperlink{struct_point}{Point}} $\ast$p2)
\item 
\mbox{\Hypertarget{namespace_utilities_afbe6171a36bf18a88838285e19f90d63}\label{namespace_utilities_afbe6171a36bf18a88838285e19f90d63}} 
Pos\+Type {\bfseries crossD} (const double $\ast$O, const double $\ast$A, const double $\ast$B)
\item 
\mbox{\Hypertarget{namespace_utilities_ab84c604b536630835c839b7975028165}\label{namespace_utilities_ab84c604b536630835c839b7975028165}} 
Pos\+Type {\bfseries crossD} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&O, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&A, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&B)
\item 
\mbox{\Hypertarget{namespace_utilities_a6997f6bfc95f466039c9652c6c50274f}\label{namespace_utilities_a6997f6bfc95f466039c9652c6c50274f}} 
std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ \mbox{\hyperlink{namespace_utilities_a6997f6bfc95f466039c9652c6c50274f}{convex\+\_\+hull}} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ \&P)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a0699a4c75e3899f853dee3fe6a442a25}\label{namespace_utilities_a0699a4c75e3899f853dee3fe6a442a25}} 
std\+::vector$<$ double $\ast$ $>$ \mbox{\hyperlink{namespace_utilities_a0699a4c75e3899f853dee3fe6a442a25}{convex\+\_\+hull}} (std\+::vector$<$ double $\ast$ $>$ \&P)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convex hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ \mbox{\hyperlink{namespace_utilities_aca82634714ad53172788a38cef165b07}{concave\+\_\+hull}} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ \&P, int k, bool test=false)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convcave hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
std\+::vector$<$ double $\ast$ $>$ \mbox{\hyperlink{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4}{concave\+\_\+hull}} (std\+::vector$<$ double $\ast$ $>$ \&P, int k)
\begin{DoxyCompactList}\small\item\em Returns a vector of points on the convcave hull in counter-\/clockwise order. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d}{contour\+\_\+ellipse}} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&P, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} center, unsigned long Npoints, std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&C, double $\ast$ellipticity, double $\ast$ellipse\+\_\+area)
\begin{DoxyCompactList}\small\item\em Returns axis ratio, area and points of an ellipse engulfed by some contour (e.\+g. a contour of same convergence calculated with find\+\_\+contour). \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \mbox{\hyperlink{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}{contour\+\_\+center}} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&P, unsigned long Npoints)
\begin{DoxyCompactList}\small\item\em Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_aa727547d253bdbd88ac47cae3f7c65c4}\label{namespace_utilities_aa727547d253bdbd88ac47cae3f7c65c4}} 
long {\bfseries Index\+From\+Position} (Pos\+Type $\ast$x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, const Pos\+Type $\ast$center)
\item 
\mbox{\Hypertarget{namespace_utilities_afa68bfc533f3ce300625ec2b97073800}\label{namespace_utilities_afa68bfc533f3ce300625ec2b97073800}} 
void \mbox{\hyperlink{namespace_utilities_afa68bfc533f3ce300625ec2b97073800}{Position\+From\+Index}} (unsigned long i, Pos\+Type $\ast$x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type const $\ast$center)
\begin{DoxyCompactList}\small\item\em This should work for square regions. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a97a19e41534673a4234e99cce59b0a23}\label{namespace_utilities_a97a19e41534673a4234e99cce59b0a23}} 
long {\bfseries Index\+From\+Position} (Pos\+Type x, long Npixels, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type center)
\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104}{Two\+D\+Interpolator}} (Pos\+Type $\ast$x,int Npixels,Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}},Pos\+Type $\ast$center,Pos\+Type $\ast$map,bool init)
\begin{DoxyCompactList}\small\item\em bilinear interpolation from a map. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_af1cbfc7c5cbcb4525faabc04298eb54d}\label{namespace_utilities_af1cbfc7c5cbcb4525faabc04298eb54d}} 
Pos\+Type {\bfseries Two\+D\+Interpolator} (Pos\+Type $\ast$map)
\item 
\mbox{\Hypertarget{namespace_utilities_a712b815d57f9f34d4d2e02209bfc1c2b}\label{namespace_utilities_a712b815d57f9f34d4d2e02209bfc1c2b}} 
{\footnotesize template$<$typename T $>$ }\\int {\bfseries cutbox} (const T $\ast$center, T $\ast$p1, T $\ast$p2, float rmax)
\item 
\mbox{\Hypertarget{namespace_utilities_ac985ac1b171f2d550864536530bbac2f}\label{namespace_utilities_ac985ac1b171f2d550864536530bbac2f}} 
{\footnotesize template$<$int lev$>$ }\\void \mbox{\hyperlink{namespace_utilities_ac985ac1b171f2d550864536530bbac2f}{quicksort\+Points\+\_\+multithread}} (\mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, Pos\+Type $\ast$arr, unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2$^\wedge$lev. The last parameter should be left out when calling so that it takes the default value. \end{DoxyCompactList}\item 
{\footnotesize template$<$int lev$>$ }\\void \mbox{\hyperlink{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a}{quicksort\+Points\+\_\+multithread}} (\mbox{\hyperlink{struct_point}{Point}} $\ast$pointarray, double($\ast$func)(\mbox{\hyperlink{struct_point}{Point}} \&), unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2$^\wedge$lev. The function {\ttfamily func} takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}\label{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}} 
{\footnotesize template$<$typename T , int lev$>$ }\\void \mbox{\hyperlink{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}{quicksort\+\_\+multithread}} (T $\ast$array, double($\ast$func)(T \&), unsigned long N, int level=0)
\begin{DoxyCompactList}\small\item\em Multi-\/threaded quicksort. The maximum number of threads used is 2$^\wedge$lev. The function {\ttfamily func} takes a T type and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. std\+::swap() is used to swap elements of the array. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a0f92371d63e47b1c09977312f15a15f0}\label{namespace_utilities_a0f92371d63e47b1c09977312f15a15f0}} 
float {\bfseries is\+Left} (\mbox{\hyperlink{struct_point}{Point}} $\ast$p0, \mbox{\hyperlink{struct_point}{Point}} $\ast$p1, Pos\+Type $\ast$x)
\item 
\mbox{\Hypertarget{namespace_utilities_a7ac422420ab4fffbff7714f0015e1727}\label{namespace_utilities_a7ac422420ab4fffbff7714f0015e1727}} 
float {\bfseries is\+Left} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&p0, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&p1, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x)
\item 
unsigned long \mbox{\hyperlink{namespace_utilities_abe61342a713adf7115f351e3342a2b79}{prevpower}} (unsigned long k)
\item 
int \mbox{\hyperlink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings}} (Pos\+Type $\ast$x,\mbox{\hyperlink{struct_point}{Point}} $\ast$points,unsigned long Npoints,Pos\+Type $\ast$area,short image)
\begin{DoxyCompactList}\small\item\em \mbox{\hyperlink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings()}}\+: winding number test for a point in a polygon Returns\+: Number of times a curves winds around the point x. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa}{windings}} (Pos\+Type $\ast$x, \mbox{\hyperlink{struct_point}{Point}} $\ast$$\ast$points, unsigned long Npoints, Pos\+Type $\ast$area, short image=0)
\item 
int \mbox{\hyperlink{namespace_utilities_a64cd4e52a3b543449c6ba0330f13f01e}{windings}} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&point, Pos\+Type $\ast$area)
\item 
int \mbox{\hyperlink{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa}{windings}} (Pos\+Type $\ast$x, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$kist, Pos\+Type $\ast$area, short image=0)
\item 
int \mbox{\hyperlink{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065}{windings2}} (Pos\+Type $\ast$x,\mbox{\hyperlink{struct_point}{Point}} $\ast$points\+\_\+original,unsigned long Npoints,Pos\+Type $\ast$area,short image)
\begin{DoxyCompactList}\small\item\em determines whether a point is inside a curve, that has been stretched 1.\+2 times returns the area of the stretched curve \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a6113d02b4e7adef2372f1875990e3fe1}\label{namespace_utilities_a6113d02b4e7adef2372f1875990e3fe1}} 
int \mbox{\hyperlink{namespace_utilities_a6113d02b4e7adef2372f1875990e3fe1}{incurve}} (Pos\+Type x\mbox{[}$\,$\mbox{]}, std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ curve)
\begin{DoxyCompactList}\small\item\em returns 1 if it is in the curve and 0 if it is out. Borders count as in. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a23cc634a3e291c24e89a13c9e480e5b2}\label{namespace_utilities_a23cc634a3e291c24e89a13c9e480e5b2}} 
int \mbox{\hyperlink{namespace_utilities_a23cc634a3e291c24e89a13c9e480e5b2}{incurve}} (Pos\+Type x\mbox{[}$\,$\mbox{]}, std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ curve)
\begin{DoxyCompactList}\small\item\em returns 1 if it is in the curve and 0 if it is out. Borders count as in. \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7}{order\+\_\+curve4}} (\mbox{\hyperlink{struct_point}{Point}} $\ast$curve, long Npoints)
\begin{DoxyCompactList}\small\item\em Orders points on a closed curve. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_ab9e95a7c17ef4a5d5c4a31fac956140c}\label{namespace_utilities_ab9e95a7c17ef4a5d5c4a31fac956140c}} 
unsigned long \mbox{\hyperlink{namespace_utilities_ab9e95a7c17ef4a5d5c4a31fac956140c}{order\+\_\+curve4}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\begin{DoxyCompactList}\small\item\em Overloads and is dependent on version that takes a point array. Returns number of points that have been ordered. Remaining, unordered points are left at the end of the kist. \end{DoxyCompactList}\item 
unsigned long \mbox{\hyperlink{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41}{order\+\_\+curve5}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\begin{DoxyCompactList}\small\item\em For odering the curve by the convex hull method. Warning\+: Does not work very well. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a742ad22484d4cfaaefd6317d73a74934}\label{namespace_utilities_a742ad22484d4cfaaefd6317d73a74934}} 
void \mbox{\hyperlink{namespace_utilities_a742ad22484d4cfaaefd6317d73a74934}{ordered\+\_\+convexhull}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\begin{DoxyCompactList}\small\item\em Replaces curve-\/$>$imagekist with its convex hull. The number of points will change. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_aa8efda5cf4838d1780ea6e08e155566f}\label{namespace_utilities_aa8efda5cf4838d1780ea6e08e155566f}} 
void {\bfseries ordered\+\_\+shrink\+\_\+wrap} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\item 
\mbox{\Hypertarget{namespace_utilities_ac95a7f052ffe8de55dfdc33d06dc541c}\label{namespace_utilities_ac95a7f052ffe8de55dfdc33d06dc541c}} 
void {\bfseries ordered\+\_\+concavehull} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\item 
Pos\+Type \mbox{\hyperlink{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0}{Convex\+Hull\+Area}} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$curve)
\begin{DoxyCompactList}\small\item\em Replaces curve with its convex hull. The number of points will change. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a1a6368539a2249ac91796f3ff043e39d}\label{namespace_utilities_a1a6368539a2249ac91796f3ff043e39d}} 
{\footnotesize template$<$class T $>$ }\\T \mbox{\hyperlink{namespace_utilities_a1a6368539a2249ac91796f3ff043e39d}{to\+\_\+numeric}} (const std\+::string \&str)
\begin{DoxyCompactList}\small\item\em convert a string to a numerical value of various types \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a55417d380d1000c91b7a59253cd0b82c}\label{namespace_utilities_a55417d380d1000c91b7a59253cd0b82c}} 
template$<$$>$ long {\bfseries to\+\_\+numeric$<$ long $>$} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{namespace_utilities_a35d114df3356f5498414ff9a481f2173}\label{namespace_utilities_a35d114df3356f5498414ff9a481f2173}} 
template$<$$>$ int {\bfseries to\+\_\+numeric$<$ int $>$} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{namespace_utilities_a0a01d1a182e6b247d4702062aab5a32f}\label{namespace_utilities_a0a01d1a182e6b247d4702062aab5a32f}} 
template$<$$>$ float {\bfseries to\+\_\+numeric$<$ float $>$} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{namespace_utilities_a5b3b8518238ba6cedc16d8012904c70f}\label{namespace_utilities_a5b3b8518238ba6cedc16d8012904c70f}} 
template$<$$>$ double {\bfseries to\+\_\+numeric$<$ double $>$} (const std\+::string \&str)
\item 
\mbox{\Hypertarget{namespace_utilities_a32849c92ee172e983b4223072587ae6d}\label{namespace_utilities_a32849c92ee172e983b4223072587ae6d}} 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries Always\+True} (T t)
\item 
\mbox{\Hypertarget{namespace_utilities_ab47b3f15baa661c5bb9cfd66acea8758}\label{namespace_utilities_ab47b3f15baa661c5bb9cfd66acea8758}} 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries Always\+False} (T t)
\item 
\mbox{\Hypertarget{namespace_utilities_a5364acb5691c4969be66653956508e6b}\label{namespace_utilities_a5364acb5691c4969be66653956508e6b}} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries Matrix} (T $\ast$$\ast$matrix, long rows, long cols)
\item 
\mbox{\Hypertarget{namespace_utilities_acdc7f37bdbbd9f9893af797a98f601aa}\label{namespace_utilities_acdc7f37bdbbd9f9893af797a98f601aa}} 
{\footnotesize template$<$class T $>$ }\\void {\bfseries free\+\_\+\+Matrix} (T $\ast$$\ast$matrix, long rows, long)
\item 
\mbox{\Hypertarget{namespace_utilities_aeab156e03bf2f71c3c0de9e267dcb39b}\label{namespace_utilities_aeab156e03bf2f71c3c0de9e267dcb39b}} 
Pos\+Type $\ast$$\ast$ {\bfseries Pos\+Type\+Matrix} (size\+\_\+t rows, size\+\_\+t cols)
\item 
\mbox{\Hypertarget{namespace_utilities_a9ee12be6dc37bf892ebfbeff4b835084}\label{namespace_utilities_a9ee12be6dc37bf892ebfbeff4b835084}} 
void {\bfseries free\+\_\+\+Pos\+Type\+Matrix} (Pos\+Type $\ast$$\ast$matrix, size\+\_\+t rows, size\+\_\+t cols)
\item 
\mbox{\Hypertarget{namespace_utilities_aee8540dba0d1bf112290a7389379fefa}\label{namespace_utilities_aee8540dba0d1bf112290a7389379fefa}} 
Pos\+Type $\ast$$\ast$ {\bfseries Pos\+Type\+Matrix} (long rows1, long rows2, long cols1, long cols2)
\item 
\mbox{\Hypertarget{namespace_utilities_aa8f8b847fdd13e67af70275c2df84ef9}\label{namespace_utilities_aa8f8b847fdd13e67af70275c2df84ef9}} 
void {\bfseries free\+\_\+\+Pos\+Type\+Matrix} (Pos\+Type $\ast$$\ast$matrix, long rows1, long rows2, long cols1, long cols2)
\item 
\mbox{\Hypertarget{namespace_utilities_a355e53765bbce52485685f2cf11632d5}\label{namespace_utilities_a355e53765bbce52485685f2cf11632d5}} 
{\footnotesize template$<$class BaseT $>$ }\\std\+::size\+\_\+t {\bfseries lower\+\_\+bound} (std\+::vector$<$ BaseT $\ast$ $>$ \&items, Pos\+Type target)
\item 
\mbox{\Hypertarget{namespace_utilities_ab5fbd0455bb23cf8290252d8ddef0874}\label{namespace_utilities_ab5fbd0455bb23cf8290252d8ddef0874}} 
{\footnotesize template$<$typename Container $>$ }\\void \mbox{\hyperlink{namespace_utilities_ab5fbd0455bb23cf8290252d8ddef0874}{delete\+\_\+container}} (Container \&c)
\begin{DoxyCompactList}\small\item\em delete the objects that are pointed to in a container of pointers \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a42da2b93e07ba858edd0d2b9ca7032ec}\label{namespace_utilities_a42da2b93e07ba858edd0d2b9ca7032ec}} 
{\footnotesize template$<$typename T $>$ }\\T {\bfseries between} (const T \&x, const T \&l, const T \&u)
\item 
{\footnotesize template$<$typename T , typename R $>$ }\\void \mbox{\hyperlink{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c}{shuffle}} (std\+::vector$<$ T $>$ \&vec, R \&ran)
\begin{DoxyCompactList}\small\item\em Shuffles a vector into a random order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a9b44ff17b26b627e429e9984d4908577}{sort\+\_\+indexes}} (const std\+::vector$<$ T $>$ \&v, std\+::vector$<$ size\+\_\+t $>$ \&index)
\begin{DoxyCompactList}\small\item\em Find the indexes that sort a vector in asending order. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_a357b69312972120ce046eff265e6b581}{sort\+\_\+indexes}} (const T $\ast$v, std\+::vector$<$ size\+\_\+t $>$ \&index, size\+\_\+t N)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe}{sort\+\_\+indexes\+\_\+decending}} (const std\+::vector$<$ T $>$ \&v, std\+::vector$<$ size\+\_\+t $>$ \&index)
\begin{DoxyCompactList}\small\item\em Find the indexes that sort a vector in descending order. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_abd8109e832d4f887939cbaef421a101d}\label{namespace_utilities_abd8109e832d4f887939cbaef421a101d}} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries apply\+\_\+permutation} (T $\ast$vec, const std\+::vector$<$ std\+::size\+\_\+t $>$ \&p)
\item 
\mbox{\Hypertarget{namespace_utilities_a173a48bc6f7d6968101fca85c6998043}\label{namespace_utilities_a173a48bc6f7d6968101fca85c6998043}} 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries apply\+\_\+permutation} (std\+::vector$<$ T $>$ \&vec, const std\+::vector$<$ std\+::size\+\_\+t $>$ \&p)
\item 
std\+::valarray$<$ double $>$ \mbox{\hyperlink{namespace_utilities_a1faf43d7dba91cb2697307c22249bc12}{Adaptive\+Smooth}} (const std\+::valarray$<$ double $>$ \&map\+\_\+in, size\+\_\+t Nx, size\+\_\+t Ny, double value)
\begin{DoxyCompactList}\small\item\em Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. \end{DoxyCompactList}\item 
std\+::vector$<$ double $>$ \mbox{\hyperlink{namespace_utilities_a144a1a0d2b8ea76c952f10b4a5f45369}{Adaptive\+Smooth}} (const std\+::vector$<$ double $>$ \&map\+\_\+in, size\+\_\+t Nx, size\+\_\+t Ny, double value)
\begin{DoxyCompactList}\small\item\em Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_afa654746e24cd77549f412bed8d3ee26}\label{namespace_utilities_afa654746e24cd77549f412bed8d3ee26}} 
int \mbox{\hyperlink{namespace_utilities_afa654746e24cd77549f412bed8d3ee26}{Get\+N\+Threads}} ()
\begin{DoxyCompactList}\small\item\em returns the compiler variable N\+\_\+\+T\+H\+R\+E\+A\+DS that is maximum number of threads to be used. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_acede0e6fa297e5d2f12c89724110bc25}\label{namespace_utilities_acede0e6fa297e5d2f12c89724110bc25}} 
void \mbox{\hyperlink{namespace_utilities_acede0e6fa297e5d2f12c89724110bc25}{splitstring}} (std\+::string \&line, std\+::vector$<$ std\+::string $>$ \&vec, const std\+::string \&delimiter)
\begin{DoxyCompactList}\small\item\em split string into vector of seporate strings that were seporated by \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_ae358b58a950d75ef089c7ad73f37a080}\label{namespace_utilities_ae358b58a950d75ef089c7ad73f37a080}} 
bool {\bfseries xorderD} (double $\ast$p1, double $\ast$p2)
\item 
\mbox{\Hypertarget{namespace_utilities_a5baa3e10d9b962622365a0916fb0fa01}\label{namespace_utilities_a5baa3e10d9b962622365a0916fb0fa01}} 
bool {\bfseries yorderD} (double $\ast$p1, double $\ast$p2)
\item 
\mbox{\Hypertarget{namespace_utilities_af495d1ed407458779abf8694a2e4cda2}\label{namespace_utilities_af495d1ed407458779abf8694a2e4cda2}} 
long \mbox{\hyperlink{namespace_utilities_af495d1ed407458779abf8694a2e4cda2}{Index\+From\+Position}} (Pos\+Type $\ast$x, long Nx, long Ny, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, const Pos\+Type $\ast$center)
\begin{DoxyCompactList}\small\item\em this is the nonsquare version of the function, it will return -\/1 is outside of region \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_a043901fd09c24707f46eb23b75548882}\label{namespace_utilities_a043901fd09c24707f46eb23b75548882}} 
void \mbox{\hyperlink{namespace_utilities_a043901fd09c24707f46eb23b75548882}{Position\+From\+Index}} (unsigned long i, Pos\+Type $\ast$x, long Nx, long Ny, Pos\+Type \mbox{\hyperlink{namespace_utilities_ae60664d77331b21da7b83e6e0cc0c75c}{range}}, Pos\+Type const $\ast$center)
\begin{DoxyCompactList}\small\item\em This should work for square or rectangular regions as long as Npixels and range are the x-\/axis values and the pixels are square. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace_utilities_aa9581800c9d5adc2444440dac76de955}\label{namespace_utilities_aa9581800c9d5adc2444440dac76de955}} 
const double {\bfseries n\+Xbin} =64.
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}

\begin{DoxyItemize}
\item 
\end{DoxyItemize}

The \mbox{\hyperlink{namespace_utilities}{Utilities}} namespace contains functions for wide use in many classes that perform generic tasks.

convert a Band type to a string name.


\begin{DoxyItemize}
\item \textbackslash{}ing\+Einstein\+\_\+roup Change\+Lens
\item \textbackslash{}ing\+Einstein\+\_\+roup Change\+Lens
\item The two functions below are inverses of each other for converting between a 1d array index and a square grid of positions Npixels in the number of point is 1 dimension index is between 0 and Npixels$\ast$\+Npixels-\/1 If x is outside of the region -\/1 is returned. 
\end{DoxyItemize}

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespace_utilities_a1faf43d7dba91cb2697307c22249bc12}\label{namespace_utilities_a1faf43d7dba91cb2697307c22249bc12}} 
\index{Utilities@{Utilities}!AdaptiveSmooth@{AdaptiveSmooth}}
\index{AdaptiveSmooth@{AdaptiveSmooth}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{AdaptiveSmooth()}{AdaptiveSmooth()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::valarray$<$ double $>$ Utilities\+::\+Adaptive\+Smooth (\begin{DoxyParamCaption}\item[{const std\+::valarray$<$ double $>$ \&}]{map\+\_\+in,  }\item[{size\+\_\+t}]{Nx,  }\item[{size\+\_\+t}]{Ny,  }\item[{double}]{value }\end{DoxyParamCaption})}



Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. 

The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)$\ast$(number of neighbours) an approximate N nearest neighbour smoothing is done. The \mbox{\Hypertarget{namespace_utilities_a144a1a0d2b8ea76c952f10b4a5f45369}\label{namespace_utilities_a144a1a0d2b8ea76c952f10b4a5f45369}} 
\index{Utilities@{Utilities}!AdaptiveSmooth@{AdaptiveSmooth}}
\index{AdaptiveSmooth@{AdaptiveSmooth}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{AdaptiveSmooth()}{AdaptiveSmooth()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$ double $>$ Utilities\+::\+Adaptive\+Smooth (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ double $>$ \&}]{map\+\_\+in,  }\item[{size\+\_\+t}]{Nx,  }\item[{size\+\_\+t}]{Ny,  }\item[{double}]{value }\end{DoxyParamCaption})}



Smooth a 2 dimensional map stored in a valarray with a density dependent kernel. 

The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)$\ast$(number of neighbours) an approximate N nearest neighbour smoothing is done.

The smoothing is done by finding the circle around each point whose total pixel values are larger than value. In the case of a density map made from particles if value = (mass of particle)$\ast$(number of neighbours) an approximate N nearest neighbour smoothing is done. The \mbox{\Hypertarget{namespace_utilities_a6d17c2495bead70b18b91c376c28c051}\label{namespace_utilities_a6d17c2495bead70b18b91c376c28c051}} 
\index{Utilities@{Utilities}!concave@{concave}}
\index{concave@{concave}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave()}{concave()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::concave (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{init\+\_\+points,  }\item[{std\+::vector$<$ T $>$ \&}]{hull\+\_\+out,  }\item[{double}]{scale }\end{DoxyParamCaption})}



Creates the concave hull of a group of 2 dimensional points by the shrink-\/wrap algorithm. 

The type of the input vector points must have an operator \mbox{[}\mbox{]}. If the input vector is the same as the output vector it will be replaced, and the function will still work.

It is guaranteed that the resulting hull will surround the all the points. Any edge that is greater than scale will be refined until it is either smaller than scale or it cannot be refined further. As a result some edges might be larger than scale and some smaller.

This should be a NlogN algorithm.

The algorithm\+: 1) The convex hull is found. 2) The longest edge is found 3) all the points that are not in the hull are tested to see if they are within the rays extending from the end point perpendicular to the edge. 4) Of the points that are the one that makes the smallest area triangle with the end points is chosen and added 5) go back to 3 if there are edges that are larger than scale and new points exist to be added 6) remove all intersections in the hull \mbox{\Hypertarget{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4}\label{namespace_utilities_afadfff44acbcae923eac1bec385ae6e4}} 
\index{Utilities@{Utilities}!concave\_hull@{concave\_hull}}
\index{concave\_hull@{concave\_hull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave\_hull()}{concave\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$ double $\ast$ $>$ Utilities\+::concave\+\_\+hull (\begin{DoxyParamCaption}\item[{std\+::vector$<$ double $\ast$ $>$ \&}]{P,  }\item[{int}]{k }\end{DoxyParamCaption})}



Returns a vector of points on the convcave hull in counter-\/clockwise order. 

This uses a K-\/nearest neighbour adapted from Moreira \& Santos (G\+R\+A\+PP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered.

This is an overloaded version of the other \mbox{\hyperlink{namespace_utilities_aca82634714ad53172788a38cef165b07}{concave\+\_\+hull()}} \mbox{\Hypertarget{namespace_utilities_aca82634714ad53172788a38cef165b07}\label{namespace_utilities_aca82634714ad53172788a38cef165b07}} 
\index{Utilities@{Utilities}!concave\_hull@{concave\_hull}}
\index{concave\_hull@{concave\_hull}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{concave\_hull()}{concave\_hull()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ Utilities\+::concave\+\_\+hull (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $\ast$ $>$ \&}]{P,  }\item[{int}]{k,  }\item[{bool}]{test = {\ttfamily false} }\end{DoxyParamCaption})}



Returns a vector of points on the convcave hull in counter-\/clockwise order. 

This uses a K-\/nearest neighbour adapted from Moreira \& Santos (G\+R\+A\+PP 2007 conference proceedings). This is a modified gift wrap algorithm using k neighbours. The value of k will automatically increase when certain special cases are encountered. \mbox{\Hypertarget{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}\label{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}} 
\index{Utilities@{Utilities}!contour\_center@{contour\_center}}
\index{contour\_center@{contour\_center}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{contour\_center()}{contour\_center()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} Utilities\+::contour\+\_\+center (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{P,  }\item[{unsigned long}]{Npoints }\end{DoxyParamCaption})}



Returns the center of a contour defined as the midpoint between the two points in the contour that are farthest apart from one another. 

The performance of the algorithm is $\sim$\+O(\+N$^\wedge$2). Less naive methods go like O(\+N) at best. Most commonly a combined convex hull plus rotating calipers algorithm is used. Since we have the convex\+\_\+hull already, we only need to implement the latter algorithm. \mbox{\Hypertarget{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d}\label{namespace_utilities_ac71ef3b7c0383a2ca61eb5d479d8490d}} 
\index{Utilities@{Utilities}!contour\_ellipse@{contour\_ellipse}}
\index{contour\_ellipse@{contour\_ellipse}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{contour\_ellipse()}{contour\_ellipse()}}
{\footnotesize\ttfamily void Utilities\+::contour\+\_\+ellipse (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{P,  }\item[{\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}}}]{center,  }\item[{unsigned long}]{Npoints,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{C,  }\item[{double $\ast$}]{ellipticity,  }\item[{double $\ast$}]{ellipse\+\_\+area }\end{DoxyParamCaption})}



Returns axis ratio, area and points of an ellipse engulfed by some contour (e.\+g. a contour of same convergence calculated with find\+\_\+contour). 

The axis ratio of the ellipse b/a is equal to the ratio of the distances between center and the nearest contour point (i.\+e. b) and between center and the farthest contour point (i.\+e. a). N\+O\+TE that the center used to calculate a and b is an input parameter. The definition of the center is crucial to the meaning of above output parameters. The center of the convex\+\_\+hull produces for even slightly distorted hulls significant offsets resulting in overestimated major axis values (a). The function \mbox{\hyperlink{namespace_utilities_a512d73667d76a5a58e44042a4a73c974}{Utilities\+::contour\+\_\+center()}} calculates the center as the midpoint between the two points in the contour that are farthest apart from one another, which gives already more reliable results. The output vector describing the ellipse is resized to match the size of the contour vector. \mbox{\Hypertarget{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0}\label{namespace_utilities_a865c4f1f38a91d8b3d4e07fdfea16bd0}} 
\index{Utilities@{Utilities}!ConvexHullArea@{ConvexHullArea}}
\index{ConvexHullArea@{ConvexHullArea}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{ConvexHullArea()}{ConvexHullArea()}}
{\footnotesize\ttfamily Pos\+Type Utilities\+::\+Convex\+Hull\+Area (\begin{DoxyParamCaption}\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$}]{curve }\end{DoxyParamCaption})}



Replaces curve with its convex hull. The number of points will change. 

gives the area within the convex hull of the curve \mbox{\Hypertarget{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2}\label{namespace_utilities_a484765a953bdbceb52b23f6790d59cf2}} 
\index{Utilities@{Utilities}!double\_sort\_points@{double\_sort\_points}}
\index{double\_sort\_points@{double\_sort\_points}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{double\_sort\_points()}{double\_sort\_points()}}
{\footnotesize\ttfamily void Utilities\+::double\+\_\+sort\+\_\+points (\begin{DoxyParamCaption}\item[{unsigned long}]{n,  }\item[{Pos\+Type $\ast$}]{arr,  }\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$}]{brr }\end{DoxyParamCaption})}



Sorts points in a point array. 

arr array uses NR standard indexing i.\+e arr\mbox{[}1...n\mbox{]} but brr\mbox{[}0..n-\/1\mbox{]} if the point array is two-\/way-\/coupled to another point array the image pointers of that array will follow sort if the array is not two-\/way-\/coupled to another the image pointers in the other array will be untouched \mbox{\Hypertarget{namespace_utilities_a380f0a954728d751781e61918facba0e}\label{namespace_utilities_a380f0a954728d751781e61918facba0e}} 
\index{Utilities@{Utilities}!fill\_linear@{fill\_linear}}
\index{fill\_linear@{fill\_linear}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{fill\_linear()}{fill\_linear()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void Utilities\+::fill\+\_\+linear (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{size\+\_\+t}]{n,  }\item[{T}]{min,  }\item[{T}]{max }\end{DoxyParamCaption})}

Fills a vector with equidistant points from \mbox{[}min, max\mbox{]}. \mbox{\Hypertarget{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a}\label{namespace_utilities_a47aedfd83edf6f6637cc03da5413e94a}} 
\index{Utilities@{Utilities}!fill\_logarithmic@{fill\_logarithmic}}
\index{fill\_logarithmic@{fill\_logarithmic}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{fill\_logarithmic()}{fill\_logarithmic()}}
{\footnotesize\ttfamily template$<$class T $>$ \\
void Utilities\+::fill\+\_\+logarithmic (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{v,  }\item[{size\+\_\+t}]{n,  }\item[{T}]{min,  }\item[{T}]{max }\end{DoxyParamCaption})}

Fills a vector with logarithmically equidistant points from \mbox{[}min, max\mbox{]}. \mbox{\Hypertarget{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e}\label{namespace_utilities_af5c6f9e86e55bf8ac250ed8a2849ba3e}} 
\index{Utilities@{Utilities}!InterpolateYvec@{InterpolateYvec}}
\index{InterpolateYvec@{InterpolateYvec}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{InterpolateYvec()}{InterpolateYvec()}}
{\footnotesize\ttfamily Pos\+Type Utilities\+::\+Interpolate\+Yvec (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{x,  }\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{y,  }\item[{Pos\+Type}]{xi }\end{DoxyParamCaption})}

Interpolate (cubic interpolation) the value of a function $ y=y(x) $ given xi \mbox{\Hypertarget{namespace_utilities_a74edb07bfa2d5cee2ef5450f0998ff57}\label{namespace_utilities_a74edb07bfa2d5cee2ef5450f0998ff57}} 
\index{Utilities@{Utilities}!LoadFitsImages@{LoadFitsImages}}
\index{LoadFitsImages@{LoadFitsImages}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{LoadFitsImages()}{LoadFitsImages()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Utilities\+::\+Load\+Fits\+Images (\begin{DoxyParamCaption}\item[{std\+::string}]{dir,  }\item[{const std\+::string \&}]{filespec,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} $>$ \&}]{images,  }\item[{int}]{maxN,  }\item[{double}]{resolution = {\ttfamily -\/1},  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}



Reads all the fits files in a directory into a vector of Pixel\+Maps. 

The input fits files must have .fits in their names in addition to the string filespec. 
\begin{DoxyParams}{Parameters}
{\em dir} & path to directory containing fits files \\
\hline
{\em filespec} & string of charactors in fits file name that are matched \\
\hline
{\em images} & output vector of Pixel\+Maps \\
\hline
{\em maxN} & maximum number of images that will be read in \\
\hline
{\em resolution} & resolution (rad) of fits image if not given in fits file, use default or -\/1 otherwise \\
\hline
{\em verbose} & lists files to stdout \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_ad3f190fa0f0cac4eb4b7c981d5131e5d}\label{namespace_utilities_ad3f190fa0f0cac4eb4b7c981d5131e5d}} 
\index{Utilities@{Utilities}!LoadFitsImages@{LoadFitsImages}}
\index{LoadFitsImages@{LoadFitsImages}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{LoadFitsImages()}{LoadFitsImages()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Utilities\+::\+Load\+Fits\+Images (\begin{DoxyParamCaption}\item[{std\+::string}]{dir,  }\item[{std\+::vector$<$ std\+::string $>$}]{filespecs,  }\item[{std\+::vector$<$ std\+::string $>$}]{file\+\_\+non\+\_\+specs,  }\item[{std\+::vector$<$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} $>$ \&}]{images,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{names,  }\item[{int}]{maxN,  }\item[{double}]{resolution = {\ttfamily -\/1},  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}



Reads all the fits files in a directory into a vector of Pixel\+Maps. 

The input fits files must have .fits in their names in addition to the string filespec. 
\begin{DoxyParams}{Parameters}
{\em dir} & path to directory containing fits files \\
\hline
{\em filespecs} & string of charactors in fits file name that are matched \\
\hline
{\em file\+\_\+non\+\_\+specs} & string of charactors in fits file name cannot have \\
\hline
{\em images} & output vector of Pixel\+Maps \\
\hline
{\em names} & file names \\
\hline
{\em maxN} & maximum number of images that will be read in \\
\hline
{\em resolution} & resolution (rad) of fits image if not given in fits file, use default or -\/1 otherwise \\
\hline
{\em verbose} & lists files to stdout \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_acc053736fab41bd2807991e8dfcab129}\label{namespace_utilities_acc053736fab41bd2807991e8dfcab129}} 
\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
size\+\_\+t Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{const std\+::vector$<$ size\+\_\+t $>$ \&}]{sorted\+\_\+index,  }\item[{T}]{value,  }\item[{size\+\_\+t \&}]{rank }\end{DoxyParamCaption})}



Finds the element of a vector given a sorted index of the vector. 

The vector v does not need to be sorted, but the index does with Utiltites\+::sort\+\_\+index(), Utilities\+::sort\+\_\+index\+\_\+decending() or in some other way.

returns the index of v that is the largest value that is $<$= value 
\begin{DoxyParams}{Parameters}
{\em v} & vector to search, does not need to be sorted \\
\hline
{\em sorted\+\_\+index} & sorted index for v, could be assending or decending \\
\hline
{\em value} & value to be matched \\
\hline
{\em rank} & index in sorted\+\_\+index \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e}\label{namespace_utilities_a929db80c547c245b0d2c2703f33ff85e}} 
\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$class T $>$ \\
long Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{const T}]{x }\end{DoxyParamCaption})}

Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -\/1 or n-\/1. \mbox{\Hypertarget{namespace_utilities_ab7663a1f094849a77cab564e61fcca49}\label{namespace_utilities_ab7663a1f094849a77cab564e61fcca49}} 
\index{Utilities@{Utilities}!locate@{locate}}
\index{locate@{locate}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{locate()}{locate()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$class T , class F $>$ \\
long Utilities\+::locate (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{F}]{x,  }\item[{std\+::function$<$ bool(F, const T \&)$>$}]{less\+\_\+than }\end{DoxyParamCaption})}

Locates the element of the given vector which, together with the following element, brackets the given number. If x is smaller than the smallest entry or larger than the largest, the result is either -\/1 or n-\/1. \mbox{\Hypertarget{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98}\label{namespace_utilities_afb7f32cbe2c0f17c06a106dee6726e98}} 
\index{Utilities@{Utilities}!nintegrateF@{nintegrateF}}
\index{nintegrateF@{nintegrateF}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{nintegrateF()}{nintegrateF()}}
{\footnotesize\ttfamily template$<$typename Functor\+Type , typename T  = double$>$ \\
T Utilities\+::nintegrateF (\begin{DoxyParamCaption}\item[{Functor\+Type}]{func,  }\item[{T}]{a,  }\item[{T}]{b,  }\item[{T}]{tols }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em func} & struct or class to be integrated \\
\hline
{\em a} & limit of integrations \\
\hline
{\em b} & limit of integrations \\
\hline
{\em tols} & target fractional error \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7}\label{namespace_utilities_af2fb3cc522fc36c51e33bccac70089c7}} 
\index{Utilities@{Utilities}!order\_curve4@{order\_curve4}}
\index{order\_curve4@{order\_curve4}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{order\_curve4()}{order\_curve4()}}
{\footnotesize\ttfamily unsigned long Utilities\+::order\+\_\+curve4 (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$}]{curve,  }\item[{long}]{Npoints }\end{DoxyParamCaption})}



Orders points on a closed curve. 

The algorithm first finds the \char`\"{}center\char`\"{} of the curve. It then does a rough ordering according to the angle around this center. It then walks the curve jumping to a neighbor cell each step choosing a neighbor along one of the x or y-\/axis before taking a diagonal step. If it comes to the point where there is no more neighbors (as may occur after going through a self-\/intersection and then returning to it) the algorithm backtracks until it finds a point in the ordered list that is also a neighbor to a point in the not yet ordered list and attaches this to the end of the ordered list and continuous to walk. This algorithm works well at finding a closed loop. It can cut off points from the curve that are either in loops or if four cells intersect and are all on the curve as can happen when there is a lot of structure in the curve that is not resolved at the gridsize used. The points that are cut off are at the end of the array in no guaranteed order.

Returns the number of point that have been ordered -\/ total number minus the cuttout points.

This algorithm could be improve by inserting the remaining points, if any, into the existing curve and recursively calling itself. \mbox{\Hypertarget{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41}\label{namespace_utilities_ad8293f72cb05db408c84e3d101a56e41}} 
\index{Utilities@{Utilities}!order\_curve5@{order\_curve5}}
\index{order\_curve5@{order\_curve5}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{order\_curve5()}{order\_curve5()}}
{\footnotesize\ttfamily unsigned long Utilities\+::order\+\_\+curve5 (\begin{DoxyParamCaption}\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$}]{curve }\end{DoxyParamCaption})}



For odering the curve by the convex hull method. Warning\+: Does not work very well. 

The convex hull is found for the points in the kist. Then each additional point is inserted into the curve where it will increase the length of the curve the least. This method leaves loops where they shouldn\textquotesingle{}t be and probably doesn\textquotesingle{}t handle self-\/intersections well. \mbox{\Hypertarget{namespace_utilities_abe61342a713adf7115f351e3342a2b79}\label{namespace_utilities_abe61342a713adf7115f351e3342a2b79}} 
\index{Utilities@{Utilities}!prevpower@{prevpower}}
\index{prevpower@{prevpower}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{prevpower()}{prevpower()}}
{\footnotesize\ttfamily unsigned long Utilities\+::prevpower (\begin{DoxyParamCaption}\item[{unsigned long}]{k }\end{DoxyParamCaption})}

This function finds the largest power of 2 that is $<$ k \mbox{\Hypertarget{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a}\label{namespace_utilities_ac980fbca67c1ca7531d28e98433e669a}} 
\index{Utilities@{Utilities}!quicksortPoints\_multithread@{quicksortPoints\_multithread}}
\index{quicksortPoints\_multithread@{quicksortPoints\_multithread}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{quicksortPoints\_multithread()}{quicksortPoints\_multithread()}}
{\footnotesize\ttfamily template$<$int lev$>$ \\
void Utilities\+::quicksort\+Points\+\_\+multithread (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$}]{pointarray,  }\item[{double($\ast$)(\mbox{\hyperlink{struct_point}{Point}} \&)}]{func,  }\item[{unsigned long}]{N,  }\item[{int}]{level = {\ttfamily 0} }\end{DoxyParamCaption})}



Multi-\/threaded quicksort. The maximum number of threads used is 2$^\wedge$lev. The function {\ttfamily func} takes a point and returns the value that is should be sorted by. The last parameter should be left out when calling so that it takes the default value. 

This function is different from \mbox{\hyperlink{namespace_utilities_ac7ddbf6268cb6f39b3e6d1b046ff1a48}{quicksort\+\_\+multithread()}} in that it uses Swap\+Points\+In\+Array() instead of std\+::swap() which is needed to make the image pointers follow the swap. \mbox{\Hypertarget{namespace_utilities_a0855636bdb71f103a4412555b9711e98}\label{namespace_utilities_a0855636bdb71f103a4412555b9711e98}} 
\index{Utilities@{Utilities}!RandomFromTable@{RandomFromTable}}
\index{RandomFromTable@{RandomFromTable}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{RandomFromTable()}{RandomFromTable()}}
{\footnotesize\ttfamily Pos\+Type Utilities\+::\+Random\+From\+Table (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{table,  }\item[{unsigned long}]{Ntable,  }\item[{long $\ast$}]{seed }\end{DoxyParamCaption})}



Generates a random deviates drawn f\+Einstein\+\_\+rom app\+Einstein\+\_\+roximately the same as the values of table. 

\textbackslash{}ing\+Einstein\+\_\+roup Utill \mbox{\Hypertarget{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2}\label{namespace_utilities_abc7be26dfecdca30048dd4d3842077a2}} 
\index{Utilities@{Utilities}!ReadFileNames@{ReadFileNames}}
\index{ReadFileNames@{ReadFileNames}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{ReadFileNames()}{ReadFileNames()}}
{\footnotesize\ttfamily void Utilities\+::\+Read\+File\+Names (\begin{DoxyParamCaption}\item[{std\+::string}]{dir,  }\item[{const std\+::string}]{filespec,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{filenames,  }\item[{const std\+::string}]{file\+\_\+non\+\_\+spec = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em dir} & path to directory containing fits files \\
\hline
{\em filespec} & string of charactors in file name that are matched. It can be an empty string. \\
\hline
{\em filenames} & output vector of Pixel\+Maps \\
\hline
{\em file\+\_\+non\+\_\+spec} & string of charactors in file name that file must not have. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c}\label{namespace_utilities_aa9906f7f742a4940019f2a58cabdb05c}} 
\index{Utilities@{Utilities}!shuffle@{shuffle}}
\index{shuffle@{shuffle}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{shuffle()}{shuffle()}}
{\footnotesize\ttfamily template$<$typename T , typename R $>$ \\
void Utilities\+::shuffle (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{vec,  }\item[{R \&}]{ran }\end{DoxyParamCaption})}



Shuffles a vector into a random order. 


\begin{DoxyParams}{Parameters}
{\em vec} & The vector to be shuffled \\
\hline
{\em ran} & a random number generator so that ran() gives a number between 0 and 1 \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a9b44ff17b26b627e429e9984d4908577}\label{namespace_utilities_a9b44ff17b26b627e429e9984d4908577}} 
\index{Utilities@{Utilities}!sort\_indexes@{sort\_indexes}}
\index{sort\_indexes@{sort\_indexes}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes()}{sort\_indexes()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index }\end{DoxyParamCaption})}



Find the indexes that sort a vector in asending order. 


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a357b69312972120ce046eff265e6b581}\label{namespace_utilities_a357b69312972120ce046eff265e6b581}} 
\index{Utilities@{Utilities}!sort\_indexes@{sort\_indexes}}
\index{sort\_indexes@{sort\_indexes}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes()}{sort\_indexes()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes (\begin{DoxyParamCaption}\item[{const T $\ast$}]{v,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index,  }\item[{size\+\_\+t}]{N }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe}\label{namespace_utilities_aec9c85bddb9c124c7df2bc04fbf350fe}} 
\index{Utilities@{Utilities}!sort\_indexes\_decending@{sort\_indexes\_decending}}
\index{sort\_indexes\_decending@{sort\_indexes\_decending}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{sort\_indexes\_decending()}{sort\_indexes\_decending()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::sort\+\_\+indexes\+\_\+decending (\begin{DoxyParamCaption}\item[{const std\+::vector$<$ T $>$ \&}]{v,  }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{index }\end{DoxyParamCaption})}



Find the indexes that sort a vector in descending order. 


\begin{DoxyParams}{Parameters}
{\em v} & the original data that is not changed \\
\hline
{\em index} & vector of indexes that if put into v will sort it \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104}\label{namespace_utilities_a2d063fcd59fdf742b8cbf0c57ef29104}} 
\index{Utilities@{Utilities}!TwoDInterpolator@{TwoDInterpolator}}
\index{TwoDInterpolator@{TwoDInterpolator}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{TwoDInterpolator()}{TwoDInterpolator()}}
{\footnotesize\ttfamily Pos\+Type Utilities\+::\+Two\+D\+Interpolator (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{x,  }\item[{int}]{Npixels,  }\item[{Pos\+Type}]{range,  }\item[{Pos\+Type $\ast$}]{center,  }\item[{Pos\+Type $\ast$}]{map,  }\item[{bool}]{init }\end{DoxyParamCaption})}



bilinear interpolation from a map. 

Out of bounds points return 0. map is a i dimensional array representing a 2 dimensional map. Don\textquotesingle{}t use init. After it is used once, later calls can use Two\+D\+Interpolator(\+Pos\+Type $\ast$map) for the same point in the same coordinate system to save time in calculating the indexes. bilinear interpolation

bilinear interpolation\mbox{\Hypertarget{namespace_utilities_a64cd4e52a3b543449c6ba0330f13f01e}\label{namespace_utilities_a64cd4e52a3b543449c6ba0330f13f01e}} 
\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily int Utilities\+::windings (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&}]{x,  }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&}]{point,  }\item[{Pos\+Type $\ast$}]{area }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \mbox{\hyperlink{struct_point}{Point}} for which the winding number is calculated \\
\hline
{\em point} & The points on the border. These must be ordered. \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa}\label{namespace_utilities_aa7db30634cbf18e1652cd2a9ec7f95aa}} 
\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{x,  }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ $\ast$}]{kist,  }\item[{Pos\+Type $\ast$}]{area,  }\item[{short}]{image = {\ttfamily 0} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \mbox{\hyperlink{struct_point}{Point}} for which the winding number is calculated \\
\hline
{\em kist} & Kist of points on the border. These must be ordered. \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa}\label{namespace_utilities_ad964e6781b61f0d76240eda24a4f9ffa}} 
\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{x,  }\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$$\ast$}]{points,  }\item[{unsigned long}]{Npoints,  }\item[{Pos\+Type $\ast$}]{area,  }\item[{short}]{image = {\ttfamily 0} }\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em x} & \mbox{\hyperlink{struct_point}{Point}} for which the winding number is calculated \\
\hline
{\em points} & The points on the border. These must be ordered. \\
\hline
{\em Npoints} & number of points in curve \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_ac42846299720c47decf597f70d448464}\label{namespace_utilities_ac42846299720c47decf597f70d448464}} 
\index{Utilities@{Utilities}!windings@{windings}}
\index{windings@{windings}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings()}{windings()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily int Utilities\+::windings (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{x,  }\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$}]{points,  }\item[{unsigned long}]{Npoints,  }\item[{Pos\+Type $\ast$}]{area,  }\item[{short}]{image }\end{DoxyParamCaption})}



\mbox{\hyperlink{namespace_utilities_ac42846299720c47decf597f70d448464}{windings()}}\+: winding number test for a point in a polygon Returns\+: Number of times a curves winds around the point x. 

The number of times the curve loops around a point is calculated.

The area of a self-\/intersecting curve will be the area of the regions encircled in a clockwise direction minus the regions encircled in a counterclockwise direction -\/ an infinity symbol has zero area. 
\begin{DoxyParams}{Parameters}
{\em x} & \mbox{\hyperlink{struct_point}{Point}} for which the winding number is calculated \\
\hline
{\em points} & The points on the border. These must be ordered. \\
\hline
{\em Npoints} & number of points in curve \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
{\em image} & if == 1 the image of the curve is uses as the curve \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065}\label{namespace_utilities_a70de03dea8a3f77f15fd209a783a8065}} 
\index{Utilities@{Utilities}!windings2@{windings2}}
\index{windings2@{windings2}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{windings2()}{windings2()}}
{\footnotesize\ttfamily int Utilities\+::windings2 (\begin{DoxyParamCaption}\item[{Pos\+Type $\ast$}]{x,  }\item[{\mbox{\hyperlink{struct_point}{Point}} $\ast$}]{points\+\_\+original,  }\item[{unsigned long}]{Npoints,  }\item[{Pos\+Type $\ast$}]{area,  }\item[{short}]{image }\end{DoxyParamCaption})}



determines whether a point is inside a curve, that has been stretched 1.\+2 times returns the area of the stretched curve 


\begin{DoxyParams}{Parameters}
{\em x} & \mbox{\hyperlink{struct_point}{Point}} for which the winding number is calculated \\
\hline
{\em points\+\_\+original} & The points on the border. These must be ordered. \\
\hline
{\em Npoints} & number of points in curve \\
\hline
{\em area} & returns absolute the area within the curve with oriented border \\
\hline
{\em image} & if == 0 the image of the curve is used as the curve \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d}\label{namespace_utilities_a7771b5ff9b3034f364adcee471cb754d}} 
\index{Utilities@{Utilities}!writeCurves@{writeCurves}}
\index{writeCurves@{writeCurves}!Utilities@{Utilities}}
\doxysubsubsection{\texorpdfstring{writeCurves()}{writeCurves()}}
{\footnotesize\ttfamily void Utilities\+::write\+Curves (\begin{DoxyParamCaption}\item[{int}]{m,  }\item[{\mbox{\hyperlink{struct_image_info}{Image\+Info}} $\ast$}]{critical,  }\item[{int}]{Ncrit,  }\item[{int}]{ind\+\_\+caustic }\end{DoxyParamCaption})}

writes in four files the critical curves and the caustics for all the curves found and also for a specified one (ind\+\_\+causic) 
\begin{DoxyParams}{Parameters}
{\em m} & part of te filename, could be the number/index of the main lens \\
\hline
{\em critical} & the crit curve \\
\hline
{\em Ncrit} & the number of crit curves \\
\hline
{\em ind\+\_\+caustic} & the index of the cuvre of interest \\
\hline
\end{DoxyParams}
