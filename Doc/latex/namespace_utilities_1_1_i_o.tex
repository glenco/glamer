\hypertarget{namespace_utilities_1_1_i_o}{}\doxysection{Utilities\+::IO Namespace Reference}
\label{namespace_utilities_1_1_i_o}\index{Utilities::IO@{Utilities::IO}}


namespace for input/output utilities  


\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_ac9fdca8373af48961e696e58f0ccb8ca}\label{namespace_utilities_1_1_i_o_ac9fdca8373af48961e696e58f0ccb8ca}} 
bool {\bfseries file\+\_\+exists} (const std\+::string \&name)
\item 
{\footnotesize template$<$class T1 , class T2 $>$ }\\void \mbox{\hyperlink{namespace_utilities_1_1_i_o_a8186909599387821361b0a5e418a4aff}{read2columnfile}} (std\+::string filename, std\+::vector$<$ T1 $>$ \&x, std\+::vector$<$ T2 $>$ \&y, std\+::string delineator=\char`\"{} \char`\"{}, int skiplines=0, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Read in data from an A\+S\+C\+II file with two columns. \end{DoxyCompactList}\item 
{\footnotesize template$<$class T1 , class T2 , class T3 $>$ }\\void \mbox{\hyperlink{namespace_utilities_1_1_i_o_a246ae00dfe4fd13897551b48bb4d14d0}{read3columnfile}} (std\+::string filename, std\+::vector$<$ T1 $>$ \&x, std\+::vector$<$ T2 $>$ \&y, std\+::vector$<$ T3 $>$ \&z, std\+::string delineator=\char`\"{} \char`\"{}, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Read in data from an A\+S\+C\+II file with three columns. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a5cd7d6292c00bdd0dd519a18ac3c74bf}\label{namespace_utilities_1_1_i_o_a5cd7d6292c00bdd0dd519a18ac3c74bf}} 
int {\bfseries Number\+Of\+Entries} (const std\+::string \&string, char deliniator)
\item 
int \mbox{\hyperlink{namespace_utilities_1_1_i_o_ade63c27fa26dbee97f6182ad188c4efe}{Count\+Columns}} (std\+::string filename, char comment\+\_\+char=\textquotesingle{}\#\textquotesingle{}, char deliniator=\textquotesingle{} \textquotesingle{})
\begin{DoxyCompactList}\small\item\em Count the number of columns in a A\+S\+C\+II data file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{namespace_utilities_1_1_i_o_af6ab01d1aec34ac1000f3551d43a76fa}{Read\+File\+Names}} (std\+::string dir, const std\+::string filespec, std\+::vector$<$ std\+::string $>$ \&filenames, bool verbose)
\begin{DoxyCompactList}\small\item\em Reads the file names in a directory that contain a specific sub string. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{namespace_utilities_1_1_i_o_ad361d43d9a51c81897c51286e7851318}{check\+\_\+directory}} (std\+::string dir)
\begin{DoxyCompactList}\small\item\em check if the directory does not exist \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_1_1_i_o_a16055c8e93e716d382c1ab590ae8af50}{Read\+A\+S\+C\+II}} (std\+::vector$<$ T $>$ \&data, std\+::string filename, int \&columns, int \&rows, char comment\+\_\+char=\textquotesingle{}\#\textquotesingle{}, int skiplines=0, size\+\_\+t Max\+Nrows=std\+::numeric\+\_\+limits$<$ size\+\_\+t $>$\+::max(), bool verbose=true)
\begin{DoxyCompactList}\small\item\em This function will read in all the numbers from a multi-\/column ,space seporated A\+S\+C\+II data file. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\int \mbox{\hyperlink{namespace_utilities_1_1_i_o_a8597a573645e6a6ad34d10f6e2012f5f}{Read\+C\+S\+Vnumerical1}} (std\+::string filename, std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&data, std\+::vector$<$ std\+::string $>$ \&column\+\_\+names, size\+\_\+t Max\+Number=100000000, char comment\+\_\+char=\textquotesingle{}\#\textquotesingle{}, char deliniator=\textquotesingle{},\textquotesingle{}, std\+::string replace=\char`\"{}\textbackslash{}\textbackslash{}N\char`\"{}, std\+::function$<$ bool(std\+::vector$<$ T $>$ \&)$>$ accept=\mbox{[}$\,$\mbox{]}(std\+::vector$<$ T $>$ \&v)\{return true;\})
\begin{DoxyCompactList}\small\item\em Read numerical data from a csv file with a header. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\size\+\_\+t \mbox{\hyperlink{namespace_utilities_1_1_i_o_a886b91155319834d24830299427a5487}{Read\+C\+S\+Vrange}} (std\+::string filename, std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&ranges, std\+::vector$<$ std\+::string $>$ \&column\+\_\+names, size\+\_\+t Max\+Number=100000000, char comment\+\_\+char=\textquotesingle{}\#\textquotesingle{}, char deliniator=\textquotesingle{},\textquotesingle{}, std\+::string replace=\char`\"{}\textbackslash{}\textbackslash{}N\char`\"{}, std\+::function$<$ bool(std\+::vector$<$ T $>$ \&)$>$ accept=\mbox{[}$\,$\mbox{]}(std\+::vector$<$ T $>$ \&v)\{return true;\})
\item 
{\footnotesize template$<$typename T $>$ }\\int \mbox{\hyperlink{namespace_utilities_1_1_i_o_a87af057cfa24bbecad73674659de0011}{Read\+C\+S\+Vnumerical2}} (std\+::string filename, std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&data, std\+::vector$<$ std\+::string $>$ \&column\+\_\+names, size\+\_\+t Nmax=1000000, char comment\+\_\+char=\textquotesingle{}\#\textquotesingle{}, char deliniator=\textquotesingle{},\textquotesingle{}, bool header=true, std\+::string reject=\char`\"{}\char`\"{})
\begin{DoxyCompactList}\small\item\em Read numerical data from a csv file with a header. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{namespace_utilities_1_1_i_o_acf2176f27ea6d9eb5430f8862d226b6c}{write\+C\+SV}} (const std\+::string filename, const std\+::vector$<$ std\+::string $>$ header, std\+::vector$<$ T $\ast$ $>$ \&data)
\begin{DoxyCompactList}\small\item\em write a C\+SV data file for some data vectors \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
namespace for input/output utilities 

\doxysubsection{Function Documentation}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_ad361d43d9a51c81897c51286e7851318}\label{namespace_utilities_1_1_i_o_ad361d43d9a51c81897c51286e7851318}} 
\index{Utilities::IO@{Utilities::IO}!check\_directory@{check\_directory}}
\index{check\_directory@{check\_directory}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{check\_directory()}{check\_directory()}}
{\footnotesize\ttfamily bool Utilities\+::\+I\+O\+::check\+\_\+directory (\begin{DoxyParamCaption}\item[{std\+::string}]{dir }\end{DoxyParamCaption})}



check if the directory does not exist 

throws a runtime error if the directory does not exist \mbox{\Hypertarget{namespace_utilities_1_1_i_o_ade63c27fa26dbee97f6182ad188c4efe}\label{namespace_utilities_1_1_i_o_ade63c27fa26dbee97f6182ad188c4efe}} 
\index{Utilities::IO@{Utilities::IO}!CountColumns@{CountColumns}}
\index{CountColumns@{CountColumns}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{CountColumns()}{CountColumns()}}
{\footnotesize\ttfamily int Utilities\+::\+I\+O\+::\+Count\+Columns (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{char}]{comment\+\_\+char = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{char}]{deliniator = {\ttfamily \textquotesingle{}~\textquotesingle{}} }\end{DoxyParamCaption})}



Count the number of columns in a A\+S\+C\+II data file. 


\begin{DoxyParams}{Parameters}
{\em filename} & name of file \\
\hline
{\em comment\+\_\+char} & comment charactor \\
\hline
{\em deliniator} & deliniator between columns \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a8186909599387821361b0a5e418a4aff}\label{namespace_utilities_1_1_i_o_a8186909599387821361b0a5e418a4aff}} 
\index{Utilities::IO@{Utilities::IO}!read2columnfile@{read2columnfile}}
\index{read2columnfile@{read2columnfile}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{read2columnfile()}{read2columnfile()}}
{\footnotesize\ttfamily template$<$class T1 , class T2 $>$ \\
void Utilities\+::\+I\+O\+::read2columnfile (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{std\+::vector$<$ T1 $>$ \&}]{x,  }\item[{std\+::vector$<$ T2 $>$ \&}]{y,  }\item[{std\+::string}]{delineator = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{int}]{skiplines = {\ttfamily 0},  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}



Read in data from an A\+S\+C\+II file with two columns. 


\begin{DoxyParams}{Parameters}
{\em filename} & input file name \\
\hline
{\em x} & vector that will contain the first column \\
\hline
{\em y} & vector that will contain the second column \\
\hline
{\em delineator} & specific string the seporates columns, ex. \char`\"{},\char`\"{}, \char`\"{}$\vert$\char`\"{}, etc. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a246ae00dfe4fd13897551b48bb4d14d0}\label{namespace_utilities_1_1_i_o_a246ae00dfe4fd13897551b48bb4d14d0}} 
\index{Utilities::IO@{Utilities::IO}!read3columnfile@{read3columnfile}}
\index{read3columnfile@{read3columnfile}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{read3columnfile()}{read3columnfile()}}
{\footnotesize\ttfamily template$<$class T1 , class T2 , class T3 $>$ \\
void Utilities\+::\+I\+O\+::read3columnfile (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{std\+::vector$<$ T1 $>$ \&}]{x,  }\item[{std\+::vector$<$ T2 $>$ \&}]{y,  }\item[{std\+::vector$<$ T3 $>$ \&}]{z,  }\item[{std\+::string}]{delineator = {\ttfamily \char`\"{}~\char`\"{}},  }\item[{bool}]{verbose = {\ttfamily false} }\end{DoxyParamCaption})}



Read in data from an A\+S\+C\+II file with three columns. 


\begin{DoxyParams}{Parameters}
{\em filename} & input file name \\
\hline
{\em x} & vector that will contain the first column \\
\hline
{\em y} & vector that will contain the second column \\
\hline
{\em z} & vector that will contain the third column \\
\hline
{\em delineator} & specific string the seporates columns, ex. \char`\"{},\char`\"{}, \char`\"{}$\vert$\char`\"{}, etc. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a16055c8e93e716d382c1ab590ae8af50}\label{namespace_utilities_1_1_i_o_a16055c8e93e716d382c1ab590ae8af50}} 
\index{Utilities::IO@{Utilities::IO}!ReadASCII@{ReadASCII}}
\index{ReadASCII@{ReadASCII}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{ReadASCII()}{ReadASCII()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::\+I\+O\+::\+Read\+A\+S\+C\+II (\begin{DoxyParamCaption}\item[{std\+::vector$<$ T $>$ \&}]{data,  }\item[{std\+::string}]{filename,  }\item[{int \&}]{columns,  }\item[{int \&}]{rows,  }\item[{char}]{comment\+\_\+char = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{int}]{skiplines = {\ttfamily 0},  }\item[{size\+\_\+t}]{Max\+Nrows = {\ttfamily std\+:\+:numeric\+\_\+limits$<$size\+\_\+t$>$\+:\+:max()},  }\item[{bool}]{verbose = {\ttfamily true} }\end{DoxyParamCaption})}



This function will read in all the numbers from a multi-\/column ,space seporated A\+S\+C\+II data file. 

It will skip the comment lines if they are at the head of the file. The number of columns and rows are returned. The entry at row r and column c will be stored at data\mbox{[}c + column$\ast$r\mbox{]}.

This function is not particularly fast for large amounts of data. If the number of roaws is large it would be best to use data.\+reserve() to set the capacity of data large enough that no rellocation of memory occurs. \mbox{\Hypertarget{namespace_utilities_1_1_i_o_a8597a573645e6a6ad34d10f6e2012f5f}\label{namespace_utilities_1_1_i_o_a8597a573645e6a6ad34d10f6e2012f5f}} 
\index{Utilities::IO@{Utilities::IO}!ReadCSVnumerical1@{ReadCSVnumerical1}}
\index{ReadCSVnumerical1@{ReadCSVnumerical1}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{ReadCSVnumerical1()}{ReadCSVnumerical1()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int Utilities\+::\+I\+O\+::\+Read\+C\+S\+Vnumerical1 (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{data,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{column\+\_\+names,  }\item[{size\+\_\+t}]{Max\+Number = {\ttfamily 100000000},  }\item[{char}]{comment\+\_\+char = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{char}]{deliniator = {\ttfamily \textquotesingle{},\textquotesingle{}},  }\item[{std\+::string}]{replace = {\ttfamily \char`\"{}\textbackslash{}\textbackslash{}N\char`\"{}},  }\item[{std\+::function$<$ bool(std\+::vector$<$ T $>$ \&)$>$}]{accept = {\ttfamily \mbox{[}\mbox{]}(std\+:\+:vector$<$T$>$~\&v)\{return~true;\}} }\end{DoxyParamCaption})}



Read numerical data from a csv file with a header. 

It will skip the comment lines if they are at the head of the file. The number of columns and rows are returned. The entries will be stored at data\mbox{[}column\mbox{]}\mbox{[}row\mbox{]}.

Comments must only be before the data. There must be a line with the column names after the comments and before the data.

This function is not particularly fast for large amounts of data. If the number of rows is large it would be best to use data.\+reserve() to set the capacity of data large enough that no rellocation of memory occurs.

The accept function can be used to limit the amount of data added. If there is an object, a, used to make this selection this can be done like \mbox{[}\&a\mbox{]}(str\+::vector$<$\+T$>$ \&v\}\{return a.\+itsok(v\mbox{[}3\mbox{]},v\mbox{[}4\mbox{]});\} where v corresponds to a row in the data file in order. return to first data line

clean blank spaces
\begin{DoxyParams}{Parameters}
{\em filename} & file name to be read \\
\hline
{\em data} & output data \\
\hline
{\em column\+\_\+names} & list of column names \\
\hline
{\em Max\+Number} & maximum number of entries read \\
\hline
{\em comment\+\_\+char} & comment charactor for header \\
\hline
{\em deliniator} & deliniator between values \\
\hline
{\em replace} & replace this string with zero \\
\hline
{\em accept} & function that determines if a row should be accepted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a87af057cfa24bbecad73674659de0011}\label{namespace_utilities_1_1_i_o_a87af057cfa24bbecad73674659de0011}} 
\index{Utilities::IO@{Utilities::IO}!ReadCSVnumerical2@{ReadCSVnumerical2}}
\index{ReadCSVnumerical2@{ReadCSVnumerical2}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{ReadCSVnumerical2()}{ReadCSVnumerical2()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
int Utilities\+::\+I\+O\+::\+Read\+C\+S\+Vnumerical2 (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{data,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{column\+\_\+names,  }\item[{size\+\_\+t}]{Nmax = {\ttfamily 1000000},  }\item[{char}]{comment\+\_\+char = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{char}]{deliniator = {\ttfamily \textquotesingle{},\textquotesingle{}},  }\item[{bool}]{header = {\ttfamily true},  }\item[{std\+::string}]{reject = {\ttfamily \char`\"{}\char`\"{}} }\end{DoxyParamCaption})}



Read numerical data from a csv file with a header. 

Same as Read\+C\+S\+Vnumerical1 except the order of the data storage is reversed data\mbox{[}row\mbox{]}\mbox{[}column\mbox{]}.

It will skip the comment lines if they are at the head of the file. The number of columns and rows are returned.

Comments must only be before the data. Then if header==true there should be a line of column names. If header!=true there are non column names.

This function is not particularly fast for large amounts of data. If the number of rows is large it would be best to use data.\+reserve() to set the capacity of data large enough that no rellocation of memory occurs. clean blank spaces
\begin{DoxyParams}{Parameters}
{\em filename} & file name to be read \\
\hline
{\em data} & output data \\
\hline
{\em column\+\_\+names} & list of column names \\
\hline
{\em comment\+\_\+char} & comment charactor for header \\
\hline
{\em deliniator} & deliniator between values \\
\hline
{\em header} & false if there are no column names \\
\hline
{\em reject} & reject lines with this entry after striping black space \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_a886b91155319834d24830299427a5487}\label{namespace_utilities_1_1_i_o_a886b91155319834d24830299427a5487}} 
\index{Utilities::IO@{Utilities::IO}!ReadCSVrange@{ReadCSVrange}}
\index{ReadCSVrange@{ReadCSVrange}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{ReadCSVrange()}{ReadCSVrange()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
size\+\_\+t Utilities\+::\+I\+O\+::\+Read\+C\+S\+Vrange (\begin{DoxyParamCaption}\item[{std\+::string}]{filename,  }\item[{std\+::vector$<$ std\+::vector$<$ T $>$ $>$ \&}]{ranges,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{column\+\_\+names,  }\item[{size\+\_\+t}]{Max\+Number = {\ttfamily 100000000},  }\item[{char}]{comment\+\_\+char = {\ttfamily \textquotesingle{}\#\textquotesingle{}},  }\item[{char}]{deliniator = {\ttfamily \textquotesingle{},\textquotesingle{}},  }\item[{std\+::string}]{replace = {\ttfamily \char`\"{}\textbackslash{}\textbackslash{}N\char`\"{}},  }\item[{std\+::function$<$ bool(std\+::vector$<$ T $>$ \&)$>$}]{accept = {\ttfamily \mbox{[}\mbox{]}(std\+:\+:vector$<$T$>$~\&v)\{return~true;\}} }\end{DoxyParamCaption})}

Finds ranges return to first data line

clean blank spaces
\begin{DoxyParams}{Parameters}
{\em filename} & file name to be read \\
\hline
{\em ranges} & output data \\
\hline
{\em column\+\_\+names} & list of column names \\
\hline
{\em Max\+Number} & maximum number of entries read \\
\hline
{\em comment\+\_\+char} & comment charactor for header \\
\hline
{\em deliniator} & deliniator between values \\
\hline
{\em replace} & replace this string with zero \\
\hline
{\em accept} & function that determines if a row should be accepted \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_af6ab01d1aec34ac1000f3551d43a76fa}\label{namespace_utilities_1_1_i_o_af6ab01d1aec34ac1000f3551d43a76fa}} 
\index{Utilities::IO@{Utilities::IO}!ReadFileNames@{ReadFileNames}}
\index{ReadFileNames@{ReadFileNames}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{ReadFileNames()}{ReadFileNames()}}
{\footnotesize\ttfamily void Utilities\+::\+I\+O\+::\+Read\+File\+Names (\begin{DoxyParamCaption}\item[{std\+::string}]{dir,  }\item[{const std\+::string}]{filespec,  }\item[{std\+::vector$<$ std\+::string $>$ \&}]{filenames,  }\item[{bool}]{verbose }\end{DoxyParamCaption})}



Reads the file names in a directory that contain a specific sub string. 


\begin{DoxyParams}{Parameters}
{\em dir} & path to directory containing fits files \\
\hline
{\em filespec} & string of charactors in file name that are matched. It can be an empty string. \\
\hline
{\em filenames} & output vector of Pixel\+Maps \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{namespace_utilities_1_1_i_o_acf2176f27ea6d9eb5430f8862d226b6c}\label{namespace_utilities_1_1_i_o_acf2176f27ea6d9eb5430f8862d226b6c}} 
\index{Utilities::IO@{Utilities::IO}!writeCSV@{writeCSV}}
\index{writeCSV@{writeCSV}!Utilities::IO@{Utilities::IO}}
\doxysubsubsection{\texorpdfstring{writeCSV()}{writeCSV()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Utilities\+::\+I\+O\+::write\+C\+SV (\begin{DoxyParamCaption}\item[{const std\+::string}]{filename,  }\item[{const std\+::vector$<$ std\+::string $>$}]{header,  }\item[{std\+::vector$<$ T $\ast$ $>$ \&}]{data }\end{DoxyParamCaption})}



write a C\+SV data file for some data vectors 

example\+: 

std\+::vector$<$std\+::string$>$ header = \{\char`\"{}alpha\char`\"{},\char`\"{}kappa\char`\"{},\char`\"{}gamma\char`\"{}\};

std\+::vector$<$double$>$ v1 = \{1,2,3\}; std\+::vector$<$double$>$ v2 = \{1.\+1,2.\+1,3.\+1\}; std\+::vector$<$double$>$ v3 = \{3,4,5\};

std\+::vector$<$std\+::vector$<$double$>$ $\ast$$>$ data; data.\+push\+\_\+back(\&v1); data.\+push\+\_\+back(\&v2); data.\+push\+\_\+back(\&v3); write\+C\+S\+V(filename,header,data); 
\begin{DoxyParams}{Parameters}
{\em filename} & output file path/name \\
\hline
{\em header} & column labels \\
\hline
{\em data} & objects must have operator \mbox{[}\mbox{]} \\
\hline
\end{DoxyParams}
