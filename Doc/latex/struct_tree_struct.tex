\doxysection{Tree\+Struct Struct Reference}
\hypertarget{struct_tree_struct}{}\label{struct_tree_struct}\index{TreeStruct@{TreeStruct}}


Tree\+: Exported struct.  




{\ttfamily \#include $<$Tree.\+h$>$}



Collaboration diagram for Tree\+Struct\+:
% FIG 0
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_tree_struct_1_1iterator}{iterator}}
\begin{DoxyCompactList}\small\item\em A iterator class fore \doxylink{struct_tree_struct}{Tree\+Struct} that allows for movement through the tree without changing anything in the tree itself. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_tree_struct_a20fc537aab17f735ce8c6bac7d95af87}{Tree\+Struct}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}xp, unsigned long Npoints, short my\+\_\+median\+\_\+cut=1, Pos\+Type buffer=0.\+0)
\begin{DoxyCompactList}\small\item\em Build a complete tree from a list of points. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_tree_struct_a578ff026e90846de685d2bee12c2d27b}{Tree\+Struct}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}xp, unsigned long npoints, Pos\+Type boundary\+\_\+p1\mbox{[}2\mbox{]}, Pos\+Type boundary\+\_\+p2\mbox{[}2\mbox{]}, Pos\+Type center\mbox{[}2\mbox{]}, int Nbucket)
\begin{DoxyCompactList}\small\item\em Make a new tree and the linked list of points in it. Does not build the tree structure. The other constructor should be used to build the whole tree. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_a8d2b2eb45f2bc3b172177929f97dee01}\label{struct_tree_struct_a8d2b2eb45f2bc3b172177929f97dee01} 
{\bfseries \texorpdfstring{$\sim$}{\string~}\+Tree\+Struct} ()
\begin{DoxyCompactList}\small\item\em Free tree and the linked list of points in it. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_a49b6885009f3adc0e9e5200d9de091aa}\label{struct_tree_struct_a49b6885009f3adc0e9e5200d9de091aa} 
\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} {\bfseries begin} () const
\item 
\Hypertarget{struct_tree_struct_ad6925efe0946917391afd5858d4b068e}\label{struct_tree_struct_ad6925efe0946917391afd5858d4b068e} 
\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} {\bfseries end} () const
\item 
\Hypertarget{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}\label{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca} 
\mbox{\hyperlink{struct_branch}{Branch}} \texorpdfstring{$\ast$}{*} {\bfseries get\+Top} ()
\begin{DoxyCompactList}\small\item\em root branch \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_tree_struct_a8e33786248bdc48fde6a165b6bfae22f}{Find\+All\+Box\+Neighbors\+Kist}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}point, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}neighbors) const
\begin{DoxyCompactList}\small\item\em Finds all the leaves that are neighboring a point. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_tree_struct_a777de57567ba5beb60b68caedb39edab}{Find\+All\+Box\+Neighbors\+Kist}} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}point, std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&neighbors) const
\begin{DoxyCompactList}\small\item\em Finds all the leaves that are neighboring a point. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{struct_tree_struct_a68145b23b953f705f127410bb125fc79}{Points\+Within\+Ellip\+Kist}} (const Pos\+Type \texorpdfstring{$\ast$}{*}center, float rmax, float rmin, float posangle, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}neighborkist) const
\begin{DoxyCompactList}\small\item\em Finds points within an ellipse. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{struct_tree_struct_a43e87679f878529623577aae8af1288b}{Points\+Within\+Kist}} (const Pos\+Type \texorpdfstring{$\ast$}{*}center, Pos\+Type rmax, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}neighborkist, short markpoints) const
\begin{DoxyCompactList}\small\item\em Finds all points in tree that lie within rmax of the point ray\mbox{[}\mbox{]}. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_a36a2c24eb61beee51be40c0624b459dd}\label{struct_tree_struct_a36a2c24eb61beee51be40c0624b459dd} 
void {\bfseries Points\+Within\+Kist\+\_\+iter} (const Pos\+Type \texorpdfstring{$\ast$}{*}center, float rmin, float rmax, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}neighborkist) const
\begin{DoxyCompactList}\small\item\em Finds all points within a circle. Much simpler, iterative algorithm. \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_tree_struct_ad5a40088ed454c0fb84073653e317a4f}{Nearest\+Neighbor\+Kist}} (const Pos\+Type \texorpdfstring{$\ast$}{*}center, int Nneighbors, Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}neighborkist) const
\begin{DoxyCompactList}\small\item\em Finds nearest neighbor points to ray. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_a567260adb1b9753c70b336ff38791341}\label{struct_tree_struct_a567260adb1b9753c70b336ff38791341} 
bool {\bfseries At\+Edge} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}point)
\begin{DoxyCompactList}\small\item\em true is point is on the edge of the field \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_acec8b0dc4a3a18fda4f3feef690923ca}\label{struct_tree_struct_acec8b0dc4a3a18fda4f3feef690923ca} 
bool {\bfseries Test} ()
\item 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_tree_struct_a5258c95f4de87c75e74ce9d4e59e888e}{Remove\+Leaf\+From\+Tree}} (\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} \&current, unsigned long \texorpdfstring{$\ast$}{*}Npoints)
\begin{DoxyCompactList}\small\item\em Prune off points that are below a resolution and in an annulus on the source plane. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_a76668d1516ab7ddb2b7cdefa470d3419}\label{struct_tree_struct_a76668d1516ab7ddb2b7cdefa470d3419} 
void {\bfseries Fill\+Tree} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}xp, unsigned long Npoints)
\begin{DoxyCompactList}\small\item\em Fill a tree with points. The previous tree structure will be destroyed. Used for refilling. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_aa57c8f27fb818e4c45e75cfda1cee0ec}\label{struct_tree_struct_aa57c8f27fb818e4c45e75cfda1cee0ec} 
int {\bfseries Add\+Points\+To\+Tree} (\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}xpoint, unsigned long Nadd)
\begin{DoxyCompactList}\small\item\em Expands tree by adding points. \end{DoxyCompactList}\item 
short \mbox{\hyperlink{struct_tree_struct_a22011842bc8af6c0770f23e4cf192a87}{empty\+Tree}} ()
\begin{DoxyCompactList}\small\item\em Spawn a subtree with current as its top. \end{DoxyCompactList}\item 
\Hypertarget{struct_tree_struct_aa07ffc0660e4f26705e9ebe38bd53957}\label{struct_tree_struct_aa07ffc0660e4f26705e9ebe38bd53957} 
bool {\bfseries is\+Empty} ()
\item 
\Hypertarget{struct_tree_struct_afc7d7d8b0b849f94f90c3aaa6dd37f0f}\label{struct_tree_struct_afc7d7d8b0b849f94f90c3aaa6dd37f0f} 
unsigned long {\bfseries get\+Nbranches} ()
\item 
\Hypertarget{struct_tree_struct_a1681e1caa459748eab374612e92cc2e9}\label{struct_tree_struct_a1681e1caa459748eab374612e92cc2e9} 
void {\bfseries print\+Tree} (\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} \&current)
\item 
\Hypertarget{struct_tree_struct_acc821cf873426c96b9f43fa0427ce0a0}\label{struct_tree_struct_acc821cf873426c96b9f43fa0427ce0a0} 
void {\bfseries check\+Tree} ()
\item 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{struct_tree_struct_a230c70e5a72e2ae2d30ff3cc159a3e87}{Find\+Box\+Point}} (const Pos\+Type \texorpdfstring{$\ast$}{*}ray) const
\item 
void \mbox{\hyperlink{struct_tree_struct_a05a6a26bae725392d290cdfa0220e7f0}{\+\_\+\+Find\+Leaf}} (\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} \&current, const Pos\+Type \texorpdfstring{$\ast$}{*}ray, unsigned long Nadd=0) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_tree_struct_a18020df556ff80dedecd9425afe72d24}\label{struct_tree_struct_a18020df556ff80dedecd9425afe72d24} 
\mbox{\hyperlink{struct_point_list}{Point\+List}} {\bfseries pointlist}
\begin{DoxyCompactList}\small\item\em list of points \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_tree_struct_adc9ac615fe5048e81da2e7be2cf7975f}\label{struct_tree_struct_adc9ac615fe5048e81da2e7be2cf7975f} 
static std\+::mutex {\bfseries mutex}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Tree\+: Exported struct. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{struct_tree_struct_a20fc537aab17f735ce8c6bac7d95af87}\index{TreeStruct@{TreeStruct}!TreeStruct@{TreeStruct}}
\index{TreeStruct@{TreeStruct}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{TreeStruct()}{TreeStruct()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{struct_tree_struct_a20fc537aab17f735ce8c6bac7d95af87} 
Tree\+Struct\+::\+Tree\+Struct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{xp}{, }\item[{unsigned long}]{Npoints}{, }\item[{short}]{my\+\_\+median\+\_\+cut}{ = {\ttfamily 1}, }\item[{Pos\+Type}]{buffer}{ = {\ttfamily 0.0}}\end{DoxyParamCaption})}



Build a complete tree from a list of points. 

median\+\_\+cut determines how the cells are subdivided if ==0 equal volume cuts, Warning this option causes an error if ==1 pseudo-\/median point cuts, never cuts through a point, but near the median \texorpdfstring{$<$}{<}{\ttfamily } \texorpdfstring{$>$}{>} \Hypertarget{struct_tree_struct_a578ff026e90846de685d2bee12c2d27b}\index{TreeStruct@{TreeStruct}!TreeStruct@{TreeStruct}}
\index{TreeStruct@{TreeStruct}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{TreeStruct()}{TreeStruct()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{struct_tree_struct_a578ff026e90846de685d2bee12c2d27b} 
Tree\+Struct\+::\+Tree\+Struct (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{xp}{, }\item[{unsigned long}]{npoints}{, }\item[{Pos\+Type}]{boundary\+\_\+p1}{\mbox{[}2\mbox{]}, }\item[{Pos\+Type}]{boundary\+\_\+p2}{\mbox{[}2\mbox{]}, }\item[{Pos\+Type}]{center}{\mbox{[}2\mbox{]}, }\item[{int}]{my\+\_\+\+Nbucket}{}\end{DoxyParamCaption})}



Make a new tree and the linked list of points in it. Does not build the tree structure. The other constructor should be used to build the whole tree. 


\begin{DoxyParams}{Parameters}
{\em xp} & array of points to be added to the tree  \\
\hline
{\em npoints} & number of points  \\
\hline
{\em boundary\+\_\+p1} & bottom left hand corner of root  \\
\hline
{\em boundary\+\_\+p2} & upper right hand corner of root  \\
\hline
{\em center} & center of root (this could be the center of mass)  \\
\hline
{\em my\+\_\+\+Nbucket} & maximum number of points allowed in a leaf \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{struct_tree_struct_a05a6a26bae725392d290cdfa0220e7f0}\index{TreeStruct@{TreeStruct}!\_FindLeaf@{\_FindLeaf}}
\index{\_FindLeaf@{\_FindLeaf}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{\_FindLeaf()}{\_FindLeaf()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a05a6a26bae725392d290cdfa0220e7f0} 
void Tree\+Struct\+::\+\_\+\+Find\+Leaf (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} \&}]{current}{, }\item[{const Pos\+Type \texorpdfstring{$\ast$}{*}}]{ray}{, }\item[{unsigned long}]{Nadd}{ = {\ttfamily 0}}\end{DoxyParamCaption}) const}

Finds the leaf the ray is in and adds Nadd to all of is parent leaves \Hypertarget{struct_tree_struct_a22011842bc8af6c0770f23e4cf192a87}\index{TreeStruct@{TreeStruct}!emptyTree@{emptyTree}}
\index{emptyTree@{emptyTree}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{emptyTree()}{emptyTree()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a22011842bc8af6c0770f23e4cf192a87} 
short Tree\+Struct\+::empty\+Tree (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}



Spawn a subtree with current as its top. 

The new tree contains all of the tree below the current. Warning\+:\+: Adding points to the new tree will not update the parent tree so it can become dangerously out of sync.

Empty tree of all point leaving a tree with an empty root.

The points are not freed, and the list structure is not destroyed.

Fill\+Tree can then be used to regenerate tree. \Hypertarget{struct_tree_struct_a8e33786248bdc48fde6a165b6bfae22f}\index{TreeStruct@{TreeStruct}!FindAllBoxNeighborsKist@{FindAllBoxNeighborsKist}}
\index{FindAllBoxNeighborsKist@{FindAllBoxNeighborsKist}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{FindAllBoxNeighborsKist()}{FindAllBoxNeighborsKist()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{struct_tree_struct_a8e33786248bdc48fde6a165b6bfae22f} 
void Tree\+Struct\+::\+Find\+All\+Box\+Neighbors\+Kist (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{point}{, }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{neighbors}{}\end{DoxyParamCaption}) const}



Finds all the leaves that are neighboring a point. 

Points outside of grid have no box neighbors Warning\+: Does not take empty leaves into account. \Hypertarget{struct_tree_struct_a777de57567ba5beb60b68caedb39edab}\index{TreeStruct@{TreeStruct}!FindAllBoxNeighborsKist@{FindAllBoxNeighborsKist}}
\index{FindAllBoxNeighborsKist@{FindAllBoxNeighborsKist}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{FindAllBoxNeighborsKist()}{FindAllBoxNeighborsKist()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{struct_tree_struct_a777de57567ba5beb60b68caedb39edab} 
void Tree\+Struct\+::\+Find\+All\+Box\+Neighbors\+Kist (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*}}]{point}{, }\item[{std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ \&}]{neighbors}{}\end{DoxyParamCaption}) const}



Finds all the leaves that are neighboring a point. 

Points outside of grid have no box neighbors Warning\+: Does not take empty leaves into account. \Hypertarget{struct_tree_struct_a230c70e5a72e2ae2d30ff3cc159a3e87}\index{TreeStruct@{TreeStruct}!FindBoxPoint@{FindBoxPoint}}
\index{FindBoxPoint@{FindBoxPoint}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{FindBoxPoint()}{FindBoxPoint()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a230c70e5a72e2ae2d30ff3cc159a3e87} 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} Tree\+Struct\+::\+Find\+Box\+Point (\begin{DoxyParamCaption}\item[{const Pos\+Type \texorpdfstring{$\ast$}{*}}]{ray}{}\end{DoxyParamCaption}) const}

return a pointer to the point that is in the same box as ray\mbox{[}2\mbox{]} if Nbuck \texorpdfstring{$>$}{>} 1 the head of the point array is returned

Memory \Hypertarget{struct_tree_struct_ad5a40088ed454c0fb84073653e317a4f}\index{TreeStruct@{TreeStruct}!NearestNeighborKist@{NearestNeighborKist}}
\index{NearestNeighborKist@{NearestNeighborKist}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{NearestNeighborKist()}{NearestNeighborKist()}}
{\footnotesize\ttfamily \label{struct_tree_struct_ad5a40088ed454c0fb84073653e317a4f} 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} Tree\+Struct\+::\+Nearest\+Neighbor\+Kist (\begin{DoxyParamCaption}\item[{const Pos\+Type \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{int}]{Nneighbors}{, }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{neighborkist}{}\end{DoxyParamCaption}) const}



Finds nearest neighbor points to ray. 

This is a kludge that relies on Nearest\+Neighbor which uses a List and translates the list to a kist. Could be rewritten.

Warning\+: The number of neighbor points in neighborkist will be less than Nneighbors when the number of points in the tree is less than Nneighbors \Hypertarget{struct_tree_struct_a68145b23b953f705f127410bb125fc79}\index{TreeStruct@{TreeStruct}!PointsWithinEllipKist@{PointsWithinEllipKist}}
\index{PointsWithinEllipKist@{PointsWithinEllipKist}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{PointsWithinEllipKist()}{PointsWithinEllipKist()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a68145b23b953f705f127410bb125fc79} 
void Tree\+Struct\+::\+Points\+Within\+Ellip\+Kist (\begin{DoxyParamCaption}\item[{const Pos\+Type \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{float}]{rmax}{, }\item[{float}]{rmin}{, }\item[{float}]{posangle}{, }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{neighborkist}{}\end{DoxyParamCaption}) const}



Finds points within an ellipse. 

This becomes less efficient when the ellipse is very elongated. Could be improved by incorporating the test of it being in the ellipse into the tree walk.

The 
\begin{DoxyParams}{Parameters}
{\em center} & center of ellipse  \\
\hline
{\em rmax} & major axis  \\
\hline
{\em rmin} & minor axis  \\
\hline
{\em posangle} & position angle of major axis, smallest angle between the x-\/axis and the long axis  \\
\hline
{\em neighborkist} & output neighbor kist, will be emptied if it contains anything on entry \\
\hline
\end{DoxyParams}
\Hypertarget{struct_tree_struct_a43e87679f878529623577aae8af1288b}\index{TreeStruct@{TreeStruct}!PointsWithinKist@{PointsWithinKist}}
\index{PointsWithinKist@{PointsWithinKist}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{PointsWithinKist()}{PointsWithinKist()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a43e87679f878529623577aae8af1288b} 
Pos\+Type Tree\+Struct\+::\+Points\+Within\+Kist (\begin{DoxyParamCaption}\item[{const Pos\+Type \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{Pos\+Type}]{rmax}{, }\item[{Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}}]{neighborkist}{, }\item[{short}]{markpoints}{}\end{DoxyParamCaption}) const}



Finds all points in tree that lie within rmax of the point ray\mbox{[}\mbox{]}. 

markpoints = 0 does not change in\+\_\+image variable in any point, gives a list of neighbors = 1 makes in\+\_\+image=YES for all points and their images in image, gives no list of neighbors = -\/1 makes in\+\_\+image=NO for all points in image to reset, gives no list of neighbors

Returns the largest gridsize of the points within the circle. Note that this is the gridsize stored in the point. If finding points on the source plane the i\+\_\+point-\/\texorpdfstring{$>$}{>}gridsize must be set to the same as the image point to get the largest gridsize on the image plane. 
\begin{DoxyParams}{Parameters}
{\em center} & center of circle  \\
\hline
{\em rmax} & radius of circle  \\
\hline
{\em neighborkist} & output neighbor kist, will be emptied if it contains anything on entry  \\
\hline
{\em markpoints} & see comment \\
\hline
\end{DoxyParams}
\Hypertarget{struct_tree_struct_a5258c95f4de87c75e74ce9d4e59e888e}\index{TreeStruct@{TreeStruct}!RemoveLeafFromTree@{RemoveLeafFromTree}}
\index{RemoveLeafFromTree@{RemoveLeafFromTree}!TreeStruct@{TreeStruct}}
\doxysubsubsection{\texorpdfstring{RemoveLeafFromTree()}{RemoveLeafFromTree()}}
{\footnotesize\ttfamily \label{struct_tree_struct_a5258c95f4de87c75e74ce9d4e59e888e} 
\mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} Tree\+Struct\+::\+Remove\+Leaf\+From\+Tree (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator}} \&}]{current}{, }\item[{unsigned long \texorpdfstring{$\ast$}{*}}]{Npoints}{}\end{DoxyParamCaption})}



Prune off points that are below a resolution and in an annulus on the source plane. 

\begin{DoxyVerb}\brief THIS DOES NOT WORK YET!!!

Reduces the size of the tree by removing points and branches that are no longer needed.
\end{DoxyVerb}


unsigned long Grid\+::\+Prune\+Trees( Pos\+Type resolution /// Maximum size of a cell to be removed. ,bool use\+SB /// If true it will not remove any point that has a flux above fluxlimit. ,Pos\+Type fluxlimit /// flux limit threshold )\{

long i,Ntmp,count = 0; Pos\+Type res,initres; bool go;

assert(trashkist);

if(i\+\_\+tree == NULL) return 0; if(s\+\_\+tree == NULL) return 0;

Ntmp = i\+\_\+tree-\/\texorpdfstring{$>$}{>}pointlist.\+size();

i\+\_\+tree-\/\texorpdfstring{$>$}{>}move\+Top();

\doxylink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator} i\+\_\+tree\+\_\+current(i\+\_\+tree); Point\+List\+::iterator i\+\_\+tree\+\_\+pointlist\+\_\+current;

initres = (i\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]}-\/i\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]}); if(resolution \texorpdfstring{$>$}{>} initres/3 \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} resolution \texorpdfstring{$<$}{<}= 0.\+0) return 0; // do not allow pruning up to the initial grid size

walk tree i=0; go = true; do\{ assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}next \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}prev);

res = ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]}-\/(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]}); if( (res \texorpdfstring{$<$}{<}= resolution \&\& i\+\_\+tree\+\_\+current.\+Is\+Square\+Branch() ) \&\& (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined)\{

if(use\+SB)\{ go = true; Check if surface brightness of all points in cell are zero. i\+\_\+tree\+\_\+pointlist\+\_\+current = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points; for(i=0; i \texorpdfstring{$<$}{<} (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints;++i,--i\+\_\+tree\+\_\+pointlist\+\_\+current )\{ if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}surface\+\_\+brightness\texorpdfstring{$\ast$}{*}pow((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}gridsize,2) \texorpdfstring{$>$}{>} fluxlimit )\{ go = false; break; \} \} \}

remove all lower branches and make current a leaf if(go \&\& (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints \texorpdfstring{$>$}{>} 1)\{

count += Free\+Branches\+Below(i\+\_\+tree\+\_\+current,i\+\_\+tree,s\+\_\+tree,trashkist); \} \} \}while(i\+\_\+tree\+\_\+current.\+Tree\+Walk\+Step(true));

rebuild source tree from list. if(count $>$ 0) Rebuild\+Tree\+From\+List(s\+\_\+tree);

assert(count == (Ntmp -\/ i\+\_\+tree-\/\texorpdfstring{$>$}{>}pointlist.\+size()) );

return count; \}

Used to keep the number of grid points limited while telescoping.

The points that are removed have cells that do not overlap the inner circle and centers that are within the outer circle. Thus some points will be outside of the inner circle and some cells that are not removed may intersect with the outer circle.

unsigned long Grid\+::\+Prune\+Points\+Outside( Pos\+Type resolution /// Maximum size of a cell to be removed. ,Pos\+Type \texorpdfstring{$\ast$}{*}y /// Center on source plane ,Pos\+Type r\+\_\+in /// Inner radius of annulus on the source plane ,Pos\+Type r\+\_\+out /// Outer radius of annulus on the source plane )\{

if(i\+\_\+tree == NULL) return 0; if(s\+\_\+tree == NULL) return 0; if(r\+\_\+in \texorpdfstring{$>$}{>} r\+\_\+out \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} resolution \texorpdfstring{$<$}{<}= 0) return 0; if(r\+\_\+out \texorpdfstring{$<$}{<}= 0.\+0) return 0.\+0;

Pos\+Type res,dr2;

long i,count = 0; \doxylink{struct_point}{Point} \texorpdfstring{$\ast$}{*}point; \doxylink{struct_branch}{Branch} \texorpdfstring{$\ast$}{*}branch; Kist$<$\+Point$>$ \texorpdfstring{$\ast$}{*} subkist = new Kist$<$\+Point$>$; bool go = true; unsigned long Ntmp; Unit \texorpdfstring{$\ast$}{*}unit;

assert(trashkist);

Make a kist of all points in the annulus. Points\+Within\+Kist(s\+\_\+tree,y,r\+\_\+out+resolution,subkist,0); s\+\_\+tree-\/\texorpdfstring{$>$}{>}Points\+Within\+Kist\+\_\+iter(y,r\+\_\+in,r\+\_\+out+resolution,subkist);

std\+::printf("{}number of points after Points\+Within \%li\textbackslash{}n"{},subkist-\/\texorpdfstring{$>$}{>}Nunits());

if(r\+\_\+in $>$ 0)\{ take out points that are within inner circle subkist-\/\texorpdfstring{$>$}{>}Move\+To\+Top(); Ntmp = subkist-\/\texorpdfstring{$>$}{>}Nunits(); for(i=0;i\texorpdfstring{$<$}{<}Ntmp;++i)\{ go = true; point = subkist-\/\texorpdfstring{$>$}{>}get\+Current(); if(point-\/\texorpdfstring{$>$}{>}gridsize\texorpdfstring{$\ast$}{*}\+Ngrid\+\_\+block \texorpdfstring{$>$}{>} resolution)\{ if(subkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; subkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); \}else if( Utilities\+::cutbox(y,point-\/\texorpdfstring{$>$}{>}leaf-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1,point-\/\texorpdfstring{$>$}{>}leaf-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2,r\+\_\+in) )\{ if(subkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; subkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); \}

if(go) subkist-\/\texorpdfstring{$>$}{>}Down(); \} \} std\+::printf("{}number of points after culling \%li\textbackslash{}n"{},subkist-\/\texorpdfstring{$>$}{>}Nunits());

if(subkist-\/\texorpdfstring{$>$}{>}Nunits() == 0)\{ delete subkist; return 0; \}

move from source plane to image plane subkist-\/\texorpdfstring{$>$}{>}Tranform\+Planes(); \begin{DoxyVerb} TreeStruct::iterator i_tree_current(i_tree);
\end{DoxyVerb}


Take out all points that are not at the center of their parent refined cell subkist-\/\texorpdfstring{$>$}{>}Move\+To\+Top(); Ntmp = subkist-\/\texorpdfstring{$>$}{>}Nunits(); for(i = 0; i \texorpdfstring{$<$}{<} Ntmp ; ++i)\{ go = true; point = subkist-\/\texorpdfstring{$>$}{>}get\+Current(); i\+\_\+tree\+\_\+current = point-\/\texorpdfstring{$>$}{>}leaf; Move up to nearest ancestor that was refined. while(!((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined) \&\& i\+\_\+tree\+\_\+current.\+up() );

res = ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]}-\/(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]});

if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints != Ngrid\+\_\+block\texorpdfstring{$\ast$}{*}\+Ngrid\+\_\+block \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} res \texorpdfstring{$>$}{>} resolution)\{ Take out the point if it is not in a parent block that has been refined than once or if the parent block is about the resolution limit if(subkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; subkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); \}else\{ assert(inbox(point-\/\texorpdfstring{$>$}{>}x,(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1,(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2));

assert(fabs((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}center\mbox{[}0\mbox{]} -\/ ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]}+(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]})/2) \texorpdfstring{$<$}{<} point-\/\texorpdfstring{$>$}{>}gridsize/2); assert(fabs((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}center\mbox{[}1\mbox{]} -\/ ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}1\mbox{]}+(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}1\mbox{]})/2) \texorpdfstring{$<$}{<} point-\/\texorpdfstring{$>$}{>}gridsize/2 ); assert(point-\/\texorpdfstring{$>$}{>}gridsize \texorpdfstring{$<$}{<} fabs((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]}-\/(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]}) ); assert(point-\/\texorpdfstring{$>$}{>}gridsize \texorpdfstring{$<$}{<} fabs((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}1\mbox{]}-\/(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}1\mbox{]}) );

if( (point-\/\texorpdfstring{$>$}{>}gridsize)/2 \texorpdfstring{$<$}{<} fabs(point-\/\texorpdfstring{$>$}{>}x\mbox{[}0\mbox{]} -\/ (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}center\mbox{[}0\mbox{]}) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (point-\/\texorpdfstring{$>$}{>}gridsize)/2 \texorpdfstring{$<$}{<} fabs(point-\/\texorpdfstring{$>$}{>}x\mbox{[}1\mbox{]} -\/ (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}center\mbox{[}1\mbox{]}) )\{ // Take out point if it is not at the center of it\textquotesingle{}s parent block if(subkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; subkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); \} \}

if(go) subkist-\/\texorpdfstring{$>$}{>}Down(); \}

assert(subkist-\/\texorpdfstring{$>$}{>}At\+Bottom());

subkist-\/\texorpdfstring{$>$}{>}Move\+To\+Top(); Point\+List\+::iterator i\+\_\+tree\+\_\+pointlist\+\_\+current; while(subkist-\/\texorpdfstring{$>$}{>}Nunits() \texorpdfstring{$>$}{>} 0)\{ i\+\_\+tree\+\_\+current = subkist-\/\texorpdfstring{$>$}{>}get\+Current()-\/\texorpdfstring{$>$}{>}leaf; Move up to nearest ancestor that was refined. while(!((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined) \&\& i\+\_\+tree\+\_\+current.\+up() );

assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == Ngrid\+\_\+block\texorpdfstring{$\ast$}{*}\+Ngrid\+\_\+block);

make sure that none of the child points are outside the annulus i\+\_\+tree\+\_\+pointlist\+\_\+current = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points; for(i=0;i \texorpdfstring{$<$}{<} Ngrid\+\_\+block\texorpdfstring{$\ast$}{*}\+Ngrid\+\_\+block ; ++i,--i\+\_\+tree\+\_\+pointlist\+\_\+current)\{ dr2 = pow((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}image-\/\texorpdfstring{$>$}{>}x\mbox{[}0\mbox{]} -\/ y\mbox{[}0\mbox{]},2) + pow((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}image-\/\texorpdfstring{$>$}{>}x\mbox{[}1\mbox{]} -\/ y\mbox{[}1\mbox{]},2); if(dr2 \texorpdfstring{$>$}{>} r\+\_\+out\texorpdfstring{$\ast$}{*}r\+\_\+out \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} dr2 \texorpdfstring{$<$}{<} r\+\_\+in\texorpdfstring{$\ast$}{*}r\+\_\+in) break; if(dr2 $<$ r\+\_\+in\texorpdfstring{$\ast$}{*}r\+\_\+in) break; \}

if(i == Ngrid\+\_\+block\texorpdfstring{$\ast$}{*}\+Ngrid\+\_\+block)\{ branch = \texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current;

count += Free\+Branches\+Below(i\+\_\+tree\+\_\+current,i\+\_\+tree,s\+\_\+tree,trashkist);

assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == 1); assert( fabs( 1 -\/ ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]} -\/ (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]})/(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}gridsize) \texorpdfstring{$<$}{<} 1.\+0e-\/4 ); assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined == false);

\}

subkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current();

\}

delete subkist;

return count; \} \begin{DoxyVerb}\brief Empty trash points.

Frees point arrays whose heads are stored in trashlist.
If check=true it will only free arrays where all the points have NULL leafs.
   check=false all the point arrays are freed..
\end{DoxyVerb}


void Collect\+Trash(\+Kist$<$\+Point$>$ \texorpdfstring{$\ast$}{*} trashkist,bool check)\{ bool go; unsigned long i,j,Ntmp; \doxylink{struct_point}{Point} \texorpdfstring{$\ast$}{*}points;

if(trashkist-\/\texorpdfstring{$>$}{>}Nunits() == 0) return;

Ntmp = trashkist-\/\texorpdfstring{$>$}{>}Nunits(); for(j=0,trashkist-\/\texorpdfstring{$>$}{>}Move\+To\+Top();j\texorpdfstring{$<$}{<}Ntmp;++j)\{

if(!(trashkist-\/\texorpdfstring{$>$}{>}get\+Current()-\/\texorpdfstring{$>$}{>}head))\{ // point is not the head of an array if(trashkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; else go = true; trashkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); \}else\{

check to see if all points in the block have been removed from the trees if(check)\{ for(i=0;i\texorpdfstring{$<$}{<}trashkist-\/\texorpdfstring{$>$}{>}get\+Current()-\/\texorpdfstring{$>$}{>}head;++i) if(trashkist-\/\texorpdfstring{$>$}{>}get\+Current()\mbox{[}i\mbox{]}.leaf != NULL) break; \}else\{ i = trashkist-\/\texorpdfstring{$>$}{>}get\+Current()-\/\texorpdfstring{$>$}{>}head; \}

if(i == trashkist-\/\texorpdfstring{$>$}{>}get\+Current()-\/\texorpdfstring{$>$}{>}head)\{ if(trashkist-\/\texorpdfstring{$>$}{>}At\+Top()) go = false; else go = true; points = trashkist-\/\texorpdfstring{$>$}{>}Take\+Out\+Current(); Free\+Point\+Array(points); \}else\{ go = true; \} \}

if(go) trashkist-\/\texorpdfstring{$>$}{>}Down(); \}

return; \}

Frees all branches of the tree below the current branch in i\+\_\+tree if that branch is square and i\+\_\+tree-\/\texorpdfstring{$>$}{>}current-\/\texorpdfstring{$>$}{>}refined == true. If either of these are not true nothing happens.

On exit\+: The i\+\_\+tree-\/\texorpdfstring{$>$}{>}current is back to the original current. If it is square it will have no children and contain one point. The source points and branches are also removed.

unsigned long Free\+Branches\+Below(\+Tree\+Struct\+::iterator \&i\+\_\+tree\+\_\+current,\+Tree\+Hndl i\+\_\+tree,\+Tree\+Hndl s\+\_\+tree,\+Kist$<$\+Point$>$ \texorpdfstring{$\ast$}{*} trashkist)\{

if(!i\+\_\+tree\+\_\+current.Is\+Square\+Branch()) return 0; if(i\+\_\+tree\+\_\+current.\+at\+Leaf()) return 0; if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined == false) return 0;

\doxylink{class_tree_struct_1_1iterator}{Tree\+Struct\+::iterator} s\+\_\+tree\+\_\+current(s\+\_\+tree); assert( s\+\_\+tree !=NULL);

\doxylink{struct_branch}{Branch} \texorpdfstring{$\ast$}{*}branch,\texorpdfstring{$\ast$}{*}headbranch; \doxylink{struct_point}{Point} \texorpdfstring{$\ast$}{*}point; unsigned long Ntmp,Nto\+Remove,i,count = 0,count2 = 0,count1; Pos\+Type center\mbox{[}2\mbox{]}; Point\+List\+::iterator i\+\_\+tree\+\_\+pointlist\+\_\+current; Point\+List\+::iterator s\+\_\+tree\+\_\+pointlist\+\_\+current;

\+\_\+free\+Branches\+\_\+iter(s\+\_\+tree); // s\+\_\+tree will no longer be valid on exit. This is to make sure it isn\textquotesingle{}t used later without a rebuild.

headbranch = \texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current; i\+\_\+tree-\/\texorpdfstring{$>$}{>}Tree\+Walk\+Step(true);

while( (headbranch-\/\texorpdfstring{$>$}{>}child1 != NULL) \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (headbranch-\/\texorpdfstring{$>$}{>}child2 != NULL) )\{

assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch)); if(i\+\_\+tree\+\_\+current.\+at\+Leaf())\{ assert(i\+\_\+tree-\/\texorpdfstring{$>$}{>}current-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}image-\/\texorpdfstring{$>$}{>}leaf); s\+\_\+tree-\/\texorpdfstring{$>$}{>}current = i\+\_\+tree-\/\texorpdfstring{$>$}{>}current-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}image-\/\texorpdfstring{$>$}{>}leaf; // set s\+\_\+tree to source of current image cell

branch = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}prev; i = branch-\/\texorpdfstring{$>$}{>}npoints;

if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current) != headbranch) i\+\_\+tree-\/\texorpdfstring{$>$}{>}Remove\+Leaf\+From\+Tree(i\+\_\+tree\+\_\+current,\&\+Ntmp); \begin{DoxyVerb}                 test line  **************************
\end{DoxyVerb}
 assert(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current == branch); assert(i == (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints); \begin{DoxyVerb}                 test line  **************************
\end{DoxyVerb}
 assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}next \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}prev);

in a square leaf cell take out extra points that have come up from below

if(i\+\_\+tree\+\_\+current.\+at\+Leaf() \&\& (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined)\{ test line \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*} assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}next \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}prev);

std\+::printf("{}  collecting points from removed leaves\textbackslash{}n"{}); assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points); i\+\_\+tree\+\_\+pointlist\+\_\+current = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points; Nto\+Remove = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints; assert(Nto\+Remove == 9); center\mbox{[}0\mbox{]} = ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}0\mbox{]} + (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}0\mbox{]})/2; center\mbox{[}1\mbox{]} = ((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p1\mbox{[}1\mbox{]} + (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}boundary\+\_\+p2\mbox{[}1\mbox{]})/2;

for(i=0,count1=0,count2=0;i\texorpdfstring{$<$}{<}Nto\+Remove;++i,--i\+\_\+tree\+\_\+pointlist\+\_\+current)\{ find central point and remove others \begin{DoxyVerb} if( (pow(center[0]-(*i_tree_pointlist_current)->x[0],2)
  + pow(center[1]-(*i_tree_pointlist_current)->x[1],2) )
  < pow((*i_tree_pointlist_current)->gridsize/2,2) ){

  ++count1;
\end{DoxyVerb}
 keep this central point (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}gridsize \texorpdfstring{$\ast$}{*}= 3; (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}image-\/\texorpdfstring{$>$}{>}gridsize = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}gridsize; (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current); \begin{DoxyVerb}                 test line  **************************
\end{DoxyVerb}
 assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}next \texorpdfstring{$\vert$}{|}\texorpdfstring{$\vert$}{|} (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points-\/\texorpdfstring{$>$}{>}prev); assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}leaf == \texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current); \}else\{

++count; // count of total number of points removed ++count2;

reduce the number of particles in all parent cells

First take points out of source plane This is tricky because they are not ordered into square blocks with 9 points in each.

Take point out of the source plane \begin{DoxyVerb}  assert((*i_tree_pointlist_current)->image);
  point = (*i_tree_pointlist_current)->image;
  assert(point->leaf);
  s_tree_current = point->leaf;
\end{DoxyVerb}
 if((\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints \texorpdfstring{$<$}{<} 2) Remove\+Leaf\+From\+Tree(s\+\_\+tree,\&\+Ntmp); while(!(s\+\_\+tree\+\_\+current.\+at\+Top()))\{ --((\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints); if((\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints \texorpdfstring{$>$}{>} 0 \&\& (\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points == point) (\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = point-\/\texorpdfstring{$>$}{>}next;

if((\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == 0) (\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = NULL;

if((\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == 0 \&\& (\texorpdfstring{$\ast$}{*}s\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}prev-\/\texorpdfstring{$>$}{>}npoints == 1)\{ only remove empty leaves if it will make its parent a leaf assert(s\+\_\+tree\+\_\+current.\+at\+Leaf()); s\+\_\+tree-\/\texorpdfstring{$>$}{>}Remove\+Leaf\+From\+Tree(s\+\_\+tree\+\_\+current,\&\+Ntmp); s\+\_\+tree\+\_\+current.\+Tree\+Walk\+Step(true); // Go to other child. s\+\_\+tree-\/\texorpdfstring{$>$}{>}Remove\+Leaf\+From\+Tree(s\+\_\+tree\+\_\+current,\&\+Ntmp); \}else\{ s\+\_\+tree\+\_\+current.\+up(); \} \} assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

Do it for top --(s\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}npoints); if(s\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}npoints \texorpdfstring{$>$}{>} 0 \&\& s\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}points == point) s\+\_\+tree-\/\texorpdfstring{$>$}{>}\doxylink{struct_tree_struct_acec6d68525f890c9938e2ad4b5e68aca}{get\+Top()}-\/\texorpdfstring{$>$}{>}points = point-\/\texorpdfstring{$>$}{>}next;

s\+\_\+tree\+\_\+pointlist\+\_\+current = point; s\+\_\+tree-\/\texorpdfstring{$>$}{>}pointlist.\+Take\+Out\+Current(s\+\_\+tree\+\_\+pointlist\+\_\+current); point-\/\texorpdfstring{$>$}{>}leaf = NULL; // set leaf to NULL to indicate that point is no longer in tree if(point-\/\texorpdfstring{$>$}{>}head) trashkist-\/\texorpdfstring{$>$}{>}Insert\+After\+Current(point); // collect heads for later trash collection

assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

take points out of image plane branch = \texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current; do\{ assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints); --((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints); if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points == (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)) (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = NULL;

\}while(i\+\_\+tree\+\_\+current.\+up()); i\+\_\+tree\+\_\+current = branch; assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current) == (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points) (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+pointlist\+\_\+current)-\/\texorpdfstring{$>$}{>}next; point = i\+\_\+tree-\/\texorpdfstring{$>$}{>}pointlist.\+Take\+Out\+Current(i\+\_\+tree\+\_\+pointlist\+\_\+current); point-\/\texorpdfstring{$>$}{>}leaf = NULL; If point is a head of a memory block add it to trashlist for eventual trash collection if(point-\/\texorpdfstring{$>$}{>}head)\{ assert(point-\/\texorpdfstring{$>$}{>}head == 8); trashkist-\/\texorpdfstring{$>$}{>}Insert\+After\+Current(point); \} \} assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

\} // loop through points in leaf

reassign first point in branches above the current branch = \texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current; do\{ assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints); if((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points == NULL) (\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points = branch-\/\texorpdfstring{$>$}{>}points; \}while(i\+\_\+tree\+\_\+current.\+up()); i\+\_\+tree\+\_\+current = branch;

assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

assert(count1 == 1); assert(count2 == 8); assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == 1); \} // if current was leaf that was refined

\} // at tree leaf assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}points); assert(boxinbox(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current,headbranch));

if( !(i\+\_\+tree\+\_\+current.\+at\+Leaf()) ) i\+\_\+tree\+\_\+current.\+Tree\+Walk\+Step(true); \} // while entry current is not a leaf

assert(\+Current\+Is\+Square\+Tree(i\+\_\+tree)); assert((\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}npoints == 1); assert(i\+\_\+tree\+\_\+current.\+at\+Leaf()); assert(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current == headbranch);

(\texorpdfstring{$\ast$}{*}i\+\_\+tree\+\_\+current)-\/\texorpdfstring{$>$}{>}refined = false;

Free the memory for the points that have been removed. Collect\+Trash(trashkist,false);

assert(trashkist-\/\texorpdfstring{$>$}{>}Nunits() == 0); if(count) std\+::printf("{}\+Free\+Branches\+Below() freed \%li points and moved up \%li points\textbackslash{}n"{},count,count2); return count; \} Removes current from a tree if it is a leaf. Will not remove root of tree.

on output\+: Current is left at the father of the leaf that was removed. All the points in the leaf that was removed are in its father so the father might be a leaf without Nbucket points. The -\/\texorpdfstring{$>$}{>}leaf pointer of these points are reassigned to the father.

returns\+: Pointer to first in list of points that were reassigned. \texorpdfstring{$\ast$}{*}\+Npoints = number of points reassigned. 

The documentation for this struct was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
SLsim\+Lib/include/Tree.\+h\item 
SLsim\+Lib/\+Tree\+Code\+\_\+link/\mbox{\hyperlink{_kist_driver_8cpp}{Kist\+Driver.\+cpp}}\item 
SLsim\+Lib/\+Tree\+Code\+\_\+link/Tree.\+cpp\item 
SLsim\+Lib/\+Tree\+Code\+\_\+link/tree\+\_\+maintenance.\+cpp\item 
SLsim\+Lib/\+Tree\+Code\+\_\+link/Tree\+Driver.\+cpp\end{DoxyCompactItemize}
