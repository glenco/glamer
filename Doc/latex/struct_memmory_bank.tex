\doxysection{Memmory\+Bank\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Struct Template Reference}
\hypertarget{struct_memmory_bank}{}\label{struct_memmory_bank}\index{MemmoryBank$<$ T $>$@{MemmoryBank$<$ T $>$}}


{\ttfamily \#include $<$point.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{struct_memmory_bank_ac36f2dac0592cee673c7fe775df7c01f}\label{struct_memmory_bank_ac36f2dac0592cee673c7fe775df7c01f} 
{\bfseries Memmory\+Bank} (\mbox{\hyperlink{struct_memmory_bank}{Memmory\+Bank}} \&\&membank)
\item 
\Hypertarget{struct_memmory_bank_aaa49991efb920da655b7bfcbbbd511d6}\label{struct_memmory_bank_aaa49991efb920da655b7bfcbbbd511d6} 
void {\bfseries operator=} (\mbox{\hyperlink{struct_memmory_bank}{Memmory\+Bank}} \&\&membank)
\item 
\Hypertarget{struct_memmory_bank_acc0b8ac1204e45456740d1d5d32078cd}\label{struct_memmory_bank_acc0b8ac1204e45456740d1d5d32078cd} 
T \texorpdfstring{$\ast$}{*} {\bfseries operator()} (size\+\_\+t N)
\item 
\Hypertarget{struct_memmory_bank_a117ca0ac3d7443faf87858586e571317}\label{struct_memmory_bank_a117ca0ac3d7443faf87858586e571317} 
void {\bfseries clear} ()
\item 
\Hypertarget{struct_memmory_bank_ac648a3b8a1ea14d3392dcb0b63d72df0}\label{struct_memmory_bank_ac648a3b8a1ea14d3392dcb0b63d72df0} 
bool {\bfseries clear} (T \texorpdfstring{$\ast$}{*}ptr)
\item 
\Hypertarget{struct_memmory_bank_a6df83324ba88a5afabecd60d1a9dc2ec}\label{struct_memmory_bank_a6df83324ba88a5afabecd60d1a9dc2ec} 
size\+\_\+t {\bfseries number\+\_\+of\+\_\+blocks} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
struct Memmory\+Bank$<$ T $>$}
This is for memory management. It will create pointers to allicated arrays of Ts that will be deleted when the Memmoryt\+Bank goes out of scope. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
SLsim\+Lib/include/point.\+h\end{DoxyCompactItemize}
