\doxysection{Tree\+Force Class Reference}
\hypertarget{class_tree_force}{}\label{class_tree_force}\index{TreeForce@{TreeForce}}


Object used to calculate the force or deflection caused by a collection of "{}particles"{} by the tree method.  




{\ttfamily \#include $<$force\+Tree.\+h$>$}



Inheritance diagram for Tree\+Force\+:
% FIG 0


Collaboration diagram for Tree\+Force\+:
% FIG 1
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_tree_force_adeabe49704610a41cadfa7f04db796a1}{Tree\+Force}} (Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}xp, Index\+Type Npoints, float \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_tree_force_aaf5bfc6384c6717f967d888fbd7fcb24}{masses}}, float \texorpdfstring{$\ast$}{*}\mbox{\hyperlink{class_tree_force_a77be3597cacacfb4c108a32cf3eeed1f}{rsph}}, bool Multimass, bool Multisize, Pos\+Type my\+\_\+kappa\+\_\+background=0, int bucket=5, int dimensions=2, bool median=false, Pos\+Type theta=0.\+1)
\item 
\mbox{\hyperlink{class_tree_force_a1fceae859e1c8badda8437c88cb175f6}{Tree\+Force}} (Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}xp, Index\+Type Npoints, \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \texorpdfstring{$\ast$}{*}my\+\_\+halos, bool Multisize=true, Pos\+Type my\+\_\+kappa\+\_\+bk=0.\+0, int bucket=5, int dimensions=2, bool median=false, Pos\+Type theta=0.\+1)
\item 
\Hypertarget{class_tree_force_af9939e82b46c3b59952adb71a6f4406f}\label{class_tree_force_af9939e82b46c3b59952adb71a6f4406f} 
float \texorpdfstring{$\ast$}{*} {\bfseries Calculate\+SPHsmoothing} (int N)
\begin{DoxyCompactList}\small\item\em calculated sph smoothing and store them in the tree, also provide pointer to them \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_tree_force_a3259836d3275204c9a3a68e10c9da7b2}{force2D}} (Pos\+Type const \texorpdfstring{$\ast$}{*}ray, Pos\+Type \texorpdfstring{$\ast$}{*}alpha, Kappa\+Type \texorpdfstring{$\ast$}{*}kappa, Kappa\+Type \texorpdfstring{$\ast$}{*}gamma, Kappa\+Type \texorpdfstring{$\ast$}{*}phi)
\begin{DoxyCompactList}\small\item\em calculate the deflection and lensing propertie \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{class_tree_simple}{Tree\+Simple$<$ PType $>$}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries Tree\+Simple} (PType \texorpdfstring{$\ast$}{*}xp, Index\+Type Npoints, int bucket=5, int dimensions=2, bool median=true)
\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries Points\+Within\+Circle} (T center\mbox{[}2\mbox{]}, float radius, std\+::list$<$ unsigned long $>$ \&neighborkist)
\begin{DoxyCompactList}\small\item\em Finds the points within a circle around center and puts their index numbers in a list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries Points\+Within\+Ellipse} (T center\mbox{[}2\mbox{]}, float a\+\_\+max, float a\+\_\+min, float posangle, std\+::list$<$ unsigned long $>$ \&neighborkist)
\begin{DoxyCompactList}\small\item\em Finds the points within an ellipse around center and puts their index numbers in a list. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\T \mbox{\hyperlink{class_tree_simple_a679035c518472da2b5ee4349f6098a02}{NNDistance}} (T \texorpdfstring{$\ast$}{*}ray, int Nneighbors) const
\begin{DoxyCompactList}\small\item\em Finds the nearest N neighbors and puts their index numbers in an array, also returns the distance to the Nth neighbor for calculating smoothing. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_tree_simple_a833bd1da5c170273db01a6d1c76f8618}{Points\+Within\+Ellipse}} (T \texorpdfstring{$\ast$}{*}ray, float rmax, float rmin, float posangle, std\+::list$<$ unsigned long $>$ \&neighborlist)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_tree_simple_aa434956ba070e6af6ff8d42938a79716}{Points\+Within\+Circle}} (T \texorpdfstring{$\ast$}{*}ray, float rmax, std\+::list$<$ unsigned long $>$ \&neighborlist)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_tree_force_a40975fd223310857fe6e4efae50190eb}\label{class_tree_force_a40975fd223310857fe6e4efae50190eb} 
void {\bfseries Calc\+Moments} ()
\item 
\Hypertarget{class_tree_force_a4e124dae6aa348df5e7398d68e20d0ec}\label{class_tree_force_a4e124dae6aa348df5e7398d68e20d0ec} 
void {\bfseries rotate\+\_\+coordinates} (Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}coord)
\begin{DoxyCompactList}\small\item\em simple rotates the coordinates in the xp array \end{DoxyCompactList}\item 
\Hypertarget{class_tree_force_a155b70e1721702765af6cbe8934b24c1}\label{class_tree_force_a155b70e1721702765af6cbe8934b24c1} 
virtual Pos\+Type {\bfseries alpha\+\_\+h} (Pos\+Type r2s2, Pos\+Type sigma)
\item 
\Hypertarget{class_tree_force_a0d2fe0bb9b78246e50fd35e66cbe8bdb}\label{class_tree_force_a0d2fe0bb9b78246e50fd35e66cbe8bdb} 
virtual Pos\+Type {\bfseries kappa\+\_\+h} (Pos\+Type r2s2, Pos\+Type sigma)
\item 
\Hypertarget{class_tree_force_a98070fc4a2184a177bf3b7e97dd2b894}\label{class_tree_force_a98070fc4a2184a177bf3b7e97dd2b894} 
virtual Pos\+Type {\bfseries gamma\+\_\+h} (Pos\+Type r2s2, Pos\+Type sigma)
\item 
\Hypertarget{class_tree_force_a2989d4456b539884016138e58654d531}\label{class_tree_force_a2989d4456b539884016138e58654d531} 
virtual Pos\+Type {\bfseries phi\+\_\+o} (Pos\+Type r2, Pos\+Type sigma)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{class_tree_simple}{Tree\+Simple$<$ PType $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*} {\bfseries Build\+Tree\+NB} (PType \texorpdfstring{$\ast$}{*}xxp, Index\+Type Nparticles, Index\+Type \texorpdfstring{$\ast$}{*}particles, int Ndimensions, Pos\+Type theta)
\item 
void {\bfseries \+\_\+\+Build\+Tree\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, Index\+Type nparticles, Index\+Type \texorpdfstring{$\ast$}{*}particles)
\item 
{\footnotesize template$<$typename T $>$ }\\void {\bfseries \+\_\+findleaf} (T \texorpdfstring{$\ast$}{*}ray, Tree\+Simple\+::iterator \&it) const
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_tree_simple_a00689f8ece60bd298e376a1d16dd08da}{\+\_\+\+Points\+Within}} (T \texorpdfstring{$\ast$}{*}ray, float \texorpdfstring{$\ast$}{*}rmax, std\+::list$<$ unsigned long $>$ \&neighborkist)
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_tree_simple_acdaf208f665887ce9d2b6e27005548a7}{\+\_\+\+Nearest\+Neighbors}} (T \texorpdfstring{$\ast$}{*}ray, int Nneighbors, unsigned long \texorpdfstring{$\ast$}{*}neighbors, Pos\+Type \texorpdfstring{$\ast$}{*}rneighbors)
\item 
\mbox{\hyperlink{struct_branch_n_b}{Branch\+NB}} \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{class_tree_simple_a155fe08dba52e39388c12461c6efc304}{New\+Branch\+NB}} (Index\+Type \texorpdfstring{$\ast$}{*}particles, Index\+Type nparticles, Pos\+Type boundary\+\_\+p1\mbox{[}$\,$\mbox{]}, Pos\+Type boundary\+\_\+p2\mbox{[}$\,$\mbox{]}, Pos\+Type center\mbox{[}$\,$\mbox{]}, int level, unsigned long branch\+NBnumber)
\item 
void {\bfseries Free\+Branch\+NB} (\mbox{\hyperlink{struct_branch_n_b}{Branch\+NB}} \texorpdfstring{$\ast$}{*}branch\+NB)
\item 
\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*} {\bfseries New\+Tree\+NB} (Index\+Type \texorpdfstring{$\ast$}{*}particles, Index\+Type nparticles, Pos\+Type boundary\+\_\+p1\mbox{[}$\,$\mbox{]}, Pos\+Type boundary\+\_\+p2\mbox{[}$\,$\mbox{]}, Pos\+Type center\mbox{[}$\,$\mbox{]}, short Ndimensions)
\item 
void {\bfseries free\+Tree\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
short {\bfseries empty\+Tree\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
void {\bfseries \+\_\+free\+Tree\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, short child)
\item 
bool {\bfseries is\+Empty\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
bool {\bfseries at\+Top\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
bool {\bfseries no\+Child\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
bool {\bfseries off\+End\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
void {\bfseries get\+Current\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, Index\+Type \texorpdfstring{$\ast$}{*}particles, Index\+Type \texorpdfstring{$\ast$}{*}nparticles)
\item 
unsigned long {\bfseries get\+Nbranches\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
void {\bfseries move\+Top\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
void {\bfseries move\+Up\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree)
\item 
void {\bfseries move\+To\+Child\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, int child)
\item 
void {\bfseries insert\+Child\+To\+Current\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, Index\+Type \texorpdfstring{$\ast$}{*}particles, Index\+Type nparticles, Pos\+Type boundary\+\_\+p1\mbox{[}$\,$\mbox{]}, Pos\+Type boundary\+\_\+p2\mbox{[}$\,$\mbox{]}, Pos\+Type center\mbox{[}$\,$\mbox{]}, int child)
\item 
void {\bfseries attach\+Child\+To\+Current\+NB} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, \mbox{\hyperlink{struct_branch_n_b}{Branch\+NB}} \&data, int child)
\item 
bool {\bfseries Tree\+NBWalk\+Step} (\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*}tree, bool allow\+Descent)
\item 
bool {\bfseries at\+Leaf} ()
\item 
{\footnotesize template$<$typename T $>$ }\\bool {\bfseries inbox} (const T \texorpdfstring{$\ast$}{*}center, Pos\+Type \texorpdfstring{$\ast$}{*}p1, Pos\+Type \texorpdfstring{$\ast$}{*}p2) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_tree_force_adefb6e7b1cc3a3fff2d2d0eeb6cb1f78}\label{class_tree_force_adefb6e7b1cc3a3fff2d2d0eeb6cb1f78} 
bool {\bfseries init}
\begin{DoxyCompactList}\small\item\em provides a way to change the profiles of the particles, by default Gaussian \end{DoxyCompactList}\item 
\Hypertarget{class_tree_force_a5a03e820fcfde1a984937c59977e52c2}\label{class_tree_force_a5a03e820fcfde1a984937c59977e52c2} 
bool {\bfseries Multi\+Mass}
\begin{DoxyCompactList}\small\item\em true if particles have different masses. \end{DoxyCompactList}\item 
\Hypertarget{class_tree_force_ade43422c62af1a47f78f725e4151cf6a}\label{class_tree_force_ade43422c62af1a47f78f725e4151cf6a} 
bool {\bfseries Multi\+Radius}
\begin{DoxyCompactList}\small\item\em true if particles have different sizes. \end{DoxyCompactList}\item 
\Hypertarget{class_tree_force_aaf5bfc6384c6717f967d888fbd7fcb24}\label{class_tree_force_aaf5bfc6384c6717f967d888fbd7fcb24} 
float \texorpdfstring{$\ast$}{*} {\bfseries masses}
\begin{DoxyCompactList}\small\item\em Array of particle masses. \end{DoxyCompactList}\item 
\Hypertarget{class_tree_force_a77be3597cacacfb4c108a32cf3eeed1f}\label{class_tree_force_a77be3597cacacfb4c108a32cf3eeed1f} 
float \texorpdfstring{$\ast$}{*} {\bfseries rsph}
\begin{DoxyCompactList}\small\item\em Array of particle sizes. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{class_tree_force_acdb57d9d285c3718886c04229dd09dfc}{kappa\+\_\+background}}
\item 
\Hypertarget{class_tree_force_a4d44a298e6b04054c902990de1582b0d}\label{class_tree_force_a4d44a298e6b04054c902990de1582b0d} 
Pos\+Type {\bfseries force\+\_\+theta}
\item 
\Hypertarget{class_tree_force_acee047b1b2f495f91199d90196d965ef}\label{class_tree_force_acee047b1b2f495f91199d90196d965ef} 
bool {\bfseries halo\+ON}
\item 
\Hypertarget{class_tree_force_a59b5d567288269bf067f824ed2083e5b}\label{class_tree_force_a59b5d567288269bf067f824ed2083e5b} 
\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \texorpdfstring{$\ast$}{*} {\bfseries halos}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{class_tree_simple}{Tree\+Simple$<$ PType $>$}}}
\begin{DoxyCompactItemize}
\item 
int {\bfseries Ndim}
\item 
int {\bfseries incell}
\item 
\mbox{\hyperlink{struct_tree_n_b_struct}{Tree\+NBStruct}}$<$ PType $>$ \texorpdfstring{$\ast$}{*} {\bfseries tree}
\item 
Index\+Type \texorpdfstring{$\ast$}{*} {\bfseries index}
\item 
Index\+Type {\bfseries Nparticles}
\item 
bool {\bfseries median\+\_\+cut}
\item 
int {\bfseries Nbucket}
\item 
Pos\+Type {\bfseries realray} \mbox{[}3\mbox{]}
\item 
PType \texorpdfstring{$\ast$}{*} {\bfseries xxp}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Object used to calculate the force or deflection caused by a collection of "{}particles"{} by the tree method. 

The particles can be point masses or have multiple sizes in which case they have a Gaussian profile. They can also have the same mass or multiple masses.

xp\mbox{[}\mbox{]}\mbox{[}\mbox{]}, masses\mbox{[}\mbox{]} and rsph\mbox{[}\mbox{]} need to be allocated before a \doxylink{class_tree_force}{Tree\+Force} is constructed and de-\/allocated after it is destructed. If the boolean flags are set to false these arrays need only be one element long. Multiple Tree\+Forces can be made from the same particles. Do not rotate the particles without reconstructing a \doxylink{class_tree_force}{Tree\+Force}.

Most of the code in the earlier Tree\+NBForce.\+c is duplicated here as private methods and a few public ones.

The default value of theta = 0.\+1 generally gives better than 1\% accuracy on alpha. The shear and kappa is always more accurate than the deflection. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_tree_force_adeabe49704610a41cadfa7f04db796a1}\index{TreeForce@{TreeForce}!TreeForce@{TreeForce}}
\index{TreeForce@{TreeForce}!TreeForce@{TreeForce}}
\doxysubsubsection{\texorpdfstring{TreeForce()}{TreeForce()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_tree_force_adeabe49704610a41cadfa7f04db796a1} 
Tree\+Force\+::\+Tree\+Force (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{xp}{, }\item[{Index\+Type}]{Npoints}{, }\item[{float \texorpdfstring{$\ast$}{*}}]{masses}{, }\item[{float \texorpdfstring{$\ast$}{*}}]{rsph}{, }\item[{bool}]{Multimass}{, }\item[{bool}]{Multisize}{, }\item[{Pos\+Type}]{my\+\_\+kappa\+\_\+background}{ = {\ttfamily 0}, }\item[{int}]{bucket}{ = {\ttfamily 5}, }\item[{int}]{dimensions}{ = {\ttfamily 2}, }\item[{bool}]{median}{ = {\ttfamily false}, }\item[{Pos\+Type}]{theta}{ = {\ttfamily 0.1}}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em my\+\_\+kappa\+\_\+background} & background kappa that is subtracted \\
\hline
\end{DoxyParams}
\Hypertarget{class_tree_force_a1fceae859e1c8badda8437c88cb175f6}\index{TreeForce@{TreeForce}!TreeForce@{TreeForce}}
\index{TreeForce@{TreeForce}!TreeForce@{TreeForce}}
\doxysubsubsection{\texorpdfstring{TreeForce()}{TreeForce()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_tree_force_a1fceae859e1c8badda8437c88cb175f6} 
Tree\+Force\+::\+Tree\+Force (\begin{DoxyParamCaption}\item[{Pos\+Type \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{xp}{, }\item[{Index\+Type}]{Npoints}{, }\item[{\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \texorpdfstring{$\ast$}{*}}]{my\+\_\+halos}{, }\item[{bool}]{Multisize}{ = {\ttfamily true}, }\item[{Pos\+Type}]{my\+\_\+kappa\+\_\+bk}{ = {\ttfamily 0.0}, }\item[{int}]{bucket}{ = {\ttfamily 5}, }\item[{int}]{dimension}{ = {\ttfamily 2}, }\item[{bool}]{median}{ = {\ttfamily false}, }\item[{Pos\+Type}]{theta}{ = {\ttfamily 0.1}}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em xp} & positions of the halos xp\mbox{[}0..Npoints-\/1\mbox{]}\mbox{[}0..1 or 2\mbox{]}  \\
\hline
{\em Npoints} & number of halos  \\
\hline
{\em my\+\_\+halos} & array with internal properties of halos  \\
\hline
{\em Multisize} & flag false if only one halo size and structure should be used, default is true  \\
\hline
{\em my\+\_\+kappa\+\_\+bk} & Background convergence to be subtracted  \\
\hline
{\em bucket} & maximum number of halos in a leaf of the tree  \\
\hline
{\em dimension} & 2 or 3, dimension of tree, default 2  \\
\hline
{\em median} & If true will divide branches at the median position of the particles, if false an equal area cut is used, default false  \\
\hline
{\em theta} & Opening angle used in tree force calculation \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_tree_force_a3259836d3275204c9a3a68e10c9da7b2}\index{TreeForce@{TreeForce}!force2D@{force2D}}
\index{force2D@{force2D}!TreeForce@{TreeForce}}
\doxysubsubsection{\texorpdfstring{force2D()}{force2D()}}
{\footnotesize\ttfamily \label{class_tree_force_a3259836d3275204c9a3a68e10c9da7b2} 
void Tree\+Force\+::force2D (\begin{DoxyParamCaption}\item[{Pos\+Type const \texorpdfstring{$\ast$}{*}}]{ray}{, }\item[{Pos\+Type \texorpdfstring{$\ast$}{*}}]{alpha}{, }\item[{Kappa\+Type \texorpdfstring{$\ast$}{*}}]{kappa}{, }\item[{Kappa\+Type \texorpdfstring{$\ast$}{*}}]{gamma}{, }\item[{Kappa\+Type \texorpdfstring{$\ast$}{*}}]{phi}{}\end{DoxyParamCaption})}



calculate the deflection and lensing propertie 

Tree\+NBForce2D calculates the defection, convergence and shear using the plane-\/lens approximation with 3D SPH smoothing of the density rsph must be calculated before doing this with Find\+RSPH or by other means. tangent\mbox{[}3\mbox{]} -\/ the direction of light rays or orientation of the simulation tree can be either a 3d or 2d tree although 2d is more efficient need to change the projected cm in \+\_\+\+Tree\+NBForce to us 3d tree

The output alpha\mbox{[}\mbox{]} is in units of mass\+\_\+scale/\+Mpc, ie it needs to be divided by Sigma\+\_\+crit and multiplied by mass\+\_\+scale to be the defelction in the lens equation expressed on the lens plane or multiplied by 4\texorpdfstring{$\ast$}{*}pi\texorpdfstring{$\ast$}{*}\+G\texorpdfstring{$\ast$}{*}mass\+\_\+scale to get the deflection angle caused by the plane lens. intersecting, subtract the point particle

\doxysubsection{Member Data Documentation}
\Hypertarget{class_tree_force_acdb57d9d285c3718886c04229dd09dfc}\index{TreeForce@{TreeForce}!kappa\_background@{kappa\_background}}
\index{kappa\_background@{kappa\_background}!TreeForce@{TreeForce}}
\doxysubsubsection{\texorpdfstring{kappa\_background}{kappa\_background}}
{\footnotesize\ttfamily \label{class_tree_force_acdb57d9d285c3718886c04229dd09dfc} 
Pos\+Type Tree\+Force\+::kappa\+\_\+background\hspace{0.3cm}{\ttfamily [protected]}}

A uniform mass sheet in units of mass\+\_\+scale/\+Mpc\texorpdfstring{$^\wedge$}{\string^}2 used to subtract of the contribution of the particles to the mean density of the universe 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
SLsim\+Lib/include/force\+Tree.\+h\item 
SLsim\+Lib/\+Tree\+Code/force\+Tree.\+cpp\end{DoxyCompactItemize}
