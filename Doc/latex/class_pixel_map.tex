\doxysection{Pixel\+Map\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{class_pixel_map}{}\label{class_pixel_map}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}


Image structure that can be manipulated and exported to/from fits files.  




{\ttfamily \#include $<$pixelmap.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_pixel_map_a4578eac86acffad52ce76093ec0b804a}{Pixel\+Map}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&pmap, double res\+\_\+ratio)
\begin{DoxyCompactList}\small\item\em Creates a \doxylink{class_pixel_map}{Pixel\+Map} at a different resolution. The new counts are calculated integrating over the input pixels. No interpolation or smoothing is performed. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a5ccb2c2ffa7f17fbfb0178b38781df54}\label{class_pixel_map_a5ccb2c2ffa7f17fbfb0178b38781df54} 
{\bfseries Pixel\+Map} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&other)
\item 
\Hypertarget{class_pixel_map_a0eaf39938395c6f49abc19af6395c333}\label{class_pixel_map_a0eaf39938395c6f49abc19af6395c333} 
{\bfseries Pixel\+Map} (\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&\&other)
\item 
\mbox{\hyperlink{class_pixel_map_a9086682cb7635da45491efb2ffc4daf6}{Pixel\+Map}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&pmap, const double \texorpdfstring{$\ast$}{*}center, std\+::size\+\_\+t Npixels)
\begin{DoxyCompactList}\small\item\em Creates a new \doxylink{class_pixel_map}{Pixel\+Map} from a square region of a \doxylink{class_pixel_map}{Pixel\+Map}. If the region exceeds the boundaries of the original map, the new map is completed with zeros. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map_ad57ffb9bb4274f30079044f9afbdc0c0}{Pixel\+Map}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&pmap, long nx, long ny, std\+::size\+\_\+t Npixels)
\begin{DoxyCompactList}\small\item\em Produces a square cut-\/out of the input \doxylink{class_pixel_map}{Pixel\+Map}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map_a3bebdffb73b5ee2665366e4a3bdfb90e}{Pixel\+Map}} (const double \texorpdfstring{$\ast$}{*}center, std\+::size\+\_\+t Npixels, double resolution, Pixel\+Map\+Units u=Pixel\+Map\+Units\+::ndef)
\begin{DoxyCompactList}\small\item\em make square \doxylink{class_pixel_map}{Pixel\+Map} \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map_a420dcaae788313e3dc529073bcc35dcd}{Pixel\+Map}} (const double \texorpdfstring{$\ast$}{*}center, std\+::size\+\_\+t Nx, std\+::size\+\_\+t Ny, double resolution, Pixel\+Map\+Units u=Pixel\+Map\+Units\+::ndef)
\begin{DoxyCompactList}\small\item\em make rectangular \doxylink{class_pixel_map}{Pixel\+Map} with square pixels \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map_ac7820da839276b6a4d4a514794ffdebd}{Pixel\+Map}} (std\+::string fitsfilename, double resolution=-\/1, Pixel\+Map\+Units u=Pixel\+Map\+Units\+::ndef)
\begin{DoxyCompactList}\small\item\em Constructs a \doxylink{class_pixel_map}{Pixel\+Map} reading in a fits file Infos about resolution, Npixels and center are read from the header. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a5f22caeccd7aba5139275d90e5e835d0}\label{class_pixel_map_a5f22caeccd7aba5139275d90e5e835d0} 
{\footnotesize template$<$typename OtherT $>$ }\\{\bfseries Pixel\+Map} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ OtherT $>$ \&)
\item 
\Hypertarget{class_pixel_map_aee4572fd5b6d85a09919e901cf1810d2}\label{class_pixel_map_aee4572fd5b6d85a09919e901cf1810d2} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \& {\bfseries operator=} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&other)
\item 
\Hypertarget{class_pixel_map_ad1deeab2249a4df78fd1115ae0b424ca}\label{class_pixel_map_ad1deeab2249a4df78fd1115ae0b424ca} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \& {\bfseries operator=} (\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&\&other)
\item 
\Hypertarget{class_pixel_map_a47ff6d96838640011822e399bc9dc1c7}\label{class_pixel_map_a47ff6d96838640011822e399bc9dc1c7} 
void {\bfseries Change\+Units} (Pixel\+Map\+Units u)
\item 
\Hypertarget{class_pixel_map_a7b8949dbb33d48e9e4dca81f04791f8f}\label{class_pixel_map_a7b8949dbb33d48e9e4dca81f04791f8f} 
Pixel\+Map\+Units {\bfseries get\+Units} () const
\item 
\Hypertarget{class_pixel_map_a26e55c911d9d1488d246433b4e5265b6}\label{class_pixel_map_a26e55c911d9d1488d246433b4e5265b6} 
bool {\bfseries valid} () const
\item 
\Hypertarget{class_pixel_map_a48631122e0c2658c8e40a6c62332d637}\label{class_pixel_map_a48631122e0c2658c8e40a6c62332d637} 
std\+::size\+\_\+t {\bfseries size} () const
\item 
\Hypertarget{class_pixel_map_a983339fde6e00a3c4d3c63e086ee94e2}\label{class_pixel_map_a983339fde6e00a3c4d3c63e086ee94e2} 
std\+::size\+\_\+t {\bfseries get\+Nx} () const
\item 
\Hypertarget{class_pixel_map_a7624e1a7843b3c5623b3acb006048e36}\label{class_pixel_map_a7624e1a7843b3c5623b3acb006048e36} 
std\+::size\+\_\+t {\bfseries get\+Ny} () const
\item 
\Hypertarget{class_pixel_map_a6dd29d7e7d247d0413a945b9b3065329}\label{class_pixel_map_a6dd29d7e7d247d0413a945b9b3065329} 
double {\bfseries get\+RangeX} () const
\item 
\Hypertarget{class_pixel_map_af3da0c2f0cb354f82220ecbfaa598876}\label{class_pixel_map_af3da0c2f0cb354f82220ecbfaa598876} 
double {\bfseries get\+RangeY} () const
\item 
\Hypertarget{class_pixel_map_a29059d2d2a3f07b16559b2a54be71fdb}\label{class_pixel_map_a29059d2d2a3f07b16559b2a54be71fdb} 
void const {\bfseries get\+Center} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&c) const
\item 
\Hypertarget{class_pixel_map_a4fcfa818955dc684a754a6fbd1745c8b}\label{class_pixel_map_a4fcfa818955dc684a754a6fbd1745c8b} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries get\+Center} () const
\item 
\Hypertarget{class_pixel_map_acecea1883ca6e7839459c3811dba7917}\label{class_pixel_map_acecea1883ca6e7839459c3811dba7917} 
double {\bfseries get\+Resolution} () const
\item 
\Hypertarget{class_pixel_map_a6181f60f32e6fcf308ca7d5ab7ec6873}\label{class_pixel_map_a6181f60f32e6fcf308ca7d5ab7ec6873} 
\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} {\bfseries get\+LLBoundary} () const
\item 
\Hypertarget{class_pixel_map_a174494b0a50ed33e862901171aebb3c8}\label{class_pixel_map_a174494b0a50ed33e862901171aebb3c8} 
double {\bfseries get\+RA} ()
\begin{DoxyCompactList}\small\item\em returns right accention of center \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a1d81949d32a08d2cb2769ba8481bd2c9}\label{class_pixel_map_a1d81949d32a08d2cb2769ba8481bd2c9} 
double {\bfseries get\+DEC} ()
\begin{DoxyCompactList}\small\item\em returns declination of center \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ac8ba47db83bb3326a2682047711f47c8}\label{class_pixel_map_ac8ba47db83bb3326a2682047711f47c8} 
void {\bfseries set\+RAand\+Dec} (double RAin, double DECin)
\begin{DoxyCompactList}\small\item\em set the coordinates of center \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a85b5c1e491be486e6eff5c9cb785f953}\label{class_pixel_map_a85b5c1e491be486e6eff5c9cb785f953} 
void {\bfseries Clean} ()
\item 
void \mbox{\hyperlink{class_pixel_map_aa099074dcde4e989b474626ac8bde801}{Add\+Images}} (\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}imageinfo, int Nimages, float rescale=1.)
\begin{DoxyCompactList}\small\item\em Add an image to the map. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a56250435304af6f8a2e1b858af627554}{Add\+Images}} (std\+::vector$<$ \mbox{\hyperlink{struct_image_info}{Image\+Info}} $>$ \&imageinfo, int Nimages, float rescale=1.)
\item 
\Hypertarget{class_pixel_map_a2ddead4c956462ef153fff9fe3c2bafc}\label{class_pixel_map_a2ddead4c956462ef153fff9fe3c2bafc} 
void {\bfseries Add\+Grid\+Brightness} (\mbox{\hyperlink{struct_grid}{Grid}} \&grid)
\begin{DoxyCompactList}\small\item\em Add an image from a the surface brightnesses of a \doxylink{struct_grid}{Grid} to the \doxylink{class_pixel_map}{Pixel\+Map}. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ad04155b31167c820e070704a021467e4}\label{class_pixel_map_ad04155b31167c820e070704a021467e4} 
void {\bfseries Add\+Grid\+Map\+Brightness} (const \mbox{\hyperlink{struct_grid_map}{Grid\+Map}} \&grid)
\begin{DoxyCompactList}\small\item\em Add an image from a the surface brightnesses of a \doxylink{struct_grid_map}{Grid\+Map} to the \doxylink{class_pixel_map}{Pixel\+Map}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a21a76b59535155e8cb1e59232f6ec6d0}{Add\+Uniform\+Images}} (\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}imageinfo, int Nimages, T value)
\begin{DoxyCompactList}\small\item\em Add images with uniform surface brightness set by input parameter value. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ab5a36fde4893b0ea45ba74bca30319e8}\label{class_pixel_map_ab5a36fde4893b0ea45ba74bca30319e8} 
Pos\+Type {\bfseries Add\+Source} (\mbox{\hyperlink{class_source}{Source}} \&source)
\item 
\Hypertarget{class_pixel_map_a7f239986b066e5392367fce0b4b5cf7b}\label{class_pixel_map_a7f239986b066e5392367fce0b4b5cf7b} 
Pos\+Type {\bfseries Add\+Source} (\mbox{\hyperlink{class_source}{Source}} \&source, int oversample)
\begin{DoxyCompactList}\small\item\em Add a source to the pixel map by oversamples the source so that oversample\texorpdfstring{$^\wedge$}{\string^}2 points within each pixel are averaged. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_acace5d518221f3faefb6816e6481a268}\label{class_pixel_map_acace5d518221f3faefb6816e6481a268} 
void {\bfseries Add\+Point\+Source} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&x, T flux)
\item 
void \mbox{\hyperlink{class_pixel_map_a23dd9311eabc4c9fb07b5e21fe42cbbe}{copy\+\_\+in}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&pmap)
\begin{DoxyCompactList}\small\item\em copy a \doxylink{class_pixel_map}{Pixel\+Map} into this one. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ad86932f2017231a958bc43a30b86a1fa}{paste}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&pmap)
\begin{DoxyCompactList}\small\item\em Replace overlaping pixel values with those of the input map. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a4f5901d2352890576c28213695ab10d1}\label{class_pixel_map_a4f5901d2352890576c28213695ab10d1} 
void {\bfseries paste} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&pmap, long nx, long ny)
\begin{DoxyCompactList}\small\item\em paste a \doxylink{class_pixel_map}{Pixel\+Map} on with the lower left pixel match to \mbox{[}nx,ny\mbox{]} of this \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map_a91ab87e9b1ded3ad323e1eec189e589b}{convolve}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&kernel)
\begin{DoxyCompactList}\small\item\em convolve the image with a kernel. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aea884c4a99a0141f34eafb964621bce7}\label{class_pixel_map_aea884c4a99a0141f34eafb964621bce7} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ {\bfseries convolve2} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&kernel)
\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map_ae1922a4d9a6015eabf8f8b63596d7d74}{cutout}} (long xmin, long xmax, long ymin, long ymax)
\begin{DoxyCompactList}\small\item\em cut out a part of the \doxylink{class_pixel_map}{Pixel\+Map} \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a0c3b6e8e5c63e799d47105e37810fe69}{duplicate}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&pmap)
\begin{DoxyCompactList}\small\item\em copy a \doxylink{class_pixel_map}{Pixel\+Map} that must be the same without creating a new one.. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a53deefce717c4fa1dd7ac8ba69bdb5fa}\label{class_pixel_map_a53deefce717c4fa1dd7ac8ba69bdb5fa} 
{\footnotesize template$<$typename S $>$ }\\Pos\+Type {\bfseries Add\+Source\+\_\+parallel} (S \&source, int oversample)
\begin{DoxyCompactList}\small\item\em Adds source to map. This version breaks pixels up into blocks and does them in seporate threads. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a7f51e20e0935f5b01446482498d0864e}{Add\+Curve}} (\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}curve, T value)
\begin{DoxyCompactList}\small\item\em Draws a closed curve through the points in curve-\/\texorpdfstring{$>$}{>}imagekist. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a4b5e257c665f1599add6f821b6aaad4e}\label{class_pixel_map_a4b5e257c665f1599add6f821b6aaad4e} 
void {\bfseries Add\+Curve} (Kist$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ \texorpdfstring{$\ast$}{*}imagekist, T value)
\item 
\Hypertarget{class_pixel_map_a9b684b2612f541c00613044f9f9348d1}\label{class_pixel_map_a9b684b2612f541c00613044f9f9348d1} 
void {\bfseries Add\+Curve} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ \&curve, T value)
\item 
\Hypertarget{class_pixel_map_a0dc343d34808c32f559e9b143a5f3135}\label{class_pixel_map_a0dc343d34808c32f559e9b143a5f3135} 
void {\bfseries Add\+Curve} (std\+::vector$<$ \mbox{\hyperlink{struct_r_a_y}{RAY}} $>$ \&curve, T value)
\item 
void \mbox{\hyperlink{class_pixel_map_a474b8c3fe3e9387f250f53f68a392416}{drawline}} (double x1\mbox{[}$\,$\mbox{]}, double x2\mbox{[}$\,$\mbox{]}, T value, bool add)
\begin{DoxyCompactList}\small\item\em simple line \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_af90bb4c3a00a7ca3b1d5b586fce767fc}\label{class_pixel_map_af90bb4c3a00a7ca3b1d5b586fce767fc} 
void {\bfseries Draw\+Line} (long x0, long x1, long y0, long y1, T value, bool add)
\begin{DoxyCompactList}\small\item\em line by Bresenham\textquotesingle{}s line algorithm \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aa42479b1c8ba48c4ce117eda47b6bb6c}\label{class_pixel_map_aa42479b1c8ba48c4ce117eda47b6bb6c} 
void {\bfseries Draw\+Line\+GS} (long x0, long x1, long y0, long y1, T value, bool add)
\item 
void \mbox{\hyperlink{class_pixel_map_ae8b5450b2b5aa75d97622cfa3df24b49}{drawcircle}} (Pos\+Type r\+\_\+center\mbox{[}$\,$\mbox{]}, Pos\+Type radius, Pos\+Type value)
\begin{DoxyCompactList}\small\item\em Draws a circle. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a44f6f55891bc9534cc9f259fb8e71059}{drawdisk}} (Pos\+Type r\+\_\+center\mbox{[}$\,$\mbox{]}, Pos\+Type radius, Pos\+Type value, int Nstrip)
\begin{DoxyCompactList}\small\item\em Draws a disk. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ae0ff75f357f02175e649a051441aa0d4}{Add\+Grid}} (const \mbox{\hyperlink{struct_grid}{Grid}} \&grid, T value=1.\+0)
\begin{DoxyCompactList}\small\item\em Fills in pixels where the image plane points in the grid are located with the value given. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_aff6dbacdcd7c070656b1035dbd593333}{Add\+Grid}} (const \mbox{\hyperlink{struct_grid}{Grid}} \&grid, \mbox{\hyperlink{standard_8h_a73d5f5042d9b38366d0b3781d199f9e7}{Lensing\+Variable}} val)
\begin{DoxyCompactList}\small\item\em Fills in pixels with the selected quantity from the grid points. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ad26f4ce83e8402b83f516b007c20fd2f}\label{class_pixel_map_ad26f4ce83e8402b83f516b007c20fd2f} 
void {\bfseries Renormalize} (T factor)
\begin{DoxyCompactList}\small\item\em Multiplies the whole map by a scalar factor. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aaf0bc5f2ecc7217e355f99561ed73171}\label{class_pixel_map_aaf0bc5f2ecc7217e355f99561ed73171} 
void {\bfseries Add\+Value} (std\+::size\+\_\+t i, T value)
\begin{DoxyCompactList}\small\item\em Adds a value to the i-\/th pixel. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aa09f52e37af0426d4925fc26e9399dd1}\label{class_pixel_map_aa09f52e37af0426d4925fc26e9399dd1} 
void {\bfseries Assign\+Value} (std\+::size\+\_\+t i, T value)
\begin{DoxyCompactList}\small\item\em Assigns a value to the i-\/th pixel. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ab8e61d9dbe8688407b3d140c69de5314}\label{class_pixel_map_ab8e61d9dbe8688407b3d140c69de5314} 
void {\bfseries print\+ASCII} () const
\begin{DoxyCompactList}\small\item\em Print an ASCII table of all the pixel values. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a913f707f9106f7a64d441cc6d0ad6786}\label{class_pixel_map_a913f707f9106f7a64d441cc6d0ad6786} 
void {\bfseries print\+ASCIIto\+File} (std\+::string filename) const
\begin{DoxyCompactList}\small\item\em Print an ASCII table of all the pixel values. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a710ed995171bd6778ac634c559e7a781}\label{class_pixel_map_a710ed995171bd6778ac634c559e7a781} 
void {\bfseries print\+FITS} (std\+::string filename, bool Xflip=false, bool verbose=false)
\begin{DoxyCompactList}\small\item\em Output the pixel map as a fits file. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ac7c6a96dc79200f352bb68bfdfedb8a5}\label{class_pixel_map_ac7c6a96dc79200f352bb68bfdfedb8a5} 
void {\bfseries print\+FITS} (std\+::string filename, std\+::vector$<$ std\+::tuple$<$ std\+::string, double, std\+::string $>$ $>$ \&extra\+\_\+header\+\_\+info, bool verbose)
\item 
void \mbox{\hyperlink{class_pixel_map_a3b3ca3285aeee1f6b1c3be7a6ffa657d}{print\+FITS}} (std\+::string filename, std\+::vector$<$ std\+::string $>$ \&headercards)
\begin{DoxyCompactList}\small\item\em This overides all header information and relaces it with the inputs. Meant for making a modified copy. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ae821ad97f54160cc8c9216559f674002}\label{class_pixel_map_ae821ad97f54160cc8c9216559f674002} 
void {\bfseries smooth} (double sigma)
\begin{DoxyCompactList}\small\item\em Smoothes a map with a Gaussian kernel of width sigma (in arcseconds) \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aad0af01f53eed2a5de96898df7813a36}\label{class_pixel_map_aad0af01f53eed2a5de96898df7813a36} 
T {\bfseries get\+Value} (std\+::size\+\_\+t i) const
\item 
\Hypertarget{class_pixel_map_a54ff10d60c5184d824bafa76de0fd166}\label{class_pixel_map_a54ff10d60c5184d824bafa76de0fd166} 
T \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (std\+::size\+\_\+t i)
\item 
\Hypertarget{class_pixel_map_a40d24bfaad8e27bedce87c9f4d67511a}\label{class_pixel_map_a40d24bfaad8e27bedce87c9f4d67511a} 
T {\bfseries operator\mbox{[}$\,$\mbox{]}} (std\+::size\+\_\+t i) const
\item 
\Hypertarget{class_pixel_map_a065101ad1f32a94fe26acff5bd116296}\label{class_pixel_map_a065101ad1f32a94fe26acff5bd116296} 
T \& {\bfseries operator()} (std\+::size\+\_\+t i)
\item 
\Hypertarget{class_pixel_map_a1dfbe3346a9e56aff943f15afa083f78}\label{class_pixel_map_a1dfbe3346a9e56aff943f15afa083f78} 
T {\bfseries operator()} (std\+::size\+\_\+t i) const
\item 
\Hypertarget{class_pixel_map_ac51a03eead81b1404276d6b7d77344b9}\label{class_pixel_map_ac51a03eead81b1404276d6b7d77344b9} 
T {\bfseries operator()} (std\+::size\+\_\+t i, std\+::size\+\_\+t j) const
\item 
\Hypertarget{class_pixel_map_ad3e5815bb0178d8cc90d8c8c70458d5d}\label{class_pixel_map_ad3e5815bb0178d8cc90d8c8c70458d5d} 
T \& {\bfseries operator()} (std\+::size\+\_\+t i, std\+::size\+\_\+t j)
\item 
\Hypertarget{class_pixel_map_a3d2e6eb00050d4c0543f5d7d9d180de6}\label{class_pixel_map_a3d2e6eb00050d4c0543f5d7d9d180de6} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \& {\bfseries operator+=} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&rhs)
\begin{DoxyCompactList}\small\item\em Add the values of another \doxylink{class_pixel_map}{Pixel\+Map} to this one. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aef05d334653ce1213d1be8f2294c782e}\label{class_pixel_map_aef05d334653ce1213d1be8f2294c782e} 
void {\bfseries operator+=} (float f)
\item 
\Hypertarget{class_pixel_map_ad5d758d2f72b84080cee674466455c55}\label{class_pixel_map_ad5d758d2f72b84080cee674466455c55} 
void {\bfseries operator+=} (double f)
\item 
\Hypertarget{class_pixel_map_ac42b6c2439140851be0a6ba5a3254451}\label{class_pixel_map_ac42b6c2439140851be0a6ba5a3254451} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} {\bfseries operator+} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&) const
\begin{DoxyCompactList}\small\item\em Add two Pixel\+Maps. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a33bef5f19f8b81dc4c7b8e67467c9ffa}\label{class_pixel_map_a33bef5f19f8b81dc4c7b8e67467c9ffa} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \& {\bfseries operator-\/=} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&rhs)
\begin{DoxyCompactList}\small\item\em Subtract the values of another \doxylink{class_pixel_map}{Pixel\+Map} from this one. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aac946e932256b05771b204fa697a705e}\label{class_pixel_map_aac946e932256b05771b204fa697a705e} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} {\bfseries operator-\/} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&) const
\begin{DoxyCompactList}\small\item\em Subtract two Pixel\+Maps. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a389f7f73f5e6f796bd925991853616f7}\label{class_pixel_map_a389f7f73f5e6f796bd925991853616f7} 
void {\bfseries operator-\/=} (float f)
\item 
\Hypertarget{class_pixel_map_a73ccd5c8bc9c5bae3e8d091830715883}\label{class_pixel_map_a73ccd5c8bc9c5bae3e8d091830715883} 
void {\bfseries operator-\/=} (double f)
\item 
\Hypertarget{class_pixel_map_a7a951f63d3f7105aa967391aa2438011}\label{class_pixel_map_a7a951f63d3f7105aa967391aa2438011} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \& {\bfseries operator\texorpdfstring{$\ast$}{*}=} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&rhs)
\begin{DoxyCompactList}\small\item\em Multiply the values of another \doxylink{class_pixel_map}{Pixel\+Map} by this one. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aa935e1aed64164209706f7f513cbbc44}\label{class_pixel_map_aa935e1aed64164209706f7f513cbbc44} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} {\bfseries operator\texorpdfstring{$\ast$}{*}} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&a) const
\begin{DoxyCompactList}\small\item\em Multiply two Pixel\+Maps. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ac7b6cd06a769ca073bd6cfcc0334b58f}\label{class_pixel_map_ac7b6cd06a769ca073bd6cfcc0334b58f} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} {\bfseries operator/} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&a) const
\begin{DoxyCompactList}\small\item\em Multiply two Pixel\+Maps. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a068eaeb34dcc10ba52cfc26521d17a23}\label{class_pixel_map_a068eaeb34dcc10ba52cfc26521d17a23} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \& {\bfseries operator\texorpdfstring{$\ast$}{*}=} (Pos\+Type b)
\item 
\Hypertarget{class_pixel_map_a54ee4a56592b0fc57d1d53b93f01b619}\label{class_pixel_map_a54ee4a56592b0fc57d1d53b93f01b619} 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} {\bfseries operator\texorpdfstring{$\ast$}{*}} (Pos\+Type b) const
\item 
\Hypertarget{class_pixel_map_a8fb028af2ba36f3ee681f51de196caee}\label{class_pixel_map_a8fb028af2ba36f3ee681f51de196caee} 
std\+::valarray$<$ T $>$ \& {\bfseries data} ()
\item 
\Hypertarget{class_pixel_map_aeafa7be82b3662b91f61ba0a4c2ca25b}\label{class_pixel_map_aeafa7be82b3662b91f61ba0a4c2ca25b} 
bool {\bfseries agrees} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \&other) const
\begin{DoxyCompactList}\small\item\em Check whether two Pixel\+Maps agree in their physical dimensions. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aa674d02860c4d762bb6147fcc6797cd9}\label{class_pixel_map_aa674d02860c4d762bb6147fcc6797cd9} 
Pos\+Type {\bfseries ave} () const
\begin{DoxyCompactList}\small\item\em return average pixel value \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_acabf4726c2aaf0220fc2d3d932f48b4f}\label{class_pixel_map_acabf4726c2aaf0220fc2d3d932f48b4f} 
Pos\+Type {\bfseries sum} () const
\begin{DoxyCompactList}\small\item\em return sum of all pixel values \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ae020b2d61f1dcb110f5fd5587340385f}\label{class_pixel_map_ae020b2d61f1dcb110f5fd5587340385f} 
size\+\_\+t {\bfseries size} ()
\begin{DoxyCompactList}\small\item\em Total number of pixels. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aaaf5c7807b9ff6586af4e1422e62e789}\label{class_pixel_map_aaaf5c7807b9ff6586af4e1422e62e789} 
T {\bfseries max} () const
\item 
\Hypertarget{class_pixel_map_aefe5610fe2bef7b1af9fe867e1c3be6e}\label{class_pixel_map_aefe5610fe2bef7b1af9fe867e1c3be6e} 
T {\bfseries min} () const
\item 
\Hypertarget{class_pixel_map_a111a31f9d421ae113d9073fb7b8a0071}\label{class_pixel_map_a111a31f9d421ae113d9073fb7b8a0071} 
void {\bfseries Find\+Arc} (Pos\+Type \&radius, Pos\+Type \texorpdfstring{$\ast$}{*}xc, Pos\+Type \texorpdfstring{$\ast$}{*}arc\+\_\+center, Pos\+Type \&arclength, Pos\+Type \&width, Pos\+Type \mbox{\hyperlink{class_pixel_map_ab6d826792511cc2b9ff1bcdfc315725c}{threshold}})
\begin{DoxyCompactList}\small\item\em Find arcs in image WARNING\+: THIS IS UNDER CONSTRUCTION! \end{DoxyCompactList}\item 
long \mbox{\hyperlink{class_pixel_map_ad790d8c0bf6a429502f3bb53c386d16d}{find\+\_\+index}} (Pos\+Type const x\mbox{[}$\,$\mbox{]}, long \&ix, long \&iy) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map, this version returns the 2D grid coordinates \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a0823af18ef1ed898fcd6440eca3dd597}\label{class_pixel_map_a0823af18ef1ed898fcd6440eca3dd597} 
long {\bfseries find\+\_\+index} (Pos\+Type const x\mbox{[}$\,$\mbox{]}) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map \end{DoxyCompactList}\item 
long \mbox{\hyperlink{class_pixel_map_a6ed8d82cec418b7e82b0084262499f08}{find\+\_\+index}} (Pos\+Type x, Pos\+Type y, long \&ix, long \&iy) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map, this version returns the 2D grid coordinates \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a1a0466bb009b20ee6b894f4b57f6b800}\label{class_pixel_map_a1a0466bb009b20ee6b894f4b57f6b800} 
long {\bfseries find\+\_\+index} (Pos\+Type x, Pos\+Type y) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ae12717f69262f11d7aa3c928d30966f2}\label{class_pixel_map_ae12717f69262f11d7aa3c928d30966f2} 
void {\bfseries find\+\_\+position} (Pos\+Type x\mbox{[}$\,$\mbox{]}, std\+::size\+\_\+t const index) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a41ff0ca9241d5113cf4f567f2aff9566}\label{class_pixel_map_a41ff0ca9241d5113cf4f567f2aff9566} 
void {\bfseries find\+\_\+position} (Pos\+Type x\mbox{[}$\,$\mbox{]}, std\+::size\+\_\+t const ix, std\+::size\+\_\+t const iy) const
\begin{DoxyCompactList}\small\item\em get the index for a position, returns -\/1 if out of map \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map_a2d6fe4ee3ffdb3b860843b657e9a4a46}{rotate}} (Pos\+Type theta, T scale=1)
\begin{DoxyCompactList}\small\item\em rotate and scale the image while keeping pixels, resoluiton \end{DoxyCompactList}\item 
T \mbox{\hyperlink{class_pixel_map_aea3c0baa3f140277633c55eeeb7bf038}{linear\+\_\+interpolate}} (Pos\+Type x\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em interpolate to point x\mbox{[}\mbox{]} \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_afbddad3feb07c24ec2e00e1fe305e963}{drawgrid}} (int N, Pos\+Type value)
\begin{DoxyCompactList}\small\item\em draw a grid on the image that divides the each demension into N cells \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ad90fd8a63b3bd3a7168fde30da5c9fa8}\label{class_pixel_map_ad90fd8a63b3bd3a7168fde30da5c9fa8} 
void {\bfseries draw\+Points} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ points, Pos\+Type size, Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_ac50c265f5e38dfad2d4780040492527a}\label{class_pixel_map_ac50c265f5e38dfad2d4780040492527a} 
void {\bfseries draw\+Points} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ points, Pos\+Type size, Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_a4e401f6ed0eaebe6afe8ebf4e2d90b7d}\label{class_pixel_map_a4e401f6ed0eaebe6afe8ebf4e2d90b7d} 
void {\bfseries draw\+Curve} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} \texorpdfstring{$\ast$}{*} $>$ points, Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_a66b3566d419872dc5711bf0614f3fa79}\label{class_pixel_map_a66b3566d419872dc5711bf0614f3fa79} 
void {\bfseries draw\+Curve} (std\+::vector$<$ \mbox{\hyperlink{struct_point}{Point}} $>$ points, Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_af5c44c9b13f778cf683772e0c750481d}\label{class_pixel_map_af5c44c9b13f778cf683772e0c750481d} 
void {\bfseries draw\+Points} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ points, Pos\+Type size, Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_a8538b0ea9c3c26e6b333822d2f2e80a3}\label{class_pixel_map_a8538b0ea9c3c26e6b333822d2f2e80a3} 
void {\bfseries draw\+Curve} (std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ points, Pos\+Type value)
\item 
void \mbox{\hyperlink{class_pixel_map_a3fc82c0d7ddb49f6cc1bdfed928fc0df}{draw\+Square}} (Pos\+Type p1\mbox{[}$\,$\mbox{]}, Pos\+Type p2\mbox{[}$\,$\mbox{]}, Pos\+Type value)
\begin{DoxyCompactList}\small\item\em Draw a rectangle. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ac6797af02982002f2782ba28d9fae648}\label{class_pixel_map_ac6797af02982002f2782ba28d9fae648} 
void {\bfseries draw\+Box} (Pos\+Type p1\mbox{[}$\,$\mbox{]}, Pos\+Type p2\mbox{[}$\,$\mbox{]}, Pos\+Type value, int Nstrip)
\begin{DoxyCompactList}\small\item\em Draws a box (filling the inside with horizontal lines, starting from the top) \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ac45faa9d9180823398c1cd48c6ec366b}{Power\+Spectrum}} (std\+::vector$<$ Pos\+Type $>$ \&power\+\_\+spectrum, std\+::vector$<$ Pos\+Type $>$ \&lvec, bool overwrite=true)
\begin{DoxyCompactList}\small\item\em Find the power spectrum of the map. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_a5b1b128379f118e89c902a6a1aa4ad18}{Power\+Spectrum}} (std\+::vector$<$ Pos\+Type $>$ \&power\+\_\+spectrum, const std\+::vector$<$ Pos\+Type $>$ \&lbins, std\+::vector$<$ Pos\+Type $>$ \&lave, bool overwrite=true)
\begin{DoxyCompactList}\small\item\em Find the power spectrum of the map. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_aa7af5b6308bfadcdcb146aaa0a592901}\label{class_pixel_map_aa7af5b6308bfadcdcb146aaa0a592901} 
void {\bfseries Adaptive\+Smooth} (Pos\+Type value)
\item 
\Hypertarget{class_pixel_map_a0b505260b79cea3c08f9280e20583db3}\label{class_pixel_map_a0b505260b79cea3c08f9280e20583db3} 
void {\bfseries find\+\_\+contour} (T level, std\+::vector$<$ std\+::vector$<$ \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} $>$ $>$ \&points, std\+::vector$<$ bool $>$ \&hits\+\_\+edge) const
\begin{DoxyCompactList}\small\item\em returns a vector of contour curves \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ab5d53bd6858dacac2cf2d129bf72125a}{find\+\_\+islands\+\_\+holes}} (T level, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&points) const
\item 
void \mbox{\hyperlink{class_pixel_map_af606be8c453f60f9434005e7dddd6ecf}{lens\+\_\+definition}} (T min\+\_\+sn\+\_\+per\+\_\+image, T pixel\+\_\+threshold, int \&Nimages, T \&total\+\_\+sig\+\_\+noise\+\_\+source, std\+::vector$<$ size\+\_\+t $>$ \&maxima\+\_\+indexes, std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&image\+\_\+points, bool \&lens\+\_\+\+TF, T \&level, size\+\_\+t \&n\+\_\+pix\+\_\+in\+\_\+source, bool verbose=false)
\item 
std\+::vector$<$ size\+\_\+t $>$ \mbox{\hyperlink{class_pixel_map_aed061b06d8259988ea3cf3e48edade3c}{maxima}} (T minlevel) const
\begin{DoxyCompactList}\small\item\em find maxima that are above minlevel \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_pixel_map_ab070d54853aca7eb11ee4027d007b5d3}{count\+\_\+islands}} (std\+::vector$<$ size\+\_\+t $>$ \&pixel\+\_\+index) const
\begin{DoxyCompactList}\small\item\em For a list of pixel indexes this will count and separated islands that are not connected. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_ab6d826792511cc2b9ff1bcdfc315725c}\label{class_pixel_map_ab6d826792511cc2b9ff1bcdfc315725c} 
size\+\_\+t {\bfseries threshold} (std\+::list$<$ size\+\_\+t $>$ \&pixel\+\_\+index, Pos\+Type value)
\begin{DoxyCompactList}\small\item\em get a list of pixels above value \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a01b0ac41cfc251460df2e29424a59ac8}\label{class_pixel_map_a01b0ac41cfc251460df2e29424a59ac8} 
void {\bfseries flipY} ()
\begin{DoxyCompactList}\small\item\em reflects the image about the horizontal mid-\/line \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_abfc6c71f1f349c25591d9ca9e0815a5f}\label{class_pixel_map_abfc6c71f1f349c25591d9ca9e0815a5f} 
void {\bfseries flipX} ()
\begin{DoxyCompactList}\small\item\em reflects the image about the vertical mid-\/line \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a61553650275b6cc19c19acbe28c69001}\label{class_pixel_map_a61553650275b6cc19c19acbe28c69001} 
void {\bfseries double\+Flip} ()
\begin{DoxyCompactList}\small\item\em rotate the image by 180deg or equivalently reflect it through the origin \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ab16b0dccdadeb421760d111bfd2a5699}{recenter}} (Pos\+Type newcenter\mbox{[}2\mbox{]})
\begin{DoxyCompactList}\small\item\em recenter the map without changing anything else. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_pixel_map_ad6dc2e50ac4ec14a9d1b6e5598352f23}{recenter}} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} newcenter)
\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map_ac3adfbd069aecd4feea2e34e8bc7849a}{downsize}} (int n)
\begin{DoxyCompactList}\small\item\em Creates a \doxylink{class_pixel_map}{Pixel\+Map} with a lower resolution. The value of the pixels are added for the new pixels. If n does not go into the orginial number of pixels evenly the right (top) redge is dropped. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}} \mbox{\hyperlink{class_pixel_map_a5417da9f568360b9e7b11fdbbf0ac720}{interpolate}} (int n)
\begin{DoxyCompactList}\small\item\em Makes a \doxylink{class_pixel_map}{Pixel\+Map} with resolution 1/n of the original with the values linearly interpolated. \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_af7d7f2e398c713083b87e8aec761aa7a}\label{class_pixel_map_af7d7f2e398c713083b87e8aec761aa7a} 
void {\bfseries addheader} (std\+::string label, long value, std\+::string comment)
\begin{DoxyCompactList}\small\item\em add a heaader keyword that will appear in fits output \end{DoxyCompactList}\item 
\Hypertarget{class_pixel_map_a88da67be6f0612e5aa2a2f274f13c44a}\label{class_pixel_map_a88da67be6f0612e5aa2a2f274f13c44a} 
void {\bfseries addheader} (std\+::string label, size\+\_\+t value, std\+::string comment)
\item 
\Hypertarget{class_pixel_map_ad2fd4173cf543e150cd64eb96b6c593b}\label{class_pixel_map_ad2fd4173cf543e150cd64eb96b6c593b} 
void {\bfseries addheader} (std\+::string label, float value, std\+::string comment)
\item 
\Hypertarget{class_pixel_map_abd79089ddf6f878dd3c730bbc7cf5db9}\label{class_pixel_map_abd79089ddf6f878dd3c730bbc7cf5db9} 
void {\bfseries addheader} (std\+::string label, double value, std\+::string comment)
\item 
\Hypertarget{class_pixel_map_a177b39b1a123b398f081becea8bf08db}\label{class_pixel_map_a177b39b1a123b398f081becea8bf08db} 
void {\bfseries addheader} (std\+::string label, std\+::string value, std\+::string comment)
\item 
\Hypertarget{class_pixel_map_a877d1d0f5bea57eb786153d5631813ba}\label{class_pixel_map_a877d1d0f5bea57eb786153d5631813ba} 
{\bfseries Pixel\+Map} (const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ double $>$ \&other)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{class_pixel_map_a57a361a688eb28a448da14820123d0cb}\label{class_pixel_map_a57a361a688eb28a448da14820123d0cb} 
static void {\bfseries swap} (\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&, \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T = double$>$\newline
class Pixel\+Map$<$ T $>$}
Image structure that can be manipulated and exported to/from fits files. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_pixel_map_a4578eac86acffad52ce76093ec0b804a}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_a4578eac86acffad52ce76093ec0b804a} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{, }\item[{double}]{res\+\_\+ratio}{}\end{DoxyParamCaption})}



Creates a \doxylink{class_pixel_map}{Pixel\+Map} at a different resolution. The new counts are calculated integrating over the input pixels. No interpolation or smoothing is performed. 


\begin{DoxyParams}{Parameters}
{\em res\+\_\+ratio} & resolution of map is res\+\_\+ratio times the resolution of the input map \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a9086682cb7635da45491efb2ffc4daf6}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_a9086682cb7635da45491efb2ffc4daf6} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{, }\item[{const double \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{std\+::size\+\_\+t}]{my\+\_\+\+Npixels}{}\end{DoxyParamCaption})}



Creates a new \doxylink{class_pixel_map}{Pixel\+Map} from a square region of a \doxylink{class_pixel_map}{Pixel\+Map}. If the region exceeds the boundaries of the original map, the new map is completed with zeros. 


\begin{DoxyParams}{Parameters}
{\em center} & Input \doxylink{class_pixel_map}{Pixel\+Map} (from which the stamp is taken)  \\
\hline
{\em my\+\_\+\+Npixels} & center of the region to be duplicated (in rads) size of the region to be duplicated (in pixels) \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ad57ffb9bb4274f30079044f9afbdc0c0}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_ad57ffb9bb4274f30079044f9afbdc0c0} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{, }\item[{long}]{nx}{, }\item[{long}]{ny}{, }\item[{std\+::size\+\_\+t}]{my\+\_\+\+Npixels}{}\end{DoxyParamCaption})}



Produces a square cut-\/out of the input \doxylink{class_pixel_map}{Pixel\+Map}. 


\begin{DoxyParams}{Parameters}
{\em nx} & Input \doxylink{class_pixel_map}{Pixel\+Map} (from which the stamp is taken)  \\
\hline
{\em ny} & lower left pixels of in pmap  \\
\hline
{\em my\+\_\+\+Npixels} & lower left pixels of in pmap size of the region to be duplicated (in pixels) \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a3bebdffb73b5ee2665366e4a3bdfb90e}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_a3bebdffb73b5ee2665366e4a3bdfb90e} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{const double \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{std\+::size\+\_\+t}]{Npixels}{, }\item[{double}]{resolution}{, }\item[{Pixel\+Map\+Units}]{u}{ = {\ttfamily PixelMapUnits\+:\+:ndef}}\end{DoxyParamCaption})}



make square \doxylink{class_pixel_map}{Pixel\+Map} 


\begin{DoxyParams}{Parameters}
{\em Npixels} & The location of the center of the map  \\
\hline
{\em resolution} & Number of pixels in one dimension of map. One dimensional range of map in whatever units the point positions are in \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a420dcaae788313e3dc529073bcc35dcd}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_a420dcaae788313e3dc529073bcc35dcd} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{const double \texorpdfstring{$\ast$}{*}}]{center}{, }\item[{std\+::size\+\_\+t}]{my\+Nx}{, }\item[{std\+::size\+\_\+t}]{my\+Ny}{, }\item[{double}]{resolution}{, }\item[{Pixel\+Map\+Units}]{u}{ = {\ttfamily PixelMapUnits\+:\+:ndef}}\end{DoxyParamCaption})}



make rectangular \doxylink{class_pixel_map}{Pixel\+Map} with square pixels 


\begin{DoxyParams}{Parameters}
{\em my\+Nx} & The location of the center of the map  \\
\hline
{\em my\+Ny} & Number of pixels in x dimension of map.  \\
\hline
{\em resolution} & Number of pixels in y dimension of map. One dimensional range of map in whatever units the point positions are in \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ac7820da839276b6a4d4a514794ffdebd}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PixelMap@{PixelMap}}
\index{PixelMap@{PixelMap}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PixelMap()}{PixelMap()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \label{class_pixel_map_ac7820da839276b6a4d4a514794ffdebd} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\mbox{\hyperlink{class_pixel_map}{\+::\+Pixel\+Map}} (\begin{DoxyParamCaption}\item[{std\+::string}]{fitsfilename}{, }\item[{double}]{my\+\_\+res}{ = {\ttfamily -\/1}, }\item[{Pixel\+Map\+Units}]{u}{ = {\ttfamily PixelMapUnits\+:\+:ndef}}\end{DoxyParamCaption})}



Constructs a \doxylink{class_pixel_map}{Pixel\+Map} reading in a fits file Infos about resolution, Npixels and center are read from the header. 


\begin{DoxyParams}{Parameters}
{\em fitsfilename} & file name of fits file to be read  \\
\hline
{\em my\+\_\+res} & resolution (rad) of fits image if not given in fits file, use default or -\/1 otherwise \\
\hline
\end{DoxyParams}


\doxysubsection{Member Function Documentation}
\Hypertarget{class_pixel_map_a7f51e20e0935f5b01446482498d0864e}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddCurve@{AddCurve}}
\index{AddCurve@{AddCurve}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddCurve()}{AddCurve()}}
{\footnotesize\ttfamily \label{class_pixel_map_a7f51e20e0935f5b01446482498d0864e} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Curve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}}]{curve}{, }\item[{T}]{value}{}\end{DoxyParamCaption})}



Draws a closed curve through the points in curve-\/\texorpdfstring{$>$}{>}imagekist. 

This differs form Pixel\+Map$<$\+T$>$\+::\+Add\+Image() in that it draws lines between the points and takes no account of the cells that the points are in or the surface brightness. The points must be ordered already. Particularly useful for drawing the caustics that may have irregular cell sizes. The last point will be connected to the first point. \Hypertarget{class_pixel_map_aff6dbacdcd7c070656b1035dbd593333}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddGrid@{AddGrid}}
\index{AddGrid@{AddGrid}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddGrid()}{AddGrid()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_aff6dbacdcd7c070656b1035dbd593333} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Grid (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_grid}{Grid}} \&}]{grid}{, }\item[{\mbox{\hyperlink{standard_8h_a73d5f5042d9b38366d0b3781d199f9e7}{Lensing\+Variable}}}]{val}{}\end{DoxyParamCaption})}



Fills in pixels with the selected quantity from the grid points. 

The grid and \doxylink{class_pixel_map}{Pixel\+Map} do not need to be related in any way. Using this function multiple grids can be added to the same image.

This is for lensing quantities and not surface brightness. If you want surface brightness use \doxylink{class_pixel_map_a2ddead4c956462ef153fff9fe3c2bafc}{Pixel\+Map$<$\+T$>$\+::\+Add\+Grid\+Brightness()}

Warning\+: When adding a new grid it should not overlap with any of the previously added grids. \Hypertarget{class_pixel_map_ae0ff75f357f02175e649a051441aa0d4}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddGrid@{AddGrid}}
\index{AddGrid@{AddGrid}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddGrid()}{AddGrid()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_ae0ff75f357f02175e649a051441aa0d4} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Grid (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_grid}{Grid}} \&}]{grid}{, }\item[{T}]{value}{ = {\ttfamily 1.0}}\end{DoxyParamCaption})}



Fills in pixels where the image plane points in the grid are located with the value given. 

This is for lensing quantities and not surface brightness. If you want surface brightness use \doxylink{class_pixel_map_a2ddead4c956462ef153fff9fe3c2bafc}{Pixel\+Map$<$\+T$>$\+::\+Add\+Grid\+Brightness()} \Hypertarget{class_pixel_map_aa099074dcde4e989b474626ac8bde801}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddImages@{AddImages}}
\index{AddImages@{AddImages}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddImages()}{AddImages()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_aa099074dcde4e989b474626ac8bde801} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Images (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}}]{imageinfo}{, }\item[{int}]{Nimages}{, }\item[{float}]{rescale}{ = {\ttfamily 1.}}\end{DoxyParamCaption})}



Add an image to the map. 

If rescale==0 gives constant surface brightness, if \texorpdfstring{$<$}{<} 0 the surface brightness is not scaled by the pixel area as for the flux (default\+: 1). Negative values are good for mapping some quantity independant of the pixel size 
\begin{DoxyParams}{Parameters}
{\em imageinfo} & An array of Image\+Info-\/s. There is no reason to separate images for this routine  \\
\hline
{\em Nimages} & Number of images on input.  \\
\hline
{\em rescale} & rescales the surface brightness while leaving the image unchanged, see full notes \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a56250435304af6f8a2e1b858af627554}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddImages@{AddImages}}
\index{AddImages@{AddImages}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddImages()}{AddImages()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_a56250435304af6f8a2e1b858af627554} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Images (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \mbox{\hyperlink{struct_image_info}{Image\+Info}} $>$ \&}]{imageinfo}{, }\item[{int}]{Nimages}{, }\item[{float}]{rescale}{ = {\ttfamily 1.}}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em imageinfo} & An array of Image\+Info-\/s. There is no reason to separate images for this routine  \\
\hline
{\em Nimages} & Number of images on input.  \\
\hline
{\em rescale} & rescales the surface brightness while leaving the image unchanged, see full notes \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a21a76b59535155e8cb1e59232f6ec6d0}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!AddUniformImages@{AddUniformImages}}
\index{AddUniformImages@{AddUniformImages}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{AddUniformImages()}{AddUniformImages()}}
{\footnotesize\ttfamily \label{class_pixel_map_a21a76b59535155e8cb1e59232f6ec6d0} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Add\+Uniform\+Images (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_image_info}{Image\+Info}} \texorpdfstring{$\ast$}{*}}]{imageinfo}{, }\item[{int}]{Nimages}{, }\item[{T}]{value}{}\end{DoxyParamCaption})}



Add images with uniform surface brightness set by input parameter value. 

This does not use the surface brightnesses stored in the image points. 
\begin{DoxyParams}{Parameters}
{\em imageinfo} & An array of Image\+Info-\/s. There is no reason to separate images for this routine \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a91ab87e9b1ded3ad323e1eec189e589b}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!convolve@{convolve}}
\index{convolve@{convolve}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{convolve()}{convolve()}}
{\footnotesize\ttfamily \label{class_pixel_map_a91ab87e9b1ded3ad323e1eec189e589b} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::convolve (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{kernel}{}\end{DoxyParamCaption})}



convolve the image with a kernel. 

It is assumed that the kernal has the same pixel size as the image.

The center of the kernel is at N/2+1. If it has an odd number of pixels in both directions this will be the center. \Hypertarget{class_pixel_map_a23dd9311eabc4c9fb07b5e21fe42cbbe}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!copy\_in@{copy\_in}}
\index{copy\_in@{copy\_in}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{copy\_in()}{copy\_in()}}
{\footnotesize\ttfamily \label{class_pixel_map_a23dd9311eabc4c9fb07b5e21fe42cbbe} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::copy\+\_\+in (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{}\end{DoxyParamCaption})}



copy a \doxylink{class_pixel_map}{Pixel\+Map} into this one. 

The size, resolution and center of the pixel maps are not changed and do not need to match. The input pixel map is added while conserving the area integral of the map within the area of overlaping pixels. \Hypertarget{class_pixel_map_ab070d54853aca7eb11ee4027d007b5d3}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!count\_islands@{count\_islands}}
\index{count\_islands@{count\_islands}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{count\_islands()}{count\_islands()}}
{\footnotesize\ttfamily \label{class_pixel_map_ab070d54853aca7eb11ee4027d007b5d3} 
template$<$typename T $>$ \\
int \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::count\+\_\+islands (\begin{DoxyParamCaption}\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{pixel\+\_\+index}{}\end{DoxyParamCaption}) const}



For a list of pixel indexes this will count and separated islands that are not connected. 

On return, \textquotesingle{}pixel\+\_\+index\textquotesingle{} is ordered into groups and the \textquotesingle{}heads\textquotesingle{} list points to the first elemant in each group plus the end of the list so that heads\mbox{[}i\mbox{]} to heads\mbox{[}i+1\mbox{]} is a group for 0 \texorpdfstring{$<$}{<}= i \texorpdfstring{$<$}{<}= ngroups. The number of groups is returned which is also heads.\+size() -\/ 1 \Hypertarget{class_pixel_map_ae1922a4d9a6015eabf8f8b63596d7d74}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!cutout@{cutout}}
\index{cutout@{cutout}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{cutout()}{cutout()}}
{\footnotesize\ttfamily \label{class_pixel_map_ae1922a4d9a6015eabf8f8b63596d7d74} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::cutout (\begin{DoxyParamCaption}\item[{long}]{xmin}{, }\item[{long}]{xmax}{, }\item[{long}]{ymin}{, }\item[{long}]{ymax}{}\end{DoxyParamCaption})}



cut out a part of the \doxylink{class_pixel_map}{Pixel\+Map} 

Inputs are in pixels. xmax and xmin are one after the disired region so that the output size is (xmax-\/xmin) x (ymax-\/ymin) \Hypertarget{class_pixel_map_ac3adfbd069aecd4feea2e34e8bc7849a}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!downsize@{downsize}}
\index{downsize@{downsize}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{downsize()}{downsize()}}
{\footnotesize\ttfamily \label{class_pixel_map_ac3adfbd069aecd4feea2e34e8bc7849a} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::downsize (\begin{DoxyParamCaption}\item[{int}]{n}{}\end{DoxyParamCaption})}



Creates a \doxylink{class_pixel_map}{Pixel\+Map} with a lower resolution. The value of the pixels are added for the new pixels. If n does not go into the orginial number of pixels evenly the right (top) redge is dropped. 


\begin{DoxyParams}{Parameters}
{\em n} & number of pixels each direction added into each new pixel \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ae8b5450b2b5aa75d97622cfa3df24b49}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!drawcircle@{drawcircle}}
\index{drawcircle@{drawcircle}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{drawcircle()}{drawcircle()}}
{\footnotesize\ttfamily \label{class_pixel_map_ae8b5450b2b5aa75d97622cfa3df24b49} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::drawcircle (\begin{DoxyParamCaption}\item[{Pos\+Type}]{r\+\_\+center}{\mbox{[}$\,$\mbox{]}, }\item[{Pos\+Type}]{radius}{, }\item[{Pos\+Type}]{value}{}\end{DoxyParamCaption})}



Draws a circle. 


\begin{DoxyParams}{Parameters}
{\em r\+\_\+center} & center of circle  \\
\hline
{\em radius} & radius of circle  \\
\hline
{\em value} & value that it is set to on the map \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a44f6f55891bc9534cc9f259fb8e71059}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!drawdisk@{drawdisk}}
\index{drawdisk@{drawdisk}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{drawdisk()}{drawdisk()}}
{\footnotesize\ttfamily \label{class_pixel_map_a44f6f55891bc9534cc9f259fb8e71059} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::drawdisk (\begin{DoxyParamCaption}\item[{Pos\+Type}]{r\+\_\+center}{\mbox{[}$\,$\mbox{]}, }\item[{Pos\+Type}]{radius}{, }\item[{Pos\+Type}]{value}{, }\item[{int}]{Nstrip}{}\end{DoxyParamCaption})}



Draws a disk. 


\begin{DoxyParams}{Parameters}
{\em r\+\_\+center} & center of disk  \\
\hline
{\em radius} & radius of disk  \\
\hline
{\em value} & value that it is set to on the map  \\
\hline
{\em Nstrip} & number of lines we want \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_afbddad3feb07c24ec2e00e1fe305e963}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!drawgrid@{drawgrid}}
\index{drawgrid@{drawgrid}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{drawgrid()}{drawgrid()}}
{\footnotesize\ttfamily \label{class_pixel_map_afbddad3feb07c24ec2e00e1fe305e963} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::drawgrid (\begin{DoxyParamCaption}\item[{int}]{N}{, }\item[{Pos\+Type}]{value}{}\end{DoxyParamCaption})}



draw a grid on the image that divides the each demension into N cells 

Draws a grid. \Hypertarget{class_pixel_map_a474b8c3fe3e9387f250f53f68a392416}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!drawline@{drawline}}
\index{drawline@{drawline}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{drawline()}{drawline()}}
{\footnotesize\ttfamily \label{class_pixel_map_a474b8c3fe3e9387f250f53f68a392416} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::drawline (\begin{DoxyParamCaption}\item[{double}]{x1}{\mbox{[}$\,$\mbox{]}, }\item[{double}]{x2}{\mbox{[}$\,$\mbox{]}, }\item[{T}]{value}{, }\item[{bool}]{add}{}\end{DoxyParamCaption})}



simple line 

Draws a line between two points on the image by setting the pixels equal to value.

TODO\+: Could be improved by detecting if the line passes through the map at all before starting. Could also be improved by making the line fatter by including neighbor points. 
\begin{DoxyParams}{Parameters}
{\em x1} & one end point of line  \\
\hline
{\em x2} & other end point of line  \\
\hline
{\em value} & value that it is set to on the map  \\
\hline
{\em add} & true \+: add value, false replace with value \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a3fc82c0d7ddb49f6cc1bdfed928fc0df}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!drawSquare@{drawSquare}}
\index{drawSquare@{drawSquare}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{drawSquare()}{drawSquare()}}
{\footnotesize\ttfamily \label{class_pixel_map_a3fc82c0d7ddb49f6cc1bdfed928fc0df} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::draw\+Square (\begin{DoxyParamCaption}\item[{Pos\+Type}]{p1}{\mbox{[}$\,$\mbox{]}, }\item[{Pos\+Type}]{p2}{\mbox{[}$\,$\mbox{]}, }\item[{Pos\+Type}]{value}{}\end{DoxyParamCaption})}



Draw a rectangle. 

Draws a square. \Hypertarget{class_pixel_map_a0c3b6e8e5c63e799d47105e37810fe69}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!duplicate@{duplicate}}
\index{duplicate@{duplicate}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{duplicate()}{duplicate()}}
{\footnotesize\ttfamily \label{class_pixel_map_a0c3b6e8e5c63e799d47105e37810fe69} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::duplicate (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{}\end{DoxyParamCaption})}



copy a \doxylink{class_pixel_map}{Pixel\+Map} that must be the same without creating a new one.. 

This avoids calling a any constructor or destructor. \Hypertarget{class_pixel_map_ad790d8c0bf6a429502f3bb53c386d16d}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!find\_index@{find\_index}}
\index{find\_index@{find\_index}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{find\_index()}{find\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_ad790d8c0bf6a429502f3bb53c386d16d} 
template$<$typename T $>$ \\
long \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::find\+\_\+index (\begin{DoxyParamCaption}\item[{Pos\+Type const}]{x}{\mbox{[}$\,$\mbox{]}, }\item[{long \&}]{ix}{, }\item[{long \&}]{iy}{}\end{DoxyParamCaption}) const}



get the index for a position, returns -\/1 if out of map, this version returns the 2D grid coordinates 

get the index for a position, returns -\/1 if out of map \Hypertarget{class_pixel_map_a6ed8d82cec418b7e82b0084262499f08}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!find\_index@{find\_index}}
\index{find\_index@{find\_index}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{find\_index()}{find\_index()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_a6ed8d82cec418b7e82b0084262499f08} 
template$<$typename T $>$ \\
long \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::find\+\_\+index (\begin{DoxyParamCaption}\item[{Pos\+Type}]{x}{, }\item[{Pos\+Type}]{y}{, }\item[{long \&}]{ix}{, }\item[{long \&}]{iy}{}\end{DoxyParamCaption}) const}



get the index for a position, returns -\/1 if out of map, this version returns the 2D grid coordinates 

get the index for a position, returns -\/1 if out of map \Hypertarget{class_pixel_map_ab5d53bd6858dacac2cf2d129bf72125a}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!find\_islands\_holes@{find\_islands\_holes}}
\index{find\_islands\_holes@{find\_islands\_holes}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{find\_islands\_holes()}{find\_islands\_holes()}}
{\footnotesize\ttfamily \label{class_pixel_map_ab5d53bd6858dacac2cf2d129bf72125a} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::find\+\_\+islands\+\_\+holes (\begin{DoxyParamCaption}\item[{T}]{level}{, }\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{points}{}\end{DoxyParamCaption}) const}

find all the points above level divided into seprated groups

Groups with points are connected regions above level. Groups without points are regions surrounded by regions above level, i.\+e. holes. \Hypertarget{class_pixel_map_a5417da9f568360b9e7b11fdbbf0ac720}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!interpolate@{interpolate}}
\index{interpolate@{interpolate}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{interpolate()}{interpolate()}}
{\footnotesize\ttfamily \label{class_pixel_map_a5417da9f568360b9e7b11fdbbf0ac720} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::interpolate (\begin{DoxyParamCaption}\item[{int}]{n}{}\end{DoxyParamCaption})}



Makes a \doxylink{class_pixel_map}{Pixel\+Map} with resolution 1/n of the original with the values linearly interpolated. 

This normalizes so that the sum of the pixels is approximately constant. \Hypertarget{class_pixel_map_af606be8c453f60f9434005e7dddd6ecf}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!lens\_definition@{lens\_definition}}
\index{lens\_definition@{lens\_definition}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{lens\_definition()}{lens\_definition()}}
{\footnotesize\ttfamily \label{class_pixel_map_af606be8c453f60f9434005e7dddd6ecf} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::lens\+\_\+definition (\begin{DoxyParamCaption}\item[{T}]{min\+\_\+sn\+\_\+per\+\_\+image}{, }\item[{T}]{pixel\+\_\+threshold}{, }\item[{int \&}]{Nimages}{, }\item[{T \&}]{total\+\_\+sig\+\_\+noise\+\_\+source}{, }\item[{std\+::vector$<$ size\+\_\+t $>$ \&}]{maxima\+\_\+indexes}{, }\item[{std\+::vector$<$ std\+::vector$<$ size\+\_\+t $>$ $>$ \&}]{image\+\_\+points}{, }\item[{bool \&}]{lens\+\_\+\+TF}{, }\item[{T \&}]{level}{, }\item[{size\+\_\+t \&}]{n\+\_\+pix\+\_\+in\+\_\+source}{, }\item[{bool}]{verbose}{ = {\ttfamily false}}\end{DoxyParamCaption})}

This applies a definition of lesning for a resolved source based on that of Sonnenfeld et al. 2023

This is meant to be used on a signal-\/to-\/noise map of the lensed source only.

The definition does the following tests\+: 1) define a footprint at surface brightness level {\ttfamily pixel\+\_\+threshold} 2) romove disconected region that have signal-\/to-\/noise below {\ttfamily min\+\_\+sn\+\_\+per\+\_\+image} 3) if there are multiple images or a hole in the image {\ttfamily lens\+\_\+\+TF =true} 4) if there is one image with no hole increase the threshold and apply 3) until the it is classified as a lens or it reaches the maximum surface brightness level 
\begin{DoxyParams}{Parameters}
{\em min\+\_\+sn\+\_\+per\+\_\+image} & signal-\/to-\/noise required for a seporate image (ex 10)  \\
\hline
{\em pixel\+\_\+threshold} & signal-\/to-\/noise threshold that defines the footprint (ex. 2)  \\
\hline
{\em Nimages} & the number of images  \\
\hline
{\em total\+\_\+sig\+\_\+noise\+\_\+source} & gives the total signal-\/to-\/noise of all images  \\
\hline
{\em maxima\+\_\+indexes} & index of maxima  \\
\hline
{\em lens\+\_\+\+TF} & whether it passes lens diffintion  \\
\hline
{\em level} & levels on which the multiple images are defined  \\
\hline
{\em n\+\_\+pix\+\_\+in\+\_\+source} & number of pixels in footprint \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_aea3c0baa3f140277633c55eeeb7bf038}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!linear\_interpolate@{linear\_interpolate}}
\index{linear\_interpolate@{linear\_interpolate}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{linear\_interpolate()}{linear\_interpolate()}}
{\footnotesize\ttfamily \label{class_pixel_map_aea3c0baa3f140277633c55eeeb7bf038} 
template$<$typename T $>$ \\
T \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::linear\+\_\+interpolate (\begin{DoxyParamCaption}\item[{Pos\+Type}]{x}{\mbox{[}$\,$\mbox{]}}\end{DoxyParamCaption})}



interpolate to point x\mbox{[}\mbox{]} 

bilinear interpolation\Hypertarget{class_pixel_map_aed061b06d8259988ea3cf3e48edade3c}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!maxima@{maxima}}
\index{maxima@{maxima}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{maxima()}{maxima()}}
{\footnotesize\ttfamily \label{class_pixel_map_aed061b06d8259988ea3cf3e48edade3c} 
template$<$typename T $>$ \\
std\+::vector$<$ size\+\_\+t $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::maxima (\begin{DoxyParamCaption}\item[{T}]{minlevel}{}\end{DoxyParamCaption}) const}



find maxima that are above minlevel 

find the index of the pixels that are larger than all its neighbors \Hypertarget{class_pixel_map_ad86932f2017231a958bc43a30b86a1fa}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!paste@{paste}}
\index{paste@{paste}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{paste()}{paste()}}
{\footnotesize\ttfamily \label{class_pixel_map_ad86932f2017231a958bc43a30b86a1fa} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::paste (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \&}]{pmap}{}\end{DoxyParamCaption})}



Replace overlaping pixel values with those of the input map. 

No attempt is made to interpolate or average the pixels of pmap. No integration is done. If the resolution of input map is higher than the reslution of the map then the pixels values will just be that of the last pixel visited while going through them.

This can be used to sew tiles together into a larger map. \Hypertarget{class_pixel_map_a5b1b128379f118e89c902a6a1aa4ad18}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PowerSpectrum@{PowerSpectrum}}
\index{PowerSpectrum@{PowerSpectrum}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PowerSpectrum()}{PowerSpectrum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_a5b1b128379f118e89c902a6a1aa4ad18} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Power\+Spectrum (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{power\+\_\+spectrum}{, }\item[{const std\+::vector$<$ Pos\+Type $>$ \&}]{lbins}{, }\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{lave}{, }\item[{bool}]{overwrite}{ = {\ttfamily true}}\end{DoxyParamCaption})}



Find the power spectrum of the map. 


\begin{DoxyParams}{Parameters}
{\em power\+\_\+spectrum} & output power spectrum  \\
\hline
{\em lbins} & output l values of bands  \\
\hline
{\em lave} & output l values of bands  \\
\hline
{\em overwrite} & if false add power to existing power\+\_\+spectrum (used for averaging over many fields \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ac45faa9d9180823398c1cd48c6ec366b}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!PowerSpectrum@{PowerSpectrum}}
\index{PowerSpectrum@{PowerSpectrum}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{PowerSpectrum()}{PowerSpectrum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_ac45faa9d9180823398c1cd48c6ec366b} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::\+Power\+Spectrum (\begin{DoxyParamCaption}\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{power\+\_\+spectrum}{, }\item[{std\+::vector$<$ Pos\+Type $>$ \&}]{lvec}{, }\item[{bool}]{overwrite}{ = {\ttfamily true}}\end{DoxyParamCaption})}



Find the power spectrum of the map. 


\begin{DoxyParams}{Parameters}
{\em power\+\_\+spectrum} & output power spectrum  \\
\hline
{\em lvec} & output l values of bands  \\
\hline
{\em overwrite} & if false add power to existing power\+\_\+spectrum (used for averaging over many fields \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a3b3ca3285aeee1f6b1c3be7a6ffa657d}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!printFITS@{printFITS}}
\index{printFITS@{printFITS}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{printFITS()}{printFITS()}}
{\footnotesize\ttfamily \label{class_pixel_map_a3b3ca3285aeee1f6b1c3be7a6ffa657d} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::print\+FITS (\begin{DoxyParamCaption}\item[{std\+::string}]{filename}{, }\item[{std\+::vector$<$ std\+::string $>$ \&}]{headercards}{}\end{DoxyParamCaption})}



This overides all header information and relaces it with the inputs. Meant for making a modified copy. 


\begin{DoxyParams}{Parameters}
{\em filename} & file to create  \\
\hline
{\em headercards} & header information in cfitsio "{}card"{} format \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ad6dc2e50ac4ec14a9d1b6e5598352f23}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!recenter@{recenter}}
\index{recenter@{recenter}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{recenter()}{recenter()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_ad6dc2e50ac4ec14a9d1b6e5598352f23} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::recenter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}}}]{newcenter}{}\end{DoxyParamCaption})}


\begin{DoxyParams}{Parameters}
{\em newcenter} & in radians \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_ab16b0dccdadeb421760d111bfd2a5699}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!recenter@{recenter}}
\index{recenter@{recenter}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{recenter()}{recenter()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \label{class_pixel_map_ab16b0dccdadeb421760d111bfd2a5699} 
template$<$typename T $>$ \\
void \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::recenter (\begin{DoxyParamCaption}\item[{Pos\+Type}]{newcenter}{\mbox{[}2\mbox{]}}\end{DoxyParamCaption})}



recenter the map without changing anything else. 


\begin{DoxyParams}{Parameters}
{\em newcenter} & in radians \\
\hline
\end{DoxyParams}
\Hypertarget{class_pixel_map_a2d6fe4ee3ffdb3b860843b657e9a4a46}\index{PixelMap$<$ T $>$@{PixelMap$<$ T $>$}!rotate@{rotate}}
\index{rotate@{rotate}!PixelMap$<$ T $>$@{PixelMap$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{rotate()}{rotate()}}
{\footnotesize\ttfamily \label{class_pixel_map_a2d6fe4ee3ffdb3b860843b657e9a4a46} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$ \mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ T $>$\+::rotate (\begin{DoxyParamCaption}\item[{Pos\+Type}]{theta}{, }\item[{T}]{scale}{ = {\ttfamily 1}}\end{DoxyParamCaption})}



rotate and scale the image while keeping pixels, resoluiton 


\begin{DoxyParams}{Parameters}
{\em theta} & counter-\/clockwise rotation (radians)  \\
\hline
{\em scale} & scale \texorpdfstring{$<$}{<}1 shrinks it \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
SLsim\+Lib/include/pixelmap.\+h\item 
SLsim\+Lib/\+Image\+Processing/pixelmap.\+cpp\end{DoxyCompactItemize}
