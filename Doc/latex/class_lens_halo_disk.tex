\doxysection{Lens\+Halo\+Disk\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{class_lens_halo_disk}{}\label{class_lens_halo_disk}\index{LensHaloDisk$<$ T $>$@{LensHaloDisk$<$ T $>$}}


Creates a exponential disk out of particles.  




{\ttfamily \#include $<$disk.\+h$>$}



Inheritance diagram for Lens\+Halo\+Disk\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=199pt]{class_lens_halo_disk__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Lens\+Halo\+Disk\texorpdfstring{$<$}{<} T \texorpdfstring{$>$}{>}\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{class_lens_halo_disk__coll__graph}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_lens_halo_disk_a67f57cb9d8ae287d948efeee3be962bb}{Lens\+Halo\+Disk}} (double mass, double disk\+\_\+scale, double Rperp, double mass\+\_\+res, float my\+\_\+\+PA, float my\+\_\+inclination, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran, float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, int Nsmooth=64)
\item 
\Hypertarget{class_lens_halo_disk_a4b8bbc4385f4e11d544aa5dd18994311}\label{class_lens_halo_disk_a4b8bbc4385f4e11d544aa5dd18994311} 
{\bfseries Lens\+Halo\+Disk} (\mbox{\hyperlink{class_lens_halo_disk}{Lens\+Halo\+Disk}} \&\&h)
\item 
\Hypertarget{class_lens_halo_disk_ae5c70078ae1dfc3201da4b0ebe324e86}\label{class_lens_halo_disk_ae5c70078ae1dfc3201da4b0ebe324e86} 
\mbox{\hyperlink{class_lens_halo_disk}{Lens\+Halo\+Disk}} \& {\bfseries operator=} (\mbox{\hyperlink{class_lens_halo_disk}{Lens\+Halo\+Disk}} \&\&h)
\item 
\Hypertarget{class_lens_halo_disk_a7395242b513238bd5a5546791604786e}\label{class_lens_halo_disk_a7395242b513238bd5a5546791604786e} 
void {\bfseries reorient} (float my\+\_\+inclination, float my\+\_\+\+PA)
\begin{DoxyCompactList}\small\item\em Reorient the disk. \end{DoxyCompactList}\item 
\Hypertarget{class_lens_halo_disk_acc77a9dec1025e4c9671b726c8125a88}\label{class_lens_halo_disk_acc77a9dec1025e4c9671b726c8125a88} 
float {\bfseries get\+Inclination} ()
\begin{DoxyCompactList}\small\item\em inclination in radians, 0 is face on \end{DoxyCompactList}\item 
\Hypertarget{class_lens_halo_disk_a83cbc1ac0a53458f122b77d939d62b72}\label{class_lens_halo_disk_a83cbc1ac0a53458f122b77d939d62b72} 
float {\bfseries get\+PA} ()
\begin{DoxyCompactList}\small\item\em postion angle in radians, \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles$<$ Particle\+Type$<$ float $>$ $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_lens_halo_particles_a9930f80c98af4265ecd12f72419aa7fa}{Lens\+Halo\+Particles}} (const std\+::string \&simulation\+\_\+filename, \mbox{\hyperlink{particle__types_8h_a37e57edf96c5308d47d38beee2b4cb2c}{Sim\+File\+Format}} format, Pos\+Type redshift, int Nsmooth, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta\+\_\+rotate, bool recenter, bool my\+\_\+multimass, double inv\+\_\+area, Pos\+Type Min\+PSize=0, Pos\+Type rescale\+\_\+mass=1.\+0, bool verbose=false)
\item 
\mbox{\hyperlink{class_lens_halo_particles_abcbba40dce46b265c1873f32820fb71b}{Lens\+Halo\+Particles}} (std\+::vector$<$ Particle\+Type$<$ float $>$ $>$ \&pvector, float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta\+\_\+rotate, bool recenter, double my\+\_\+inv\+\_\+area, float Min\+PSize=0, double max\+\_\+range=-\/1, bool verbose=false)
\item 
\mbox{\hyperlink{class_lens_halo_particles_a48d4ed53ba5e81f0af6a1339423fbe66}{Lens\+Halo\+Particles}} (Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}begin, size\+\_\+t n, float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta\+\_\+rotate, bool recenter, double my\+\_\+inv\+\_\+area, float Min\+PSize=0, double max\+\_\+range=-\/1, bool verbose=false)
\begin{DoxyCompactList}\small\item\em this constructor does not take possession of the particles \end{DoxyCompactList}\item 
{\bfseries Lens\+Halo\+Particles} (\mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles}} \&\&h)
\item 
\mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles}}$<$ Particle\+Type$<$ float $>$ $>$ \& {\bfseries operator=} (\mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles}}$<$ Particle\+Type$<$ float $>$ $>$ \&\&h)
\item 
void \mbox{\hyperlink{class_lens_halo_particles_a9b240b0b6e022039c971dde8864ce6fd}{force\+\_\+halo}} (double \texorpdfstring{$\ast$}{*}alpha, Kappa\+Type \texorpdfstring{$\ast$}{*}kappa, Kappa\+Type \texorpdfstring{$\ast$}{*}gamma, Kappa\+Type \texorpdfstring{$\ast$}{*}phi, double const \texorpdfstring{$\ast$}{*}xcm, bool subtract\+\_\+point=false, Pos\+Type screening=1.\+0)
\item 
size\+\_\+t {\bfseries getN} () const
\item 
void \mbox{\hyperlink{class_lens_halo_particles_a6d2a87ae29ff2a1840ffced17599d8a9}{rotate}} (\mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta)
\begin{DoxyCompactList}\small\item\em rotate the simulation around the origin of the simulation coordinates, (radians) \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_point__3d}{Point\+\_\+3d}} {\bfseries Center\+Of\+Mass} ()
\begin{DoxyCompactList}\small\item\em get current center of mass in input coordinates \end{DoxyCompactList}\item 
\mbox{\hyperlink{struct_point__3d}{Point\+\_\+3d}} {\bfseries Densest\+Point} ()
\begin{DoxyCompactList}\small\item\em get the densistt point in input coordinates \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_lens_halo_particles_a4fbe0f1a990d0e8c070e4f79b5c831b8}{read\+Position\+File\+ASCII}} (const std\+::string \&filename)
\begin{DoxyCompactList}\small\item\em Reads number of particle and particle positons into Npoint and xp from a ASCII file. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries Lens\+Halo} ()
\begin{DoxyCompactList}\small\item\em Shell constructor. \end{DoxyCompactList}\item 
{\bfseries Lens\+Halo} (Pos\+Type z, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo)
\item 
\mbox{\hyperlink{class_lens_halo_a0b96fdb10f3a10a2b65085fa5883ec1f}{Lens\+Halo}} (const \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \&h)
\item 
{\bfseries Lens\+Halo} (\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \&\&h)
\item 
\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \& \mbox{\hyperlink{class_lens_halo_aaa135c7e56a24de4a1dee76604a44141}{operator=}} (const \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \&h)
\item 
\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \& \mbox{\hyperlink{class_lens_halo_a9be986a94c12228b2e5c173c1cf5d85c}{operator=}} (\mbox{\hyperlink{class_lens_halo}{Lens\+Halo}} \&\&h)
\item 
float \mbox{\hyperlink{class_lens_halo_a6aee0c9abc88ca6d3d8ed9e44a18e6e3}{get\+\_\+\+Rmax}} () const
\begin{DoxyCompactList}\small\item\em this can be used to tag types of Lens\+Halos \end{DoxyCompactList}\item 
float {\bfseries get\+Rsize} () const
\begin{DoxyCompactList}\small\item\em get the Rsize which is the size of the halo in Mpc \end{DoxyCompactList}\item 
float {\bfseries get\+\_\+mass} () const
\begin{DoxyCompactList}\small\item\em get the mass solar units \end{DoxyCompactList}\item 
float {\bfseries get\+\_\+rscale} () const
\begin{DoxyCompactList}\small\item\em get the scale radius in Mpc \end{DoxyCompactList}\item 
Pos\+Type {\bfseries get\+Zlens} () const
\begin{DoxyCompactList}\small\item\em get the redshift \end{DoxyCompactList}\item 
void {\bfseries getX} (Pos\+Type \texorpdfstring{$\ast$}{*}My\+Pos\+Halo) const
\begin{DoxyCompactList}\small\item\em get the position of the Halo in physical Mpc on the lens plane \end{DoxyCompactList}\item 
Pos\+Type {\bfseries operator\mbox{[}$\,$\mbox{]}} (int i) const
\begin{DoxyCompactList}\small\item\em returns position of the Halo in physical Mpc on the lens plane \end{DoxyCompactList}\item 
void {\bfseries set\+Theta} (Pos\+Type PosX, Pos\+Type PosY)
\begin{DoxyCompactList}\small\item\em set the position of the Halo in radians \end{DoxyCompactList}\item 
void {\bfseries set\+Theta} (Pos\+Type \texorpdfstring{$\ast$}{*}Pos\+XY)
\begin{DoxyCompactList}\small\item\em set the position of the Halo in radians \end{DoxyCompactList}\item 
void {\bfseries set\+Theta} (const \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} \&p)
\begin{DoxyCompactList}\small\item\em set the position of the Halo in radians \end{DoxyCompactList}\item 
void {\bfseries get\+Theta} (Pos\+Type \texorpdfstring{$\ast$}{*}My\+Pos\+Halo) const
\begin{DoxyCompactList}\small\item\em get the position of the Halo in radians \end{DoxyCompactList}\item 
void {\bfseries set\+Dist} (\mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&co)
\begin{DoxyCompactList}\small\item\em Set the angular size distance to the halo. This should be the distance to the lens plane. \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{class_lens_halo_a50bd89dc5d7d11932c757eb4e962b6ba}{get\+Dist}} () const
\item 
void \mbox{\hyperlink{class_lens_halo_a81938111b0d90611edcff8b2d4dd8432}{display\+Pos}} ()
\item 
virtual void \mbox{\hyperlink{class_lens_halo_a645d2cbd9e686ce0d061d83d28c88eb0}{init\+From\+File}} (float my\+\_\+mass, long \texorpdfstring{$\ast$}{*}seed, float vmax, float r\+\_\+halfmass)
\begin{DoxyCompactList}\small\item\em initialize from a simulation file \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_lens_halo_a8b31bdf68c61572e7a32dc3da6b139c8}{init\+From\+Mass\+Func}} (float my\+\_\+mass, float my\+\_\+\+Rsize, float my\+\_\+rscale, Pos\+Type my\+\_\+slope, long \texorpdfstring{$\ast$}{*}seed)
\begin{DoxyCompactList}\small\item\em initialize from a mass function \end{DoxyCompactList}\item 
virtual void {\bfseries set\+\_\+\+Rsize\+Rmax} (float my\+\_\+\+Rsize)
\begin{DoxyCompactList}\small\item\em set Rsize (in Mpc) and reset Rmax \end{DoxyCompactList}\item 
void {\bfseries set\+\_\+mass} (float my\+\_\+mass)
\begin{DoxyCompactList}\small\item\em set mass (in solar masses) \end{DoxyCompactList}\item 
virtual void {\bfseries set\+\_\+rscale} (float my\+\_\+rscale)
\begin{DoxyCompactList}\small\item\em set scale radius (in Mpc) \end{DoxyCompactList}\item 
void {\bfseries set\+Zlens} (Pos\+Type my\+\_\+zlens, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo)
\begin{DoxyCompactList}\small\item\em set redshift \end{DoxyCompactList}\item 
void {\bfseries set\+Rsize} (Pos\+Type R)
\item 
void {\bfseries set\+Zlens\+Dist} (Pos\+Type my\+\_\+zlens, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cos)
\item 
void {\bfseries set\+Mass} (Pos\+Type m)
\item 
virtual void \mbox{\hyperlink{class_lens_halo_ababdb795dfb3955b14078a8fe777d608}{set\+\_\+slope}} (Pos\+Type my\+\_\+slope)
\begin{DoxyCompactList}\small\item\em set slope \end{DoxyCompactList}\item 
virtual Pos\+Type \mbox{\hyperlink{class_lens_halo_a2deb914a879890de10a76323cf056aae}{get\+\_\+slope}} ()
\begin{DoxyCompactList}\small\item\em get slope \end{DoxyCompactList}\item 
bool {\bfseries get\+\_\+flag\+\_\+elliptical} ()
\begin{DoxyCompactList}\small\item\em flag=True if halo elliptical \end{DoxyCompactList}\item 
void {\bfseries set\+\_\+flag\+\_\+elliptical} (bool ell)
\item 
bool {\bfseries get\+\_\+switch\+\_\+flag} ()
\item 
void {\bfseries set\+\_\+switch\+\_\+flag} (bool swt)
\begin{DoxyCompactList}\small\item\em flag permits case distinction in force\+\_\+halo\+\_\+asym for elliptical NFWs only (get\+\_\+switch\+\_\+flag==true), in latter case the mass\+\_\+norm\+\_\+factor\texorpdfstring{$^\wedge$}{\string^}2 is used instead of mass\+\_\+norm\+\_\+factor. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_lens_halo_ae93d20b6fdeaaab7d1f0a61a13e6d644}{set\+Cosmology}} (const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo)
\begin{DoxyCompactList}\small\item\em used for elliptical NFWs only, in that case get\+\_\+switch\+\_\+flag==true \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_lens_halo_a9125a5a6f4685d157dfbeacd00433ab2}{compareZ}} (Pos\+Type z)
\begin{DoxyCompactList}\small\item\em force tree calculation for stars \end{DoxyCompactList}\item 
\mbox{\hyperlink{_input_params_8h_abeeb8c8413457c56ac46767a52fc2618}{Ellip\+Method}} \mbox{\hyperlink{class_lens_halo_ae4e6a8b770a38df28c9bee8799385923}{get\+Ellip\+Method}} () const
\begin{DoxyCompactList}\small\item\em stars \end{DoxyCompactList}\item 
std\+::vector$<$ double $>$ {\bfseries get\+\_\+mod} ()
\begin{DoxyCompactList}\small\item\em get vector of Fourier modes, which are calculated in the constructors of the Lens\+Haloes when main\+\_\+ellip\+\_\+method is set to \textquotesingle{}Fourier\textquotesingle{} \end{DoxyCompactList}\item 
virtual std\+::size\+\_\+t {\bfseries Nparams} () const
\begin{DoxyCompactList}\small\item\em get the number of halo parameters \end{DoxyCompactList}\item 
virtual Pos\+Type {\bfseries get\+Param} (std\+::size\+\_\+t p) const
\begin{DoxyCompactList}\small\item\em get the value of a scaled halo parameter by index \end{DoxyCompactList}\item 
virtual Pos\+Type {\bfseries set\+Param} (std\+::size\+\_\+t p, Pos\+Type value)
\begin{DoxyCompactList}\small\item\em set the value of a scaled halo parameter by index \end{DoxyCompactList}\item 
virtual void {\bfseries print\+CSV} (std\+::ostream \&, bool header=false) const
\begin{DoxyCompactList}\small\item\em print the halo parameters in CSV format \end{DoxyCompactList}\item 
Pos\+Type \mbox{\hyperlink{class_lens_halo_a7184a202e39fac7cf8f7d0436abdc982}{Mass\+By2\+DIntegation}} (Pos\+Type R)
\begin{DoxyCompactList}\small\item\em Prints star parameters; if show\+\_\+stars is true, prints data for single stars. \end{DoxyCompactList}\item 
Pos\+Type {\bfseries Mass\+By1\+DIntegation} (Pos\+Type R)
\begin{DoxyCompactList}\small\item\em calculates the mass within radius R by integating alpha on a ring and using Gauss\textquotesingle{} law, used only for testing \end{DoxyCompactList}\item 
Pos\+Type {\bfseries test\+\_\+average\+\_\+gt} (Pos\+Type R)
\begin{DoxyCompactList}\small\item\em calculates the average gamma\+\_\+t for \doxylink{class_lens_halo_a9b357894d8d644741be0cec08e45bb30}{Lens\+Halo\+::test()} \end{DoxyCompactList}\item 
Pos\+Type {\bfseries test\+\_\+average\+\_\+kappa} (Pos\+Type R)
\item 
void {\bfseries set\+\_\+norm\+\_\+factor} ()
\item 
void {\bfseries set\+\_\+rsize} (float my\+\_\+rsize)
\begin{DoxyCompactList}\small\item\em set radius rsize beyond which interpolation values between alpha\+\_\+ellip and alpha\+\_\+iso are computed \end{DoxyCompactList}\item 
float {\bfseries get\+\_\+rsize} ()
\item 
bool \mbox{\hyperlink{class_lens_halo_a9b357894d8d644741be0cec08e45bb30}{test}} ()
\begin{DoxyCompactList}\small\item\em perform some basic consistancy checks for halo \end{DoxyCompactList}\item 
size\+\_\+t {\bfseries get\+ID} () const
\item 
void {\bfseries set\+ID} (size\+\_\+t id)
\item 
Pos\+Type {\bfseries renormalization} (Pos\+Type r\+\_\+max)
\item 
\mbox{\hyperlink{class_pixel_map}{Pixel\+Map}}$<$ double $>$ \mbox{\hyperlink{class_lens_halo_a0652d15d437d73b38dc8b057ed2c025f}{map\+\_\+variables}} (\mbox{\hyperlink{standard_8h_a73d5f5042d9b38366d0b3781d199f9e7}{Lensing\+Variable}} lensvar, size\+\_\+t Nx, size\+\_\+t Ny, double res)
\begin{DoxyCompactList}\small\item\em Map a \doxylink{class_pixel_map}{Pixel\+Map} of the surface, density, potential and potential gradient centred on (0,0) in \doxylink{class_lens_halo}{Lens\+Halo} coordinates. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Static Public Member Functions inherited from \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles$<$ Particle\+Type$<$ float $>$ $>$}}}
\begin{DoxyCompactItemize}
\item 
static void \mbox{\hyperlink{class_lens_halo_particles_a6f74ecb8b18030fe0f01136192d9e4bb}{make\+SIE}} (std\+::string new\+\_\+filename, Pos\+Type redshift, double particle\+\_\+mass, double total\+\_\+mass, double sigma, double q, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em This is a test static function that makes a truncated SIE out of particles and puts it into a file in the right format for constructing a \doxylink{class_lens_halo_particles}{Lens\+Halo\+Particles}. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles}}$<$ \mbox{\hyperlink{struct_particle_type_simple}{Particle\+Type\+Simple}} $>$ \mbox{\hyperlink{class_lens_halo_particles_a46def593bc40d817ca3c45d521b700ce}{SIE}} (Pos\+Type redshift, double particle\+\_\+mass, double total\+\_\+mass, double sigma, double q, int Nneighbors, \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&ran)
\begin{DoxyCompactList}\small\item\em This is a test static function that makes a truncated SIE out of particles and puts it into a file in the right format for constructing a \doxylink{class_lens_halo_particles}{Lens\+Halo\+Particles}. \end{DoxyCompactList}\item 
static void {\bfseries calculate\+\_\+smoothing} (int Nsmooth, Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}pp, size\+\_\+t Npoints, bool verbose=false)
\item 
static void {\bfseries write\+Sizes} (const std\+::string \&filename, int Nsmooth, const Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}pp, size\+\_\+t Npoints)
\item 
static bool {\bfseries read\+Sizes\+File} (const std\+::string \&filename, Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}pp, size\+\_\+t Npoints, int Nsmooth, Pos\+Type min\+\_\+size)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
static const int {\bfseries get\+\_\+\+Nmod} ()
\begin{DoxyCompactList}\small\item\em get length of mod array, which is Nmod. Not to be confused with get\+Nmodes in the class \doxylink{class_lens_halo_fit}{Lens\+Halo\+Fit} \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
int {\bfseries tag} =0
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles$<$ Particle\+Type$<$ float $>$ $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_lens_halo_particles_a287284a34695af4542c2dad6bf610baf}{Lens\+Halo\+Particles}} (float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo)
\item 
\mbox{\hyperlink{class_lens_halo_particles_a36d9e0624adb91026d7ac1c648800f8c}{Lens\+Halo\+Particles}} (Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}pdata, size\+\_\+t Nparticles, float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta\+\_\+rotate, bool recenter, double my\+\_\+inv\+\_\+area, bool verbose=false)
\item 
void {\bfseries rotate\+\_\+particles} (Pos\+Type theta\+\_\+x, Pos\+Type theta\+\_\+y)
\item 
void {\bfseries assign\+Params} (\mbox{\hyperlink{class_input_params}{Input\+Params}} \&params)
\item 
void \mbox{\hyperlink{class_lens_halo_particles_a96e7e332fc3494f003293e608ebc5bb6}{set\+\_\+up}} (float redshift, const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&cosmo, \mbox{\hyperlink{struct_point__2d}{Point\+\_\+2d}} theta\+\_\+rotate, double max\+\_\+range, bool recenter, bool verbose)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
Pos\+Type {\bfseries alpha\+\_\+int} (Pos\+Type x) const
\begin{DoxyCompactList}\small\item\em Calculates potential (phi\+\_\+int) from alpha\+\_\+h. If flag is\+\_\+alphah\+\_\+a\+\_\+table is True it takes and integrates directly the gfunction instead of alpha\+\_\+h. The gfunction is used for the Interpolation\+Table used in alpha\+\_\+h. Setting the flag to False speeds up the calculation of phi\+\_\+h. \end{DoxyCompactList}\item 
Pos\+Type {\bfseries norm\+\_\+int} (Pos\+Type r\+\_\+max)
\item 
void \mbox{\hyperlink{class_lens_halo_a374d199861689b8186c04d29bf92d6a2}{force\+\_\+halo\+\_\+sym}} (Pos\+Type \texorpdfstring{$\ast$}{*}alpha, Kappa\+Type \texorpdfstring{$\ast$}{*}kappa, Kappa\+Type \texorpdfstring{$\ast$}{*}gamma, Kappa\+Type \texorpdfstring{$\ast$}{*}phi, Pos\+Type const \texorpdfstring{$\ast$}{*}xcm, bool subtract\+\_\+point=false, Pos\+Type screening=1.\+0)
\begin{DoxyCompactList}\small\item\em returns the lensing quantities of a ray in center of mass coordinates for a symmetric halo \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_lens_halo_a78cc531d36104d72bec891424aba9fcb}{force\+\_\+halo\+\_\+asym}} (Pos\+Type \texorpdfstring{$\ast$}{*}alpha, Kappa\+Type \texorpdfstring{$\ast$}{*}kappa, Kappa\+Type \texorpdfstring{$\ast$}{*}gamma, Kappa\+Type \texorpdfstring{$\ast$}{*}phi, Pos\+Type const \texorpdfstring{$\ast$}{*}xcm, bool subtract\+\_\+point=false, Pos\+Type screening=1.\+0)
\item 
bool {\bfseries force\+\_\+point} (Pos\+Type \texorpdfstring{$\ast$}{*}alpha, Kappa\+Type \texorpdfstring{$\ast$}{*}kappa, Kappa\+Type \texorpdfstring{$\ast$}{*}gamma, Kappa\+Type \texorpdfstring{$\ast$}{*}phi, Pos\+Type const \texorpdfstring{$\ast$}{*}xcm, Pos\+Type rcm2, bool subtract\+\_\+point, Pos\+Type screening)
\item 
void {\bfseries assign\+Params} (\mbox{\hyperlink{class_input_params}{Input\+Params}} \&params, bool need\+Rsize)
\begin{DoxyCompactList}\small\item\em read in parameters from a parameterfile in \doxylink{class_input_params}{Input\+Params} params \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_lens_halo_a6a8cf22c76bab7821b1b0ee3b50ea75f}{error\+\_\+message1}} (std\+::string name, std\+::string filename)
\begin{DoxyCompactList}\small\item\em read in star parameters. This is valid for all halos and not overloaded. \end{DoxyCompactList}\item 
virtual Pos\+Type \mbox{\hyperlink{class_lens_halo_a9295b7b1d0a66b3742a81ead5bf2a863}{alpha\+\_\+h}} (Pos\+Type x) const
\item 
virtual Kappa\+Type {\bfseries kappa\+\_\+h} (Pos\+Type x) const
\item 
virtual Kappa\+Type {\bfseries gamma\+\_\+h} (Pos\+Type x) const
\item 
virtual Kappa\+Type {\bfseries phi\+\_\+h} (Pos\+Type x) const
\item 
virtual Kappa\+Type {\bfseries phi\+\_\+int} (Pos\+Type x) const
\item 
virtual Pos\+Type {\bfseries ffunction} (Pos\+Type x) const
\item 
virtual Pos\+Type {\bfseries gfunction} (Pos\+Type x) const
\item 
virtual Pos\+Type {\bfseries dgfunctiondx} (Pos\+Type x)
\item 
virtual Pos\+Type {\bfseries bfunction} (Pos\+Type x)
\item 
virtual Pos\+Type {\bfseries dhfunction} (Pos\+Type x) const
\item 
virtual Pos\+Type {\bfseries ddhfunction} (Pos\+Type x, bool numerical)
\item 
virtual Pos\+Type {\bfseries dddhfunction} (Pos\+Type x, bool numerical)
\item 
virtual Pos\+Type {\bfseries bnumfunction} (Pos\+Type x)
\item 
virtual Pos\+Type {\bfseries dbfunction} (Pos\+Type x)
\item 
virtual Pos\+Type {\bfseries ddbfunction} (Pos\+Type x)
\item 
virtual Pos\+Type \mbox{\hyperlink{class_lens_halo_afeafc7e19741a79fdf5b2d1e3b21f2ee}{dmoddb}} (int whichmod, Pos\+Type q, Pos\+Type b)
\item 
virtual Pos\+Type {\bfseries ddmoddb} (int whichmod, Pos\+Type q, Pos\+Type b)
\item 
virtual Pos\+Type {\bfseries dmoddq} (int whichmod, Pos\+Type q, Pos\+Type b)
\item 
virtual Pos\+Type {\bfseries ddmoddq} (int whichmod, Pos\+Type q, Pos\+Type b)
\item 
void \mbox{\hyperlink{class_lens_halo_a825833ac8df009db76b5e4b4b4e140f9}{faxial}} (Pos\+Type x, Pos\+Type theta, Pos\+Type f\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em If set to true the correct normalization is applied for asymmetric NFW profiles, the mass\+\_\+norm\+\_\+factor is different for the other halos. \end{DoxyCompactList}\item 
void {\bfseries faxial0} (Pos\+Type theta, Pos\+Type f0\mbox{[}$\,$\mbox{]})
\item 
void {\bfseries faxial1} (Pos\+Type theta, Pos\+Type f1\mbox{[}$\,$\mbox{]})
\item 
void {\bfseries faxial2} (Pos\+Type theta, Pos\+Type f2\mbox{[}$\,$\mbox{]})
\item 
void {\bfseries gradial} (Pos\+Type r, Pos\+Type g\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Derivatives of the potential damping factor with respect to r ... TODO\+: come up with a better damping faction. \end{DoxyCompactList}\item 
void {\bfseries gradial2} (Pos\+Type r, Pos\+Type mu, Pos\+Type sigma, Pos\+Type g\mbox{[}$\,$\mbox{]})
\item 
void \mbox{\hyperlink{class_lens_halo_a70d44bd2ef4edee5fb918a61cf5d3fcf}{felliptical}} (Pos\+Type x, Pos\+Type q, Pos\+Type theta, Pos\+Type f\mbox{[}$\,$\mbox{]}, Pos\+Type g\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Calculate the derivatives of the G function = r\texorpdfstring{$\ast$}{*}sqrt(cos(theta)\texorpdfstring{$^\wedge$}{\string^}2 + q(r)\texorpdfstring{$^\wedge$}{\string^}2 sin(theta)) \end{DoxyCompactList}\item 
virtual void {\bfseries gamma\+\_\+asym} (Pos\+Type x, Pos\+Type theta, Pos\+Type gamma\mbox{[}$\,$\mbox{]})
\item 
virtual Pos\+Type \mbox{\hyperlink{class_lens_halo_ac3f16aeffae590925d115799698ebaf4}{kappa\+\_\+asym}} (Pos\+Type x, Pos\+Type theta)
\item 
virtual void \mbox{\hyperlink{class_lens_halo_a7e68cb08c90a52d21f6af474acfc20e2}{alphakappagamma\+\_\+asym}} (Pos\+Type x, Pos\+Type theta, Pos\+Type alpha\mbox{[}$\,$\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}kappa, Pos\+Type gamma\mbox{[}$\,$\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}phi)
\begin{DoxyCompactList}\small\item\em Pseudo-\/elliptical profiles by Phi(\+G)-\/Ansatz. \end{DoxyCompactList}\item 
virtual void \mbox{\hyperlink{class_lens_halo_ab90367cd516c00c93e8608894732e965}{alphakappagamma1asym}} (Pos\+Type x, Pos\+Type theta, Pos\+Type alpha\mbox{[}2\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}kappa, Pos\+Type gamma\mbox{[}$\,$\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}phi)
\begin{DoxyCompactList}\small\item\em Elliptical profiles by Fourier-\/\+Ansatz. \end{DoxyCompactList}\item 
virtual void {\bfseries alphakappagamma2asym} (Pos\+Type x, Pos\+Type theta, Pos\+Type alpha\mbox{[}2\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}kappa, Pos\+Type gamma\mbox{[}$\,$\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}phi)
\item 
virtual void {\bfseries alphakappagamma3asym} (Pos\+Type x, Pos\+Type theta, Pos\+Type alpha\mbox{[}2\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}kappa, Pos\+Type gamma\mbox{[}$\,$\mbox{]}, Pos\+Type \texorpdfstring{$\ast$}{*}phi)
\item 
virtual Pos\+Type {\bfseries alpha\+\_\+ell} (Pos\+Type x, Pos\+Type theta)
\item 
double {\bfseries fourier\+\_\+coeff} (double n, double q, double beta)
\begin{DoxyCompactList}\small\item\em Calculates fourier-\/coefficients for power law halo. \end{DoxyCompactList}\item 
double {\bfseries IDAXDM} (double lambda, double a2, double b2, double x\mbox{[}$\,$\mbox{]}, double rmax, double mo)
\item 
double {\bfseries IDAYDM} (double lambda, double a2, double b2, double x\mbox{[}$\,$\mbox{]}, double rmax, double mo)
\item 
double {\bfseries SCHRAMMKN} (double n, double x\mbox{[}$\,$\mbox{]}, double rmax)
\item 
double {\bfseries SCHRAMMJN} (double n, double x\mbox{[}$\,$\mbox{]}, double rmax)
\item 
double {\bfseries SCHRAMMI} (double x\mbox{[}$\,$\mbox{]}, double rmax)
\item 
void {\bfseries calc\+Modes} (double q, double beta, double rottheta, Pos\+Type newmod\mbox{[}$\,$\mbox{]})
\begin{DoxyCompactList}\small\item\em Calculates the modes for fourier expansion of power law halo. All the modes are relative to the zero mode to conserve mass throughout the calculation of kappa etc. \end{DoxyCompactList}\item 
void {\bfseries calc\+ModesB} (Pos\+Type x, double q, double beta, double rottheta, Pos\+Type newmod\mbox{[}$\,$\mbox{]})
\item 
void {\bfseries calc\+ModesC} (Pos\+Type beta\+\_\+r, double q, double rottheta, Pos\+Type newmod\mbox{[}$\,$\mbox{]})
\item 
virtual Pos\+Type {\bfseries Interpolate\+Modes} (int whichmod, Pos\+Type q, Pos\+Type b)
\item 
void \mbox{\hyperlink{class_lens_halo_affb1ead96e81d87f61d45e09a6f6fb3f}{anal\+Modes}} (int modnumber, Pos\+Type my\+\_\+beta, Pos\+Type q, Pos\+Type amod\mbox{[}3\mbox{]})
\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Member Functions inherited from \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles$<$ Particle\+Type$<$ float $>$ $>$}}}
\begin{DoxyCompactItemize}
\item 
static void {\bfseries smooth\+\_\+} (\mbox{\hyperlink{class_tree_simple}{Tree\+Simple}}$<$ Particle\+Type$<$ float $>$ $>$ \texorpdfstring{$\ast$}{*}tree3d, Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*}xp, size\+\_\+t N, int Nsmooth)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{class_lens_halo_particles}{Lens\+Halo\+Particles$<$ Particle\+Type$<$ float $>$ $>$}}}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_point__3d}{Point\+\_\+3d}} {\bfseries mcenter}
\item 
\mbox{\hyperlink{struct_point__3d}{Point\+\_\+3d}} {\bfseries densest\+\_\+point}
\item 
Particle\+Type$<$ float $>$ \texorpdfstring{$\ast$}{*} {\bfseries pp}
\item 
std\+::vector$<$ Particle\+Type$<$ float $>$ $>$ {\bfseries trash\+\_\+collector}
\item 
Pos\+Type {\bfseries min\+\_\+size}
\item 
bool {\bfseries multimass}
\item 
\mbox{\hyperlink{class_utilities_1_1_geometry_1_1_spherical_point}{Utilities\+::\+Geometry\+::\+Spherical\+Point}} {\bfseries center}
\item 
size\+\_\+t {\bfseries Npoints}
\item 
Pos\+Type {\bfseries inv\+\_\+area}
\item 
std\+::string {\bfseries simfile}
\item 
std\+::string {\bfseries sizefile}
\item 
\mbox{\hyperlink{class_tree_quad_particles}{Tree\+Quad\+Particles}}$<$ Particle\+Type$<$ float $>$ $>$ \texorpdfstring{$\ast$}{*} {\bfseries qtree}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
float {\bfseries Rsize} = 0
\item 
float {\bfseries mass}
\item 
Pos\+Type {\bfseries Dist}
\item 
Pos\+Type {\bfseries mnorm}
\item 
float {\bfseries Rmax}
\item 
Pos\+Type {\bfseries beta}
\item 
float {\bfseries Rmax\+\_\+to\+\_\+\+Rsize\+\_\+ratio} = 1.\+2
\begin{DoxyCompactList}\small\item\em The factor by which Rmax is larger than Rsize. \end{DoxyCompactList}\item 
float {\bfseries rscale}
\begin{DoxyCompactList}\small\item\em scale length or core size. Different meaning in different cases. Not used in NSIE case. \end{DoxyCompactList}\item 
\mbox{\hyperlink{_input_params_8h_abeeb8c8413457c56ac46767a52fc2618}{Ellip\+Method}} {\bfseries main\+\_\+ellip\+\_\+method}
\item 
Pos\+Type {\bfseries xmax}
\item 
Pos\+Type {\bfseries mass\+\_\+norm\+\_\+factor} =1
\begin{DoxyCompactList}\small\item\em This is Rsize/rscale !! \end{DoxyCompactList}\item 
float {\bfseries pa}
\item 
float {\bfseries fratio} =1.\+0
\item 
bool {\bfseries elliptical\+\_\+flag} = false
\item 
bool {\bfseries switch\+\_\+flag} = false
\item 
Pos\+Type {\bfseries mod} \mbox{[}Nmod\mbox{]}
\item 
Pos\+Type {\bfseries mod1} \mbox{[}Nmod\mbox{]}
\item 
Pos\+Type {\bfseries mod2} \mbox{[}Nmod\mbox{]}
\item 
Pos\+Type {\bfseries r\+\_\+eps}
\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Attributes inherited from \mbox{\hyperlink{class_lens_halo}{Lens\+Halo}}}
\begin{DoxyCompactItemize}
\item 
static const int {\bfseries Nmod} = 32
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T = float$>$\newline
class Lens\+Halo\+Disk$<$ T $>$}
Creates a exponential disk out of particles. 

The disk is created out of particles and the smoothing done by nearest-\/N neighbour B-\/spline smoothing as if they came from a simulation, but they are placed more regularly so that the surface density is relatively smooth. 

\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{class_lens_halo_disk_a67f57cb9d8ae287d948efeee3be962bb}\index{LensHaloDisk$<$ T $>$@{LensHaloDisk$<$ T $>$}!LensHaloDisk@{LensHaloDisk}}
\index{LensHaloDisk@{LensHaloDisk}!LensHaloDisk$<$ T $>$@{LensHaloDisk$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{LensHaloDisk()}{LensHaloDisk()}}
{\footnotesize\ttfamily \label{class_lens_halo_disk_a67f57cb9d8ae287d948efeee3be962bb} 
template$<$typename T $>$ \\
\mbox{\hyperlink{class_lens_halo_disk}{Lens\+Halo\+Disk}}$<$ T $>$\mbox{\hyperlink{class_lens_halo_disk}{\+::\+Lens\+Halo\+Disk}} (\begin{DoxyParamCaption}\item[{double}]{mass}{, }\item[{double}]{disk\+\_\+scale}{, }\item[{double}]{Rperp}{, }\item[{double}]{mass\+\_\+res}{, }\item[{float}]{my\+\_\+\+PA}{, }\item[{float}]{my\+\_\+inclination}{, }\item[{\mbox{\hyperlink{class_utilities_1_1_random_numbers___n_r}{Utilities\+::\+Random\+Numbers\+\_\+\+NR}} \&}]{ran}{, }\item[{float}]{redshift}{, }\item[{const \mbox{\hyperlink{class_c_o_s_m_o_l_o_g_y}{COSMOLOGY}} \&}]{cosmo}{, }\item[{int}]{Nsmooth}{ = {\ttfamily 64}}\end{DoxyParamCaption})}

set up base Lenshalo

(1-\/x);
\begin{DoxyParams}{Parameters}
{\em mass} & mass of disk  \\
\hline
{\em disk\+\_\+scale} & scale hight of disk (Mpc)  \\
\hline
{\em Rperp} & vertical scale hight of disk (Mpc)  \\
\hline
{\em mass\+\_\+res} & mass resolution, mass of particles  \\
\hline
{\em my\+\_\+\+PA} & position angle in radians  \\
\hline
{\em my\+\_\+inclination} & inclination of disk in radians, 0 is face on  \\
\hline
{\em ran} & random number generator  \\
\hline
{\em Nsmooth} & number of neighbors used in smoothing \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
SLsim\+Lib/include/disk.\+h\end{DoxyCompactItemize}
